(self.webpackChunkangular_vanta_app=self.webpackChunkangular_vanta_app||[]).push([[179],{833:function(pc){typeof self<"u"&&self,pc.exports=function(Lr){var Tt={};function it(pe){if(Tt[pe])return Tt[pe].exports;var vt=Tt[pe]={i:pe,l:!1,exports:{}};return Lr[pe].call(vt.exports,vt,vt.exports,it),vt.l=!0,vt.exports}return it.m=Lr,it.c=Tt,it.d=function(pe,vt,gn){it.o(pe,vt)||Object.defineProperty(pe,vt,{enumerable:!0,get:gn})},it.r=function(pe){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(pe,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(pe,"__esModule",{value:!0})},it.t=function(pe,vt){if(1&vt&&(pe=it(pe)),8&vt||4&vt&&"object"==typeof pe&&pe&&pe.__esModule)return pe;var gn=Object.create(null);if(it.r(gn),Object.defineProperty(gn,"default",{enumerable:!0,value:pe}),2&vt&&"string"!=typeof pe)for(var on in pe)it.d(gn,on,function(en){return pe[en]}.bind(null,on));return gn},it.n=function(pe){var vt=pe&&pe.__esModule?function(){return pe.default}:function(){return pe};return it.d(vt,"a",vt),vt},it.o=function(pe,vt){return Object.prototype.hasOwnProperty.call(pe,vt)},it.p="",it(it.s=18)}({0:function(Lr,Tt,it){"use strict";function pe(){return typeof navigator<"u"?/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||window.innerWidth<600:null}it.d(Tt,"e",function(){return pe}),it.d(Tt,"i",function(){return vt}),it.d(Tt,"h",function(){return gn}),it.d(Tt,"g",function(){return on}),it.d(Tt,"f",function(){return en}),it.d(Tt,"b",function(){return me}),it.d(Tt,"c",function(){return Ae}),it.d(Tt,"d",function(){return $e}),it.d(Tt,"a",function(){return Ge}),Number.prototype.clamp=function(Le,Xt){return Math.min(Math.max(this,Le),Xt)};const vt=Le=>Le[Math.floor(Math.random()*Le.length)];function gn(Le,Xt){return null==Le&&(Le=0),null==Xt&&(Xt=1),Le+Math.random()*(Xt-Le)}function on(Le,Xt){return null==Le&&(Le=0),null==Xt&&(Xt=1),Math.floor(Le+Math.random()*(Xt-Le+1))}const en=Le=>document.querySelector(Le),me=Le=>"number"==typeof Le?"#"+("00000"+Le.toString(16)).slice(-6):Le,Ae=(Le,Xt=1)=>{const Uo=me(Le),Rr=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(Uo),lo=Rr?{r:parseInt(Rr[1],16),g:parseInt(Rr[2],16),b:parseInt(Rr[3],16)}:null;return"rgba("+lo.r+","+lo.g+","+lo.b+","+Xt+")"},$e=Le=>.299*Le.r+.587*Le.g+.114*Le.b;function Ge(Le){for(;Le.children&&Le.children.length>0;)Ge(Le.children[0]),Le.remove(Le.children[0]);Le.geometry&&Le.geometry.dispose(),Le.material&&(Object.keys(Le.material).forEach(Xt=>{Le.material[Xt]&&null!==Le.material[Xt]&&"function"==typeof Le.material[Xt].dispose&&Le.material[Xt].dispose()}),Le.material.dispose())}},1:function(Lr,Tt,it){"use strict";it.d(Tt,"a",function(){return on});var pe=it(0);const vt="object"==typeof window;let gn=vt&&window.THREE||{};vt&&!window.VANTA&&(window.VANTA={});const on=vt&&window.VANTA||{};on.register=(me,Ae)=>on[me]=$e=>new Ae($e),on.version="0.5.22";const en=function(){return Array.prototype.unshift.call(arguments,"[VANTA]"),console.error.apply(this,arguments)};on.VantaBase=class{constructor(me={}){if(!vt)return!1;on.current=this,this.windowMouseMoveWrapper=this.windowMouseMoveWrapper.bind(this),this.windowTouchWrapper=this.windowTouchWrapper.bind(this),this.windowGyroWrapper=this.windowGyroWrapper.bind(this),this.resize=this.resize.bind(this),this.animationLoop=this.animationLoop.bind(this),this.restart=this.restart.bind(this);const Ae="function"==typeof this.getDefaultOptions?this.getDefaultOptions():this.defaultOptions;if(this.options=Object.assign({mouseControls:!0,touchControls:!0,gyroControls:!1,minHeight:200,minWidth:200,scale:1,scaleMobile:1},Ae),(me instanceof HTMLElement||"string"==typeof me)&&(me={el:me}),Object.assign(this.options,me),this.options.THREE&&(gn=this.options.THREE),this.el=this.options.el,null==this.el)en('Instance needs "el" param!');else if(!(this.options.el instanceof HTMLElement)){const Ge=this.el;if(this.el=Object(pe.f)(Ge),!this.el)return void en("Cannot find element",Ge)}this.prepareEl(),this.initThree(),this.setSize();try{this.init()}catch(Ge){return en("Init error",Ge),this.renderer&&this.renderer.domElement&&this.el.removeChild(this.renderer.domElement),void(this.options.backgroundColor&&(console.log("[VANTA] Falling back to backgroundColor"),this.el.style.background=Object(pe.b)(this.options.backgroundColor)))}this.initMouse(),this.resize(),this.animationLoop();const $e=window.addEventListener;$e("resize",this.resize),window.requestAnimationFrame(this.resize),this.options.mouseControls&&($e("scroll",this.windowMouseMoveWrapper),$e("mousemove",this.windowMouseMoveWrapper)),this.options.touchControls&&($e("touchstart",this.windowTouchWrapper),$e("touchmove",this.windowTouchWrapper)),this.options.gyroControls&&$e("deviceorientation",this.windowGyroWrapper)}setOptions(me={}){Object.assign(this.options,me),this.triggerMouseMove()}prepareEl(){let me,Ae;if(typeof Node<"u"&&Node.TEXT_NODE)for(me=0;me<this.el.childNodes.length;me++){const $e=this.el.childNodes[me];if($e.nodeType===Node.TEXT_NODE){const Ge=document.createElement("span");Ge.textContent=$e.textContent,$e.parentElement.insertBefore(Ge,$e),$e.remove()}}for(me=0;me<this.el.children.length;me++)Ae=this.el.children[me],"static"===getComputedStyle(Ae).position&&(Ae.style.position="relative"),"auto"===getComputedStyle(Ae).zIndex&&(Ae.style.zIndex=1);"static"===getComputedStyle(this.el).position&&(this.el.style.position="relative")}applyCanvasStyles(me,Ae={}){Object.assign(me.style,{position:"absolute",zIndex:0,top:0,left:0,background:""}),Object.assign(me.style,Ae),me.classList.add("vanta-canvas")}initThree(){gn.WebGLRenderer?(this.renderer=new gn.WebGLRenderer({alpha:!0,antialias:!0}),this.el.appendChild(this.renderer.domElement),this.applyCanvasStyles(this.renderer.domElement),isNaN(this.options.backgroundAlpha)&&(this.options.backgroundAlpha=1),this.scene=new gn.Scene):console.warn("[VANTA] No THREE defined on window")}getCanvasElement(){return this.renderer?this.renderer.domElement:this.p5renderer?this.p5renderer.canvas:void 0}getCanvasRect(){const me=this.getCanvasElement();return!!me&&me.getBoundingClientRect()}windowMouseMoveWrapper(me){const Ae=this.getCanvasRect();if(!Ae)return!1;const $e=me.clientX-Ae.left,Ge=me.clientY-Ae.top;$e>=0&&Ge>=0&&$e<=Ae.width&&Ge<=Ae.height&&(this.mouseX=$e,this.mouseY=Ge,this.options.mouseEase||this.triggerMouseMove($e,Ge))}windowTouchWrapper(me){const Ae=this.getCanvasRect();if(!Ae)return!1;if(1===me.touches.length){const $e=me.touches[0].clientX-Ae.left,Ge=me.touches[0].clientY-Ae.top;$e>=0&&Ge>=0&&$e<=Ae.width&&Ge<=Ae.height&&(this.mouseX=$e,this.mouseY=Ge,this.options.mouseEase||this.triggerMouseMove($e,Ge))}}windowGyroWrapper(me){const Ae=this.getCanvasRect();if(!Ae)return!1;const $e=Math.round(2*me.alpha)-Ae.left,Ge=Math.round(2*me.beta)-Ae.top;$e>=0&&Ge>=0&&$e<=Ae.width&&Ge<=Ae.height&&(this.mouseX=$e,this.mouseY=Ge,this.options.mouseEase||this.triggerMouseMove($e,Ge))}triggerMouseMove(me,Ae){void 0===me&&void 0===Ae&&(this.options.mouseEase?(me=this.mouseEaseX,Ae=this.mouseEaseY):(me=this.mouseX,Ae=this.mouseY)),this.uniforms&&(this.uniforms.iMouse.value.x=me/this.scale,this.uniforms.iMouse.value.y=Ae/this.scale),"function"==typeof this.onMouseMove&&this.onMouseMove(me/this.width,Ae/this.height)}setSize(){this.scale||(this.scale=1),Object(pe.e)()&&this.options.scaleMobile?this.scale=this.options.scaleMobile:this.options.scale&&(this.scale=this.options.scale),this.width=Math.max(this.el.offsetWidth,this.options.minWidth),this.height=Math.max(this.el.offsetHeight,this.options.minHeight)}initMouse(){(!this.mouseX&&!this.mouseY||this.mouseX===this.options.minWidth/2&&this.mouseY===this.options.minHeight/2)&&(this.mouseX=this.width/2,this.mouseY=this.height/2,this.triggerMouseMove(this.mouseX,this.mouseY))}resize(){this.setSize(),this.camera&&(this.camera.aspect=this.width/this.height,"function"==typeof this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix()),this.renderer&&(this.renderer.setSize(this.width,this.height),this.renderer.setPixelRatio(window.devicePixelRatio/this.scale)),"function"==typeof this.onResize&&this.onResize()}isOnScreen(){const me=this.el.offsetHeight,Ae=this.el.getBoundingClientRect(),$e=window.pageYOffset||(document.documentElement||document.body.parentNode||document.body).scrollTop,Ge=Ae.top+$e;return Ge-window.innerHeight<=$e&&$e<=Ge+me}animationLoop(){return this.t||(this.t=0),this.t+=1,this.t2||(this.t2=0),this.t2+=this.options.speed||1,this.uniforms&&(this.uniforms.iTime.value=.016667*this.t2),this.options.mouseEase&&(this.mouseEaseX=this.mouseEaseX||this.mouseX||0,this.mouseEaseY=this.mouseEaseY||this.mouseY||0,Math.abs(this.mouseEaseX-this.mouseX)+Math.abs(this.mouseEaseY-this.mouseY)>.1&&(this.mouseEaseX+=.05*(this.mouseX-this.mouseEaseX),this.mouseEaseY+=.05*(this.mouseY-this.mouseEaseY),this.triggerMouseMove(this.mouseEaseX,this.mouseEaseY))),(this.isOnScreen()||this.options.forceAnimate)&&("function"==typeof this.onUpdate&&this.onUpdate(),this.scene&&this.camera&&(this.renderer.render(this.scene,this.camera),this.renderer.setClearColor(this.options.backgroundColor,this.options.backgroundAlpha)),this.fps&&this.fps.update&&this.fps.update(),"function"==typeof this.afterRender&&this.afterRender()),this.req=window.requestAnimationFrame(this.animationLoop)}restart(){if(this.scene)for(;this.scene.children.length;)this.scene.remove(this.scene.children[0]);"function"==typeof this.onRestart&&this.onRestart(),this.init()}init(){"function"==typeof this.onInit&&this.onInit()}destroy(){"function"==typeof this.onDestroy&&this.onDestroy();const me=window.removeEventListener;me("touchstart",this.windowTouchWrapper),me("touchmove",this.windowTouchWrapper),me("scroll",this.windowMouseMoveWrapper),me("mousemove",this.windowMouseMoveWrapper),me("deviceorientation",this.windowGyroWrapper),me("resize",this.resize),window.cancelAnimationFrame(this.req);const Ae=this.scene;Ae&&Ae.children&&Object(pe.a)(Ae),this.renderer&&(this.renderer.domElement&&this.el.removeChild(this.renderer.domElement),this.renderer=null,this.scene=null),on.current===this&&(on.current=null)}},Tt.b=on.VantaBase},18:function(Lr,Tt,it){"use strict";it.r(Tt);var pe=it(1),vt=it(0);let gn="object"==typeof window&&window.THREE,{Camera:on,ClampToEdgeWrapping:en,DataTexture:me,FloatType:Ae,Mesh:$e,NearestFilter:Ge,PlaneBufferGeometry:Le,RGBAFormat:Xt,Scene:Uo,ShaderMaterial:Rr,WebGLRenderTarget:lo}=gn||{};var _h=function(rt,fe,ee,ze){ze&&({Camera:on,ClampToEdgeWrapping:en,DataTexture:me,FloatType:Ae,Mesh:$e,NearestFilter:Ge,PlaneBufferGeometry:Le,RGBAFormat:Xt,Scene:Uo,ShaderMaterial:Rr,WebGLRenderTarget:lo}=ze),this.variables=[],this.currentTextureIndex=0;var le=Ae,Ve=new Uo,Ie=new on;Ie.position.z=1;var we={passThruTexture:{value:null}},ht=je("uniform sampler2D passThruTexture;\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\tgl_FragColor = texture2D( passThruTexture, uv );\n\n}\n",we),De=new $e(new Le(2,2),ht);function dt(be){be.defines.resolution="vec2( "+rt.toFixed(1)+", "+fe.toFixed(1)+" )"}function je(be,de){var Dt=new Rr({uniforms:de=de||{},vertexShader:"void main()\t{\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n",fragmentShader:be});return dt(Dt),Dt}Ve.add(De),this.setDataType=function(be){return le=be,this},this.addVariable=function(be,de,Dt){var jt={name:be,initialValueTexture:Dt,material:this.createShaderMaterial(de),dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:Ge,magFilter:Ge};return this.variables.push(jt),jt},this.setVariableDependencies=function(be,de){be.dependencies=de},this.init=function(){if(!ee.capabilities.isWebGL2&&!ee.extensions.get("OES_texture_float"))return"No OES_texture_float support for float textures.";if(0===ee.capabilities.maxVertexTextures)return"No support for vertex shader textures.";for(var be=0;be<this.variables.length;be++){var de=this.variables[be];de.renderTargets[0]=this.createRenderTarget(rt,fe,de.wrapS,de.wrapT,de.minFilter,de.magFilter),de.renderTargets[1]=this.createRenderTarget(rt,fe,de.wrapS,de.wrapT,de.minFilter,de.magFilter),this.renderTexture(de.initialValueTexture,de.renderTargets[0]),this.renderTexture(de.initialValueTexture,de.renderTargets[1]);var Dt=de.material,jt=Dt.uniforms;if(null!==de.dependencies)for(var Ut=0;Ut<de.dependencies.length;Ut++){var sn=de.dependencies[Ut];if(sn.name!==de.name){for(var ai=!1,Si=0;Si<this.variables.length;Si++)if(sn.name===this.variables[Si].name){ai=!0;break}if(!ai)return"Variable dependency not found. Variable="+de.name+", dependency="+sn.name}jt[sn.name]={value:null},Dt.fragmentShader="\nuniform sampler2D "+sn.name+";\n"+Dt.fragmentShader}}return this.currentTextureIndex=0,null},this.compute=function(){for(var be=this.currentTextureIndex,de=0===this.currentTextureIndex?1:0,Dt=0,jt=this.variables.length;Dt<jt;Dt++){var Ut=this.variables[Dt];if(null!==Ut.dependencies)for(var sn=Ut.material.uniforms,ai=0,Si=Ut.dependencies.length;ai<Si;ai++){var _u=Ut.dependencies[ai];sn[_u.name].value=_u.renderTargets[be].texture}this.doRenderTarget(Ut.material,Ut.renderTargets[de])}this.currentTextureIndex=de},this.getCurrentRenderTarget=function(be){return be.renderTargets[this.currentTextureIndex]},this.getAlternateRenderTarget=function(be){return be.renderTargets[0===this.currentTextureIndex?1:0]},this.addResolutionDefine=dt,this.createShaderMaterial=je,this.createRenderTarget=function(be,de,Dt,jt,Ut,sn){return new lo(be=be||rt,de=de||fe,{wrapS:Dt=Dt||en,wrapT:jt=jt||en,minFilter:Ut=Ut||Ge,magFilter:sn=sn||Ge,format:Xt,type:le,stencilBuffer:!1,depthBuffer:!1})},this.createTexture=function(){var be=new Float32Array(rt*fe*4);return new me(be,rt,fe,Xt,Ae)},this.renderTexture=function(be,de){we.passThruTexture.value=be,this.doRenderTarget(ht,de),we.passThruTexture.value=null},this.doRenderTarget=function(be,de){var Dt=ee.getRenderTarget();De.material=be,ee.setRenderTarget(de),ee.render(Ve,Ie),De.material=ht,ee.setRenderTarget(Dt)}};let Mt="object"==typeof window&&window.THREE;const ki=!Object(vt.e)();let Ln=32,Rs=Ln*Ln;let Go,yu;class bh extends pe.b{static initClass(){this.prototype.defaultOptions={backgroundColor:465199,color1:16711680,color2:53759,colorMode:"varianceGradient",birdSize:1,wingSpan:30,speedLimit:5,separation:20,alignment:20,cohesion:20,quantity:5}}constructor(fe){var rt;Mt=fe.THREE||Mt,rt=Mt,Go=function(fe={}){var ee=this;function ze(Ve,Ie,we){const ht=1.5*(fe.birdSize||1);ee.vertices.push(new rt.Vector3(Ve*ht,Ie*ht,we*ht))}function le(Ve,Ie,we){ee.faces.push(new rt.Face3(Ve,Ie,we))}rt.Geometry.call(this),ze(5,0,0),ze(-5,-1,1),ze(-5,0,0),ze(-5,-2,-1),ze(0,2,-6),ze(0,2,6),ze(2,0,0),ze(-3,0,0),le(0,2,1),le(4,7,6),le(5,6,7),this.computeFaceNormals()},Go.prototype=Object.create(rt.Geometry.prototype),yu=function(fe){var ee,ze,le=new rt.Vector3,Ve=500,Ie=500,we=200,ht=fe;this.position=new rt.Vector3,this.velocity=new rt.Vector3,ee=new rt.Vector3,this.setGoal=function(De){ze=De},this.setWorldSize=function(De,dt,je){Ve=De,Ie=dt,we=je},this.run=function(De){le.set(-Ve,this.position.y,this.position.z),(le=this.avoid(le)).multiplyScalar(5),ee.add(le),le.set(Ve,this.position.y,this.position.z),(le=this.avoid(le)).multiplyScalar(5),ee.add(le),le.set(this.position.x,-Ie,this.position.z),(le=this.avoid(le)).multiplyScalar(5),ee.add(le),le.set(this.position.x,Ie,this.position.z),(le=this.avoid(le)).multiplyScalar(5),ee.add(le),le.set(this.position.x,this.position.y,-we),(le=this.avoid(le)).multiplyScalar(5),ee.add(le),le.set(this.position.x,this.position.y,we),(le=this.avoid(le)).multiplyScalar(5),ee.add(le),Math.random()>.5&&this.flock(De),this.move()},this.flock=function(De){ze&&ee.add(this.reach(ze,.005)),ee.add(this.alignment(De)),ee.add(this.cohesion(De)),ee.add(this.separation(De))},this.move=function(){this.velocity.add(ee);var De=this.velocity.length();De>2.5&&this.velocity.divideScalar(De/2.5),this.position.add(this.velocity),ee.set(0,0,0)},this.checkBounds=function(){this.position.x>Ve&&(this.position.x=-Ve),this.position.x<-Ve&&(this.position.x=Ve),this.position.y>Ie&&(this.position.y=-Ie),this.position.y<-Ie&&(this.position.y=Ie),this.position.z>we&&(this.position.z=-we),this.position.z<-we&&(this.position.z=we)},this.avoid=function(De){var dt=new rt.Vector3;return dt.copy(this.position),dt.sub(De),dt.multiplyScalar(1/this.position.distanceToSquared(De)),dt},this.repulse=function(De){var dt=this.position.distanceTo(De);if(dt<150){var je=new rt.Vector3;je.subVectors(this.position,De),je.multiplyScalar(.5/dt),ee.add(je)}},this.reach=function(De,dt){var je=new rt.Vector3;return je.subVectors(De,this.position),je.multiplyScalar(dt),je},this.alignment=function(De){var dt,je,be=new rt.Vector3,de=0;const Dt=100*ht.alignment/20;for(var jt=0,Ut=De.length;jt<Ut;jt++)Math.random()>.6||(je=(dt=De[jt]).position.distanceTo(this.position))>0&&je<=Dt&&(be.add(dt.velocity),de++);if(de>0){be.divideScalar(de);var sn=be.length();sn>.1&&be.divideScalar(sn/.1)}return be},this.cohesion=function(De){var dt,je,be=new rt.Vector3,de=new rt.Vector3,Dt=0;const jt=100*ht.cohesion/20;for(var Ut=0,sn=De.length;Ut<sn;Ut++)Math.random()>.6||(je=(dt=De[Ut]).position.distanceTo(this.position))>0&&je<=jt&&(be.add(dt.position),Dt++);Dt>0&&be.divideScalar(Dt),de.subVectors(be,this.position);var ai=de.length();return ai>.1&&de.divideScalar(ai/.1),de},this.separation=function(De){var dt,je,be=new rt.Vector3,de=new rt.Vector3;const Dt=100*ht.separation/20;for(var jt=0,Ut=De.length;jt<Ut;jt++)Math.random()>.6||(je=(dt=De[jt]).position.distanceTo(this.position))>0&&je<=Dt&&(de.subVectors(this.position,dt.position),de.normalize(),de.divideScalar(je),be.add(de));return be}},rt.BirdGeometry=function(fe){fe.quantity&&(Ln=Math.pow(2,fe.quantity),Rs=Ln*Ln);const ee=3*Rs,ze=3*ee;rt.BufferGeometry.call(this);const le=new rt.BufferAttribute(new Float32Array(3*ze),3),Ve=new rt.BufferAttribute(new Float32Array(3*ze),3),Ie=new rt.BufferAttribute(new Float32Array(2*ze),2),we=new rt.BufferAttribute(new Float32Array(ze),1);this.setAttribute||(this.setAttribute=this.addAttribute),this.setAttribute("position",le),this.setAttribute("birdColor",Ve),this.setAttribute("reference",Ie),this.setAttribute("birdVertex",we);let ht=0;const De=function(){for(let de=0;de<arguments.length;de++)le.array[ht++]=arguments[de]},dt=fe.wingSpan||20,je=fe.birdSize||1;for(let de=0;de<Rs;de++)De(0,-0,-20*je,0,4*je,-20*je,0,0,30*je),De(0,0,-15*je,-dt*je,0,0,0,0,15*je),De(0,0,15*je,dt*je,0,0,0,0,-15*je);const be={};for(ht=0;ht<3*ee;ht++){const de=~~(ht/3),Dt=de%Ln/Ln,jt=~~(de/Ln)/Ln,Ut=~~(ht/9)/Rs,sn=Ut.toString(),ai=-1!=fe.colorMode.indexOf("Gradient");let Si;Si=!ai&&be[sn]?be[sn]:fe.effect.getNewCol(Ut),ai||be[sn]||(be[sn]=Si),Ve.array[3*ht+0]=Si.r,Ve.array[3*ht+1]=Si.g,Ve.array[3*ht+2]=Si.b,Ie.array[2*ht]=Dt,Ie.array[2*ht+1]=jt,we.array[ht]=ht%9}return this.scale(.2,.2,.2)},rt.BirdGeometry.prototype=Object.create(rt.BufferGeometry.prototype),super(fe)}initComputeRenderer(){this.gpuCompute=new _h(Ln,Ln,this.renderer,Mt);const fe=this.gpuCompute.createTexture(),ee=this.gpuCompute.createTexture();(function(rt){const fe=rt.image.data;let ee=0;const ze=fe.length;(()=>{const le=[];for(;ee<ze;){const Ve=800*Math.random()-400,Ie=800*Math.random()-400,we=800*Math.random()-400;fe[ee+0]=Ve,fe[ee+1]=Ie,fe[ee+2]=we,fe[ee+3]=1,le.push(ee+=4)}})()})(fe),function(rt){const fe=rt.image.data;let ee=0;const ze=fe.length;(()=>{const le=[];for(;ee<ze;){const Ve=Math.random()-.5,Ie=Math.random()-.5,we=Math.random()-.5;fe[ee+0]=10*Ve,fe[ee+1]=10*Ie,fe[ee+2]=10*we,fe[ee+3]=1,le.push(ee+=4)}})()}(ee),this.velocityVariable=this.gpuCompute.addVariable("textureVelocity","uniform float time;\nuniform float testing;\nuniform float delta; // about 0.016\nuniform float separationDistance; // 20\nuniform float alignmentDistance; // 40\nuniform float cohesionDistance;\nuniform float speedLimit;\nuniform float freedomFactor;\nuniform vec3 predator;\n\nconst float width = resolution.x;\nconst float height = resolution.y;\n\nconst float PI = 3.141592653589793;\nconst float PI_2 = PI * 2.0;\n// const float VISION = PI * 0.55;\n\nfloat zoneRadius = 40.0;\nfloat zoneRadiusSquared = 1600.0;\n\nfloat separationThresh = 0.45;\nfloat alignmentThresh = 0.65;\n\nconst float UPPER_BOUNDS = BOUNDS;\nconst float LOWER_BOUNDS = -UPPER_BOUNDS;\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n\n  zoneRadius = separationDistance + alignmentDistance + cohesionDistance;\n  separationThresh = separationDistance / zoneRadius;\n  alignmentThresh = ( separationDistance + alignmentDistance ) / zoneRadius;\n  zoneRadiusSquared = zoneRadius * zoneRadius;\n\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  vec3 birdPosition, birdVelocity;\n\n  vec3 selfPosition = texture2D( texturePosition, uv ).xyz;\n  vec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;\n\n  float dist;\n  vec3 dir; // direction\n  float distSquared;\n\n  float separationSquared = separationDistance * separationDistance;\n  float cohesionSquared = cohesionDistance * cohesionDistance;\n\n  float f;\n  float percent;\n\n  vec3 velocity = selfVelocity;\n\n  float limit = speedLimit;\n\n  dir = predator * UPPER_BOUNDS - selfPosition;\n  dir.z = 0.;\n  // dir.z *= 0.6;\n  dist = length( dir );\n  distSquared = dist * dist;\n\n  float preyRadius = 150.0;\n  float preyRadiusSq = preyRadius * preyRadius;\n\n  // move birds away from predator\n  if (dist < preyRadius) {\n\n    f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;\n    velocity += normalize( dir ) * f;\n    limit += 5.0;\n  }\n\n  // if (testing == 0.0) {}\n  // if ( rand( uv + time ) < freedomFactor ) {}\n\n  // Attract flocks to the center\n  vec3 central = vec3( 0., 0., 0. );\n  dir = selfPosition - central;\n  dist = length( dir );\n\n  dir.y *= 2.5;\n  velocity -= normalize( dir ) * delta * 5.;\n\n  for (float y=0.0;y<height;y++) {\n    for (float x=0.0;x<width;x++) {\n\n      vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;\n      birdPosition = texture2D( texturePosition, ref ).xyz;\n\n      dir = birdPosition - selfPosition;\n      dist = length(dir);\n\n      if (dist < 0.0001) continue;\n\n      distSquared = dist * dist;\n\n      if (distSquared > zoneRadiusSquared ) continue;\n\n      percent = distSquared / zoneRadiusSquared;\n\n      if ( percent < separationThresh ) { // low\n\n        // Separation - Move apart for comfort\n        f = (separationThresh / percent - 1.0) * delta;\n        velocity -= normalize(dir) * f;\n\n      } else if ( percent < alignmentThresh ) { // high\n\n        // Alignment - fly the same direction\n        float threshDelta = alignmentThresh - separationThresh;\n        float adjustedPercent = ( percent - separationThresh ) / threshDelta;\n\n        birdVelocity = texture2D( textureVelocity, ref ).xyz;\n\n        f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;\n        velocity += normalize(birdVelocity) * f;\n\n      } else {\n\n        // Attraction / Cohesion - move closer\n        float threshDelta = 1.0 - alignmentThresh;\n        float adjustedPercent = ( percent - alignmentThresh ) / threshDelta;\n\n        f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;\n\n        velocity += normalize(dir) * f;\n\n      }\n    }\n  }\n\n  // this make tends to fly around than down or up\n  // if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);\n\n  // Speed Limits\n  if ( length( velocity ) > limit ) {\n    velocity = normalize( velocity ) * limit;\n  }\n\n  gl_FragColor = vec4( velocity, 1.0 );\n\n}",ee),this.positionVariable=this.gpuCompute.addVariable("texturePosition","uniform float time;\nuniform float delta;\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  vec4 tmpPos = texture2D( texturePosition, uv );\n  vec3 position = tmpPos.xyz;\n  vec3 velocity = texture2D( textureVelocity, uv ).xyz;\n\n  float phase = tmpPos.w;\n\n  phase = mod( ( phase + delta +\n    length( velocity.xz ) * delta * 3. +\n    max( velocity.y, 0.0 ) * delta * 6. ), 62.83 );\n\n  gl_FragColor = vec4( position + velocity * delta * 15. , phase );\n\n}",fe),this.gpuCompute.setVariableDependencies(this.velocityVariable,[this.positionVariable,this.velocityVariable]),this.gpuCompute.setVariableDependencies(this.positionVariable,[this.positionVariable,this.velocityVariable]),this.positionUniforms=this.positionVariable.material.uniforms,this.velocityUniforms=this.velocityVariable.material.uniforms,this.positionUniforms.time={value:0},this.positionUniforms.delta={value:0},this.velocityUniforms.time={value:1},this.velocityUniforms.delta={value:0},this.velocityUniforms.testing={value:1},this.velocityUniforms.separationDistance={value:1},this.velocityUniforms.alignmentDistance={value:1},this.velocityUniforms.cohesionDistance={value:1},this.velocityUniforms.speedLimit={value:1},this.velocityUniforms.freedomFactor={value:1},this.velocityUniforms.predator={value:new Mt.Vector3},this.velocityVariable.material.defines.BOUNDS=800..toFixed(2),this.velocityVariable.wrapS=Mt.RepeatWrapping,this.velocityVariable.wrapT=Mt.RepeatWrapping,this.positionVariable.wrapS=Mt.RepeatWrapping,this.positionVariable.wrapT=Mt.RepeatWrapping;const ze=this.gpuCompute.init();null!==ze&&console.error(ze)}initGpgpuBirds(){const fe=Object.assign({},this.options,{effect:this}),ee=new Mt.BirdGeometry(fe);this.birdUniforms={color:{value:new Mt.Color(16720384)},texturePosition:{value:null},textureVelocity:{value:null},time:{value:1},delta:{value:0},birdSize:{value:this.options.birdSize}};const ze=new Mt.ShaderMaterial({uniforms:this.birdUniforms,vertexShader:"attribute vec2 reference;\nattribute float birdVertex;\n\nattribute vec3 birdColor;\n\nuniform sampler2D texturePosition;\nuniform sampler2D textureVelocity;\n\nvarying vec4 vColor;\nvarying float z;\n\nuniform float time;\nuniform float birdSize;\n\nvoid main() {\n\n  vec4 tmpPos = texture2D( texturePosition, reference );\n  vec3 pos = tmpPos.xyz;\n  vec3 velocity = normalize(texture2D( textureVelocity, reference ).xyz);\n\n  vec3 newPosition = position;\n\n  if ( birdVertex == 4.0 || birdVertex == 7.0 ) {\n    // flap wings\n    newPosition.y = sin( tmpPos.w ) * 5. * birdSize;\n  }\n\n  newPosition = mat3( modelMatrix ) * newPosition;\n\n  velocity.z *= -1.;\n  float xz = length( velocity.xz );\n  float xyz = 1.;\n  float x = sqrt( 1. - velocity.y * velocity.y );\n\n  float cosry = velocity.x / xz;\n  float sinry = velocity.z / xz;\n\n  float cosrz = x / xyz;\n  float sinrz = velocity.y / xyz;\n\n  mat3 maty =  mat3(\n    cosry, 0, -sinry,\n    0    , 1, 0     ,\n    sinry, 0, cosry\n  );\n\n  mat3 matz =  mat3(\n    cosrz , sinrz, 0,\n    -sinrz, cosrz, 0,\n    0     , 0    , 1\n  );\n  newPosition =  maty * matz * newPosition;\n  newPosition += pos;\n  z = newPosition.z;\n\n  vColor = vec4( birdColor, 1.0 );\n  gl_Position = projectionMatrix *  viewMatrix  * vec4( newPosition, 1.0 );\n}",fragmentShader:"varying vec4 vColor;\nvarying float z;\nuniform vec3 color;\nvoid main() {\n  // Fake colors for now\n  float rr = 0.2 + ( 1000. - z ) / 1000. * vColor.x;\n  float gg = 0.2 + ( 1000. - z ) / 1000. * vColor.y;\n  float bb = 0.2 + ( 1000. - z ) / 1000. * vColor.z;\n  gl_FragColor = vec4( rr, gg, bb, 1. );\n}",side:Mt.DoubleSide}),le=new Mt.Mesh(ee,ze);return le.rotation.y=Math.PI/2,le.matrixAutoUpdate=!1,le.updateMatrix(),this.scene.add(le)}getNewCol(fe){const ee=this.options,ze=null!=ee.color1?ee.color1:4456448,le=null!=ee.color2?ee.color2:6684672,Ve=new Mt.Color(ze),Ie=new Mt.Color(le);let we,ht;if(ht=-1!=ee.colorMode.indexOf("Gradient")?Math.random():fe,0==ee.colorMode.indexOf("variance")){const De=(Ve.r+Math.random()*Ie.r).clamp(0,1),dt=(Ve.g+Math.random()*Ie.g).clamp(0,1),je=(Ve.b+Math.random()*Ie.b).clamp(0,1);we=new Mt.Color(De,dt,je)}else we=0==ee.colorMode.indexOf("mix")?new Mt.Color(ze+ht*le):Ve.lerp(Ie,ht);return we}onInit(){this.camera=new Mt.PerspectiveCamera(75,this.width/this.height,1,3e3),this.camera.position.z=350,this.fog=new Mt.Fog(16777215,100,1e3),this.mouseX=this.mouseY=0;const fe=this.birds=[],ee=this.boids=[],ze=this.options;let le,Ve;if(ki)try{this.initComputeRenderer(),this.valuesChanger=this.valuesChanger.bind(this),this.valuesChanger(),this.initGpgpuBirds()}catch(De){console.error("[vanta.js] birds init error: ",De)}else{const De=6*Math.pow(2,ze.quantity);for(var Ie=0;Ie<De;Ie++){le=ee[Ie]=new yu(ze),le.position.x=400*Math.random()-200,le.position.y=400*Math.random()-200,le.position.z=400*Math.random()-200,le.velocity.x=2*Math.random()-1,le.velocity.y=2*Math.random()-1,le.velocity.z=2*Math.random()-1,le.setWorldSize(500,500,300);const dt=-1!=ze.colorMode.indexOf("Gradient"),je=new Go(ze);for(var we=0;we<je.faces.length;we++)if(dt)for(var ht=0;ht<3;ht++){const be=this.getNewCol();je.faces[we].vertexColors[ht]=be}else{const be=this.getNewCol(Ie/De);je.faces[we].vertexColors[0]=be,je.faces[we].vertexColors[1]=be,je.faces[we].vertexColors[2]=be}Ve=fe[Ie]=new Mt.Mesh(je,new Mt.MeshBasicMaterial({color:16777215,side:Mt.DoubleSide,vertexColors:Mt.VertexColors})),Ve.phase=Math.floor(62.83*Math.random()),Ve.position.x=ee[Ie].position.x,Ve.position.y=ee[Ie].position.y,Ve.position.z=ee[Ie].position.z,this.scene.add(Ve)}}}valuesChanger(){this.velocityUniforms&&(this.velocityUniforms.separationDistance.value=this.options.separation,this.velocityUniforms.alignmentDistance.value=this.options.alignment,this.velocityUniforms.speedLimit.value=this.options.speedLimit,this.velocityUniforms.cohesionDistance.value=this.options.cohesion)}onUpdate(){this.now=performance.now(),this.last||(this.last=this.now);let fe=(this.now-this.last)/1e3;if(fe>1&&(fe=1),this.last=this.now,ki)this.positionUniforms.time.value=this.now,this.positionUniforms.delta.value=fe,this.velocityUniforms.time.value=this.now,this.velocityUniforms.delta.value=fe,this.birdUniforms.time.value=this.now,this.birdUniforms.delta.value=fe,this.velocityUniforms.predator.value.set(this.mouseX,-this.mouseY,0),this.mouseX=1e4,this.mouseY=1e4,this.gpuCompute.compute(),this.birdUniforms.texturePosition.value=this.gpuCompute.getCurrentRenderTarget(this.positionVariable).texture,this.birdUniforms.textureVelocity.value=this.gpuCompute.getCurrentRenderTarget(this.velocityVariable).texture;else{const le=this.birds,Ve=this.boids;let Ie,we;for(var ee=0,ze=le.length;ee<ze;ee++)Ie=Ve[ee],Ie.run(Ve),we=le[ee],we.rotation.y=Math.atan2(-Ie.velocity.z,Ie.velocity.x),we.rotation.z=Math.asin(Ie.velocity.y/Ie.velocity.length()),we.phase=(we.phase+(Math.max(0,we.rotation.z)+.1))%62.83,we.geometry.vertices[5].y=we.geometry.vertices[4].y=5*Math.sin(we.phase)*this.options.birdSize,we.geometry.verticesNeedUpdate=!0,we.position.x=Ve[ee].position.x,we.position.y=Ve[ee].position.y,we.position.z=Ve[ee].position.z}}onMouseMove(fe,ee){if(this.mouseX=fe-.5,this.mouseY=ee-.5,!ki){const Ie=this.boids;let we;for(var ze=new Mt.Vector3(this.mouseX*this.width,-this.mouseY*this.height,0),le=0,Ve=Ie.length;le<Ve;le++)we=Ie[le],ze.z=we.position.z,we.repulse(ze)}}onDestroy(){}onResize(){}}bh.initClass(),Tt.default=pe.a.register("BIRDS",bh)}})},78:(pc,Lr,Tt)=>{"use strict";var it={};function pe(e){return"function"==typeof e}function vt(e){const n=e(i=>{Error.call(i),i.stack=(new Error).stack});return n.prototype=Object.create(Error.prototype),n.prototype.constructor=n,n}Tt.r(it),Tt.d(it,{ACESFilmicToneMapping:()=>aS,AddEquation:()=>is,AddOperation:()=>iS,AdditiveAnimationBlendMode:()=>ny,AdditiveBlending:()=>kg,AlphaFormat:()=>mS,AlwaysDepth:()=>ZE,AlwaysStencilFunc:()=>lT,AmbientLight:()=>ih,AmbientLightProbe:()=>bv,AnimationClip:()=>Mi,AnimationLoader:()=>ov,AnimationMixer:()=>Dv,AnimationObjectGroup:()=>$D,AnimationUtils:()=>zt,ArcCurve:()=>cc,ArrayCamera:()=>vf,ArrowHelper:()=>oz,Audio:()=>Mv,AudioAnalyser:()=>WD,AudioContext:()=>xv,AudioListener:()=>OG,AudioLoader:()=>lh,AxesHelper:()=>l1,AxisHelper:()=>Bz,BackSide:()=>wn,BasicDepthPacking:()=>sT,BasicShadowMap:()=>aB,BinaryTextureLoader:()=>Gz,Bone:()=>Zl,BooleanKeyframeTrack:()=>Wf,BoundingBoxHelper:()=>kz,Box2:()=>ZD,Box3:()=>xr,Box3Helper:()=>iz,BoxBufferGeometry:()=>kl,BoxGeometry:()=>ky,BoxHelper:()=>a1,BufferAttribute:()=>Ee,BufferGeometry:()=>Me,BufferGeometryLoader:()=>ah,ByteType:()=>lS,Cache:()=>Ss,Camera:()=>Mr,CameraHelper:()=>nz,CanvasRenderer:()=>Wz,CanvasTexture:()=>Kl,CatmullRomCurve3:()=>kn,CineonToneMapping:()=>sS,CircleBufferGeometry:()=>Hy,CircleGeometry:()=>dD,ClampToEdgeWrapping:()=>Xn,Clock:()=>UD,ClosedSplineCurve3:()=>_1,Color:()=>ae,ColorKeyframeTrack:()=>qf,CompressedTexture:()=>nc,CompressedTextureLoader:()=>sv,ConeBufferGeometry:()=>hD,ConeGeometry:()=>fD,CubeCamera:()=>gs,CubeGeometry:()=>ky,CubeReflectionMapping:()=>dl,CubeRefractionMapping:()=>fl,CubeTexture:()=>Er,CubeTextureLoader:()=>Yf,CubeUVReflectionMapping:()=>Ta,CubeUVRefractionMapping:()=>hl,CubicBezierCurve:()=>nr,CubicBezierCurve3:()=>Dr,CubicInterpolant:()=>zf,CullFaceBack:()=>Ng,CullFaceFront:()=>NE,CullFaceFrontBack:()=>sB,CullFaceNone:()=>FE,Curve:()=>xe,CurvePath:()=>oo,CustomBlending:()=>BE,CustomToneMapping:()=>cS,CylinderBufferGeometry:()=>tu,CylinderGeometry:()=>Vy,Cylindrical:()=>YG,DataTexture:()=>no,DataTexture2DArray:()=>Xa,DataTexture3D:()=>Ya,DataTextureLoader:()=>Zf,DataUtils:()=>az,DecrementStencilOp:()=>vB,DecrementWrapStencilOp:()=>xB,DefaultLoadingManager:()=>PD,DepthFormat:()=>os,DepthStencilFormat:()=>Ia,DepthTexture:()=>eu,DirectionalLight:()=>nh,DirectionalLightHelper:()=>tz,DiscreteInterpolant:()=>jf,DodecahedronBufferGeometry:()=>Uy,DodecahedronGeometry:()=>pD,DoubleSide:()=>ll,DstAlphaFactor:()=>jE,DstColorFactor:()=>qE,DynamicBufferAttribute:()=>Dz,DynamicCopyUsage:()=>FB,DynamicDrawUsage:()=>ls,DynamicReadUsage:()=>LB,EdgesGeometry:()=>zy,EdgesHelper:()=>Hz,EllipseCurve:()=>Ei,EqualDepth:()=>QE,EqualStencilFunc:()=>EB,EquirectangularReflectionMapping:()=>qd,EquirectangularRefractionMapping:()=>$d,Euler:()=>dT,EventDispatcher:()=>_r,ExtrudeBufferGeometry:()=>ou,ExtrudeGeometry:()=>qy,Face3:()=>Dl,Face4:()=>fz,FaceColors:()=>gz,FileLoader:()=>Oi,FlatShading:()=>Bg,Float16BufferAttribute:()=>Pl,Float32Attribute:()=>Nz,Float32BufferAttribute:()=>te,Float64Attribute:()=>Oz,Float64BufferAttribute:()=>Fl,FloatType:()=>Xr,Fog:()=>xf,FogExp2:()=>_f,Font:()=>vv,FontLoader:()=>_v,FrontSide:()=>Ea,Frustum:()=>Hl,GLBufferAttribute:()=>Av,GLSL1:()=>OB,GLSL3:()=>sy,GammaEncoding:()=>Qd,Geometry:()=>Lt,GeometryUtils:()=>jz,GreaterDepth:()=>eS,GreaterEqualDepth:()=>KE,GreaterEqualStencilFunc:()=>CB,GreaterStencilFunc:()=>TB,GridHelper:()=>r1,Group:()=>Ro,HalfFloatType:()=>vl,HemisphereLight:()=>Kf,HemisphereLightHelper:()=>KG,HemisphereLightProbe:()=>wv,IcosahedronBufferGeometry:()=>$y,IcosahedronGeometry:()=>wD,ImageBitmapLoader:()=>gv,ImageLoader:()=>ac,ImageUtils:()=>us,ImmediateRenderObject:()=>fu,IncrementStencilOp:()=>yB,IncrementWrapStencilOp:()=>_B,InstancedBufferAttribute:()=>sh,InstancedBufferGeometry:()=>du,InstancedInterleavedBuffer:()=>Cv,InstancedMesh:()=>Tf,Int16Attribute:()=>Lz,Int16BufferAttribute:()=>Ll,Int32Attribute:()=>Pz,Int32BufferAttribute:()=>Rl,Int8Attribute:()=>Cz,Int8BufferAttribute:()=>Cl,IntType:()=>dS,InterleavedBuffer:()=>wi,InterleavedBufferAttribute:()=>Po,Interpolant:()=>bi,InterpolateDiscrete:()=>_l,InterpolateLinear:()=>xl,InterpolateSmooth:()=>Zd,InvertStencilOp:()=>wB,JSONLoader:()=>qz,KeepStencilOp:()=>ef,KeyframeTrack:()=>In,LOD:()=>Xl,LatheBufferGeometry:()=>Xy,LatheGeometry:()=>bD,Layers:()=>my,LensFlare:()=>Xz,LessDepth:()=>JE,LessEqualDepth:()=>jd,LessEqualStencilFunc:()=>SB,LessStencilFunc:()=>MB,Light:()=>kt,LightProbe:()=>Bi,Line:()=>Ni,Line3:()=>QD,LineBasicMaterial:()=>$t,LineCurve:()=>ri,LineCurve3:()=>ir,LineDashedMaterial:()=>Es,LineLoop:()=>Lf,LinePieces:()=>pz,LineSegments:()=>Qn,LineStrip:()=>hz,LinearEncoding:()=>Yn,LinearFilter:()=>En,LinearInterpolant:()=>au,LinearMipMapLinearFilter:()=>fB,LinearMipMapNearestFilter:()=>dB,LinearMipmapLinearFilter:()=>Da,LinearMipmapNearestFilter:()=>Wg,LinearToneMapping:()=>rS,Loader:()=>Et,LoaderUtils:()=>mv,LoadingManager:()=>rv,LogLuvEncoding:()=>oT,LoopOnce:()=>tT,LoopPingPong:()=>iT,LoopRepeat:()=>nT,LuminanceAlphaFormat:()=>yS,LuminanceFormat:()=>gS,MOUSE:()=>rB,Material:()=>Pe,MaterialLoader:()=>oh,Math:()=>ke,MathUtils:()=>ke,Matrix3:()=>Zn,Matrix4:()=>Ze,MaxEquation:()=>Gg,Mesh:()=>Gt,MeshBasicMaterial:()=>Pi,MeshDepthMaterial:()=>Io,MeshDistanceMaterial:()=>Lo,MeshFaceMaterial:()=>vz,MeshLambertMaterial:()=>bs,MeshMatcapMaterial:()=>Ms,MeshNormalMaterial:()=>ws,MeshPhongMaterial:()=>Bo,MeshPhysicalMaterial:()=>Oo,MeshStandardMaterial:()=>Tr,MeshToonMaterial:()=>xs,MinEquation:()=>Ug,MirroredRepeatWrapping:()=>ml,MixOperation:()=>nS,MultiMaterial:()=>_z,MultiplyBlending:()=>Vg,MultiplyOperation:()=>ul,NearestFilter:()=>bn,NearestMipMapLinearFilter:()=>uB,NearestMipMapNearestFilter:()=>lB,NearestMipmapLinearFilter:()=>Yd,NearestMipmapNearestFilter:()=>Xd,NeverDepth:()=>YE,NeverStencilFunc:()=>bB,NoBlending:()=>$r,NoColors:()=>mz,NoToneMapping:()=>rs,NormalAnimationBlendMode:()=>Jd,NormalBlending:()=>Sa,NotEqualDepth:()=>tS,NotEqualStencilFunc:()=>DB,NumberKeyframeTrack:()=>oc,Object3D:()=>ge,ObjectLoader:()=>LG,ObjectSpaceNormalMap:()=>cT,OctahedronBufferGeometry:()=>Uf,OctahedronGeometry:()=>MD,OneFactor:()=>UE,OneMinusDstAlphaFactor:()=>WE,OneMinusDstColorFactor:()=>$E,OneMinusSrcAlphaFactor:()=>jg,OneMinusSrcColorFactor:()=>zE,OrthographicCamera:()=>lc,PCFShadowMap:()=>Og,PCFSoftShadowMap:()=>OE,PMREMGenerator:()=>cz,ParametricBufferGeometry:()=>rc,ParametricGeometry:()=>su,Particle:()=>wz,ParticleBasicMaterial:()=>Ez,ParticleSystem:()=>bz,ParticleSystemMaterial:()=>Sz,Path:()=>sr,PerspectiveCamera:()=>pn,Plane:()=>wr,PlaneBufferGeometry:()=>yf,PlaneGeometry:()=>ED,PlaneHelper:()=>rz,PointCloud:()=>xz,PointCloudMaterial:()=>Mz,PointLight:()=>th,PointLightHelper:()=>JG,Points:()=>tc,PointsMaterial:()=>er,PolarGridHelper:()=>ez,PolyhedronBufferGeometry:()=>vs,PolyhedronGeometry:()=>SD,PositionalAudio:()=>kG,PropertyBinding:()=>Hn,PropertyMixer:()=>Ev,QuadraticBezierCurve:()=>rr,QuadraticBezierCurve3:()=>Cr,Quaternion:()=>On,QuaternionKeyframeTrack:()=>cu,QuaternionLinearInterpolant:()=>$f,REVISION:()=>PE,RGBADepthPacking:()=>aT,RGBAFormat:()=>gi,RGBAIntegerFormat:()=>ES,RGBA_ASTC_10x10_Format:()=>BS,RGBA_ASTC_10x5_Format:()=>FS,RGBA_ASTC_10x6_Format:()=>NS,RGBA_ASTC_10x8_Format:()=>OS,RGBA_ASTC_12x10_Format:()=>kS,RGBA_ASTC_12x12_Format:()=>HS,RGBA_ASTC_4x4_Format:()=>TS,RGBA_ASTC_5x4_Format:()=>DS,RGBA_ASTC_5x5_Format:()=>CS,RGBA_ASTC_6x5_Format:()=>AS,RGBA_ASTC_6x6_Format:()=>IS,RGBA_ASTC_8x5_Format:()=>LS,RGBA_ASTC_8x6_Format:()=>RS,RGBA_ASTC_8x8_Format:()=>PS,RGBA_BPTC_Format:()=>VS,RGBA_ETC2_EAC_Format:()=>ty,RGBA_PVRTC_2BPPV1_Format:()=>Kg,RGBA_PVRTC_4BPPV1_Format:()=>Qg,RGBA_S3TC_DXT1_Format:()=>$g,RGBA_S3TC_DXT3_Format:()=>Xg,RGBA_S3TC_DXT5_Format:()=>Yg,RGBDEncoding:()=>oy,RGBEEncoding:()=>Kd,RGBEFormat:()=>vS,RGBFormat:()=>wo,RGBIntegerFormat:()=>MS,RGBM16Encoding:()=>ry,RGBM7Encoding:()=>iy,RGB_ETC1_Format:()=>SS,RGB_ETC2_Format:()=>ey,RGB_PVRTC_2BPPV1_Format:()=>Jg,RGB_PVRTC_4BPPV1_Format:()=>Zg,RGB_S3TC_DXT1_Format:()=>qg,RGFormat:()=>wS,RGIntegerFormat:()=>bS,RawShaderMaterial:()=>ro,Ray:()=>Na,Raycaster:()=>Iv,RectAreaLight:()=>rh,RedFormat:()=>_S,RedIntegerFormat:()=>xS,ReinhardToneMapping:()=>oS,RepeatWrapping:()=>pl,ReplaceStencilOp:()=>gB,ReverseSubtractEquation:()=>HE,RingBufferGeometry:()=>Yy,RingGeometry:()=>TD,SRGB8_ALPHA8_ASTC_10x10_Format:()=>QS,SRGB8_ALPHA8_ASTC_10x5_Format:()=>YS,SRGB8_ALPHA8_ASTC_10x6_Format:()=>ZS,SRGB8_ALPHA8_ASTC_10x8_Format:()=>JS,SRGB8_ALPHA8_ASTC_12x10_Format:()=>KS,SRGB8_ALPHA8_ASTC_12x12_Format:()=>eT,SRGB8_ALPHA8_ASTC_4x4_Format:()=>US,SRGB8_ALPHA8_ASTC_5x4_Format:()=>GS,SRGB8_ALPHA8_ASTC_5x5_Format:()=>zS,SRGB8_ALPHA8_ASTC_6x5_Format:()=>jS,SRGB8_ALPHA8_ASTC_6x6_Format:()=>WS,SRGB8_ALPHA8_ASTC_8x5_Format:()=>qS,SRGB8_ALPHA8_ASTC_8x6_Format:()=>$S,SRGB8_ALPHA8_ASTC_8x8_Format:()=>XS,Scene:()=>Ry,SceneUtils:()=>$z,ShaderChunk:()=>ct,ShaderLib:()=>Ki,ShaderMaterial:()=>Jn,ShadowMaterial:()=>_s,Shape:()=>ko,ShapeBufferGeometry:()=>Zy,ShapeGeometry:()=>Jy,ShapePath:()=>yv,ShapeUtils:()=>io,ShortType:()=>uS,Skeleton:()=>Jl,SkeletonHelper:()=>e1,SkinnedMesh:()=>Yl,SmoothShading:()=>cB,Sphere:()=>Zr,SphereBufferGeometry:()=>Gf,SphereGeometry:()=>DD,Spherical:()=>XG,SphericalHarmonics3:()=>ND,Spline:()=>kv,SplineCurve:()=>or,SplineCurve3:()=>x1,SpotLight:()=>eh,SpotLightHelper:()=>ZG,Sprite:()=>$l,SpriteMaterial:()=>Fo,SrcAlphaFactor:()=>zg,SrcAlphaSaturateFactor:()=>XE,SrcColorFactor:()=>GE,StaticCopyUsage:()=>PB,StaticDrawUsage:()=>Ml,StaticReadUsage:()=>IB,StereoCamera:()=>VD,StreamCopyUsage:()=>NB,StreamDrawUsage:()=>AB,StreamReadUsage:()=>RB,StringKeyframeTrack:()=>Xf,SubtractEquation:()=>kE,SubtractiveBlending:()=>Hg,TOUCH:()=>oB,TangentSpaceNormalMap:()=>cs,TetrahedronBufferGeometry:()=>Qy,TetrahedronGeometry:()=>CD,TextBufferGeometry:()=>Ky,TextGeometry:()=>AD,Texture:()=>At,TextureLoader:()=>Jf,TorusBufferGeometry:()=>ev,TorusGeometry:()=>ID,TorusKnotBufferGeometry:()=>tv,TorusKnotGeometry:()=>LD,Triangle:()=>An,TriangleFanDrawMode:()=>pB,TriangleStripDrawMode:()=>hB,TrianglesDrawMode:()=>rT,TubeBufferGeometry:()=>nv,TubeGeometry:()=>RD,UVMapping:()=>Wd,Uint16Attribute:()=>Rz,Uint16BufferAttribute:()=>hs,Uint32Attribute:()=>Fz,Uint32BufferAttribute:()=>ps,Uint8Attribute:()=>Az,Uint8BufferAttribute:()=>Al,Uint8ClampedAttribute:()=>Iz,Uint8ClampedBufferAttribute:()=>Il,Uniform:()=>uh,UniformsLib:()=>J,UniformsUtils:()=>ET,UnsignedByteType:()=>Ca,UnsignedInt248Type:()=>Aa,UnsignedIntType:()=>yl,UnsignedShort4444Type:()=>fS,UnsignedShort5551Type:()=>hS,UnsignedShort565Type:()=>pS,UnsignedShortType:()=>gl,VSMShadowMap:()=>Ma,Vector2:()=>V,Vector3:()=>M,Vector4:()=>It,VectorKeyframeTrack:()=>sc,Vertex:()=>Tz,VertexColors:()=>yz,VideoTexture:()=>Oy,WebGL1Renderer:()=>Ly,WebGLCubeRenderTarget:()=>to,WebGLMultisampleRenderTarget:()=>cy,WebGLRenderTarget:()=>yi,WebGLRenderTargetCube:()=>zz,WebGLRenderer:()=>zl,WebGLUtils:()=>XT,WireframeGeometry:()=>iv,WireframeHelper:()=>Vz,WrapAroundEnding:()=>wl,XHRLoader:()=>Uz,ZeroCurvatureEnding:()=>ss,ZeroFactor:()=>VE,ZeroSlopeEnding:()=>as,ZeroStencilOp:()=>mB,sRGBEncoding:()=>bl});const gn=vt(e=>function(n){e(this),this.message=n?`${n.length} errors occurred during unsubscription:\n${n.map((i,r)=>`${r+1}) ${i.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=n});function on(e,t){if(e){const n=e.indexOf(t);0<=n&&e.splice(n,1)}}class en{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:n}=this;if(n)if(this._parentage=null,Array.isArray(n))for(const o of n)o.remove(this);else n.remove(this);const{initialTeardown:i}=this;if(pe(i))try{i()}catch(o){t=o instanceof gn?o.errors:[o]}const{_finalizers:r}=this;if(r){this._finalizers=null;for(const o of r)try{$e(o)}catch(s){t=t??[],s instanceof gn?t=[...t,...s.errors]:t.push(s)}}if(t)throw new gn(t)}}add(t){var n;if(t&&t!==this)if(this.closed)$e(t);else{if(t instanceof en){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(n=this._finalizers)&&void 0!==n?n:[]).push(t)}}_hasParent(t){const{_parentage:n}=this;return n===t||Array.isArray(n)&&n.includes(t)}_addParent(t){const{_parentage:n}=this;this._parentage=Array.isArray(n)?(n.push(t),n):n?[n,t]:t}_removeParent(t){const{_parentage:n}=this;n===t?this._parentage=null:Array.isArray(n)&&on(n,t)}remove(t){const{_finalizers:n}=this;n&&on(n,t),t instanceof en&&t._removeParent(this)}}en.EMPTY=(()=>{const e=new en;return e.closed=!0,e})();const me=en.EMPTY;function Ae(e){return e instanceof en||e&&"closed"in e&&pe(e.remove)&&pe(e.add)&&pe(e.unsubscribe)}function $e(e){pe(e)?e():e.unsubscribe()}const Ge={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Le={setTimeout(e,t,...n){const{delegate:i}=Le;return i?.setTimeout?i.setTimeout(e,t,...n):setTimeout(e,t,...n)},clearTimeout(e){const{delegate:t}=Le;return(t?.clearTimeout||clearTimeout)(e)},delegate:void 0};function Xt(e){Le.setTimeout(()=>{const{onUnhandledError:t}=Ge;if(!t)throw e;t(e)})}function Uo(){}const Rr=Mt("C",void 0,void 0);function Mt(e,t,n){return{kind:e,value:t,error:n}}let ki=null;function Ln(e){if(Ge.useDeprecatedSynchronousErrorHandling){const t=!ki;if(t&&(ki={errorThrown:!1,error:null}),e(),t){const{errorThrown:n,error:i}=ki;if(ki=null,n)throw i}}else e()}class Pr extends en{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,Ae(t)&&t.add(this)):this.destination=wh}static create(t,n,i){return new Ps(t,n,i)}next(t){this.isStopped?gc(function _h(e){return Mt("N",e,void 0)}(t),this):this._next(t)}error(t){this.isStopped?gc(function lo(e){return Mt("E",void 0,e)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?gc(Rr,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const mc=Function.prototype.bind;function Go(e,t){return mc.call(e,t)}class yu{constructor(t){this.partialObserver=t}next(t){const{partialObserver:n}=this;if(n.next)try{n.next(t)}catch(i){Fs(i)}}error(t){const{partialObserver:n}=this;if(n.error)try{n.error(t)}catch(i){Fs(i)}else Fs(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(n){Fs(n)}}}class Ps extends Pr{constructor(t,n,i){let r;if(super(),pe(t)||!t)r={next:t??void 0,error:n??void 0,complete:i??void 0};else{let o;this&&Ge.useDeprecatedNextContext?(o=Object.create(t),o.unsubscribe=()=>this.unsubscribe(),r={next:t.next&&Go(t.next,o),error:t.error&&Go(t.error,o),complete:t.complete&&Go(t.complete,o)}):r=t}this.destination=new yu(r)}}function Fs(e){Ge.useDeprecatedSynchronousErrorHandling?function Rs(e){Ge.useDeprecatedSynchronousErrorHandling&&ki&&(ki.errorThrown=!0,ki.error=e)}(e):Xt(e)}function gc(e,t){const{onStoppedNotification:n}=Ge;n&&Le.setTimeout(()=>n(e,t))}const wh={closed:!0,next:Uo,error:function xh(e){throw e},complete:Uo},yc="function"==typeof Symbol&&Symbol.observable||"@@observable";function vu(e){return e}let fe=(()=>{class e{constructor(n){n&&(this._subscribe=n)}lift(n){const i=new e;return i.source=this,i.operator=n,i}subscribe(n,i,r){const o=function le(e){return e&&e instanceof Pr||function ze(e){return e&&pe(e.next)&&pe(e.error)&&pe(e.complete)}(e)&&Ae(e)}(n)?n:new Ps(n,i,r);return Ln(()=>{const{operator:s,source:a}=this;o.add(s?s.call(o,a):a?this._subscribe(o):this._trySubscribe(o))}),o}_trySubscribe(n){try{return this._subscribe(n)}catch(i){n.error(i)}}forEach(n,i){return new(i=ee(i))((r,o)=>{const s=new Ps({next:a=>{try{n(a)}catch(c){o(c),s.unsubscribe()}},error:o,complete:r});this.subscribe(s)})}_subscribe(n){var i;return null===(i=this.source)||void 0===i?void 0:i.subscribe(n)}[yc](){return this}pipe(...n){return function rt(e){return 0===e.length?vu:1===e.length?e[0]:function(n){return e.reduce((i,r)=>r(i),n)}}(n)(this)}toPromise(n){return new(n=ee(n))((i,r)=>{let o;this.subscribe(s=>o=s,s=>r(s),()=>i(o))})}}return e.create=t=>new e(t),e})();function ee(e){var t;return null!==(t=e??Ge.Promise)&&void 0!==t?t:Promise}const Ve=vt(e=>function(){e(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Ie=(()=>{class e extends fe{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(n){const i=new we(this,this);return i.operator=n,i}_throwIfClosed(){if(this.closed)throw new Ve}next(n){Ln(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const i of this.currentObservers)i.next(n)}})}error(n){Ln(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=n;const{observers:i}=this;for(;i.length;)i.shift().error(n)}})}complete(){Ln(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:n}=this;for(;n.length;)n.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var n;return(null===(n=this.observers)||void 0===n?void 0:n.length)>0}_trySubscribe(n){return this._throwIfClosed(),super._trySubscribe(n)}_subscribe(n){return this._throwIfClosed(),this._checkFinalizedStatuses(n),this._innerSubscribe(n)}_innerSubscribe(n){const{hasError:i,isStopped:r,observers:o}=this;return i||r?me:(this.currentObservers=null,o.push(n),new en(()=>{this.currentObservers=null,on(o,n)}))}_checkFinalizedStatuses(n){const{hasError:i,thrownError:r,isStopped:o}=this;i?n.error(r):o&&n.complete()}asObservable(){const n=new fe;return n.source=this,n}}return e.create=(t,n)=>new we(t,n),e})();class we extends Ie{constructor(t,n){super(),this.destination=t,this.source=n}next(t){var n,i;null===(i=null===(n=this.destination)||void 0===n?void 0:n.next)||void 0===i||i.call(n,t)}error(t){var n,i;null===(i=null===(n=this.destination)||void 0===n?void 0:n.error)||void 0===i||i.call(n,t)}complete(){var t,n;null===(n=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===n||n.call(t)}_subscribe(t){var n,i;return null!==(i=null===(n=this.source)||void 0===n?void 0:n.subscribe(t))&&void 0!==i?i:me}}function De(e){return t=>{if(function ht(e){return pe(e?.lift)}(t))return t.lift(function(n){try{return e(n,this)}catch(i){this.error(i)}});throw new TypeError("Unable to lift unknown Observable type")}}function dt(e,t,n,i,r){return new je(e,t,n,i,r)}class je extends Pr{constructor(t,n,i,r,o,s){super(t),this.onFinalize=o,this.shouldUnsubscribe=s,this._next=n?function(a){try{n(a)}catch(c){t.error(c)}}:super._next,this._error=r?function(a){try{r(a)}catch(c){t.error(c)}finally{this.unsubscribe()}}:super._error,this._complete=i?function(){try{i()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:n}=this;super.unsubscribe(),!n&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function zo(e){return this instanceof zo?(this.v=e,this):new zo(e)}function A1(e,t,n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,i=n.apply(e,t||[]),o=[];return r={},s("next"),s("throw"),s("return"),r[Symbol.asyncIterator]=function(){return this},r;function s(f){i[f]&&(r[f]=function(h){return new Promise(function(p,y){o.push([f,h,p,y])>1||a(f,h)})})}function a(f,h){try{!function c(f){f.value instanceof zo?Promise.resolve(f.value.v).then(l,d):u(o[0][2],f)}(i[f](h))}catch(p){u(o[0][3],p)}}function l(f){a("next",f)}function d(f){a("throw",f)}function u(f,h){f(h),o.shift(),o.length&&a(o[0][0],o[0][1])}}function I1(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,t=e[Symbol.asyncIterator];return t?t.call(e):(e=function Gv(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],i=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&i>=e.length&&(e=void 0),{value:e&&e[i++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(e),n={},i("next"),i("throw"),i("return"),n[Symbol.asyncIterator]=function(){return this},n);function i(o){n[o]=e[o]&&function(s){return new Promise(function(a,c){!function r(o,s,a,c){Promise.resolve(c).then(function(l){o({value:l,done:a})},s)}(a,c,(s=e[o](s)).done,s.value)})}}}const zv=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function jv(e){return pe(e?.then)}function Wv(e){return pe(e[yc])}function qv(e){return Symbol.asyncIterator&&pe(e?.[Symbol.asyncIterator])}function $v(e){return new TypeError(`You provided ${null!==e&&"object"==typeof e?"an invalid object":`'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const Xv=function R1(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function Yv(e){return pe(e?.[Xv])}function Zv(e){return A1(this,arguments,function*(){const n=e.getReader();try{for(;;){const{value:i,done:r}=yield zo(n.read());if(r)return yield zo(void 0);yield yield zo(i)}}finally{n.releaseLock()}})}function Jv(e){return pe(e?.getReader)}function Ns(e){if(e instanceof fe)return e;if(null!=e){if(Wv(e))return function P1(e){return new fe(t=>{const n=e[yc]();if(pe(n.subscribe))return n.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(e);if(zv(e))return function F1(e){return new fe(t=>{for(let n=0;n<e.length&&!t.closed;n++)t.next(e[n]);t.complete()})}(e);if(jv(e))return function N1(e){return new fe(t=>{e.then(n=>{t.closed||(t.next(n),t.complete())},n=>t.error(n)).then(null,Xt)})}(e);if(qv(e))return Qv(e);if(Yv(e))return function O1(e){return new fe(t=>{for(const n of e)if(t.next(n),t.closed)return;t.complete()})}(e);if(Jv(e))return function B1(e){return Qv(Zv(e))}(e)}throw $v(e)}function Qv(e){return new fe(t=>{(function k1(e,t){var n,i,r,o;return function _u(e,t,n,i){return new(n||(n=Promise))(function(o,s){function a(d){try{l(i.next(d))}catch(u){s(u)}}function c(d){try{l(i.throw(d))}catch(u){s(u)}}function l(d){d.done?o(d.value):function r(o){return o instanceof n?o:new n(function(s){s(o)})}(d.value).then(a,c)}l((i=i.apply(e,t||[])).next())})}(this,void 0,void 0,function*(){try{for(n=I1(e);!(i=yield n.next()).done;)if(t.next(i.value),t.closed)return}catch(s){r={error:s}}finally{try{i&&!i.done&&(o=n.return)&&(yield o.call(n))}finally{if(r)throw r.error}}t.complete()})})(e,t).catch(n=>t.error(n))})}function uo(e,t,n,i=0,r=!1){const o=t.schedule(function(){n(),r?e.add(this.schedule(null,i)):this.unsubscribe()},i);if(e.add(o),!r)return o}function Kv(e,t,n=1/0){return pe(t)?Kv((i,r)=>function be(e,t){return De((n,i)=>{let r=0;n.subscribe(dt(i,o=>{i.next(e.call(t,o,r++))}))})}((o,s)=>t(i,o,r,s))(Ns(e(i,r))),n):("number"==typeof t&&(n=t),De((i,r)=>function H1(e,t,n,i,r,o,s,a){const c=[];let l=0,d=0,u=!1;const f=()=>{u&&!c.length&&!l&&t.complete()},h=y=>l<i?p(y):c.push(y),p=y=>{o&&t.next(y),l++;let v=!1;Ns(n(y,d++)).subscribe(dt(t,g=>{r?.(g),o?h(g):t.next(g)},()=>{v=!0},void 0,()=>{if(v)try{for(l--;c.length&&l<i;){const g=c.shift();s?uo(t,s,()=>p(g)):p(g)}f()}catch(g){t.error(g)}}))};return e.subscribe(dt(t,h,()=>{u=!0,f()})),()=>{a?.()}}(i,r,e,n)))}const Mh=new fe(e=>e.complete());function Eh(e){return e[e.length-1]}function e0(e,t=0){return De((n,i)=>{n.subscribe(dt(i,r=>uo(i,e,()=>i.next(r),t),()=>uo(i,e,()=>i.complete(),t),r=>uo(i,e,()=>i.error(r),t)))})}function t0(e,t=0){return De((n,i)=>{i.add(e.schedule(()=>n.subscribe(i),t))})}function n0(e,t){if(!e)throw new Error("Iterable cannot be null");return new fe(n=>{uo(n,t,()=>{const i=e[Symbol.asyncIterator]();uo(n,t,()=>{i.next().then(r=>{r.done?n.complete():n.next(r.value)})},0,!0)})})}function r0(e,t){return t?function Z1(e,t){if(null!=e){if(Wv(e))return function W1(e,t){return Ns(e).pipe(t0(t),e0(t))}(e,t);if(zv(e))return function $1(e,t){return new fe(n=>{let i=0;return t.schedule(function(){i===e.length?n.complete():(n.next(e[i++]),n.closed||this.schedule())})})}(e,t);if(jv(e))return function q1(e,t){return Ns(e).pipe(t0(t),e0(t))}(e,t);if(qv(e))return n0(e,t);if(Yv(e))return function X1(e,t){return new fe(n=>{let i;return uo(n,t,()=>{i=e[Xv](),uo(n,t,()=>{let r,o;try{({value:r,done:o}=i.next())}catch(s){return void n.error(s)}o?n.complete():n.next(r)},0,!0)}),()=>pe(i?.return)&&i.return()})}(e,t);if(Jv(e))return function Y1(e,t){return n0(Zv(e),t)}(e,t)}throw $v(e)}(e,t):Ns(e)}function J1(...e){const t=function z1(e){return function G1(e){return e&&pe(e.schedule)}(Eh(e))?e.pop():void 0}(e),n=function j1(e,t){return"number"==typeof Eh(e)?e.pop():t}(e,1/0),i=e;return i.length?1===i.length?Ns(i[0]):function V1(e=1/0){return Kv(vu,e)}(n)(r0(i,t)):Mh}function Sh(e,t,...n){return!0===t?(e(),null):!1===t?null:t(...n).pipe(function Q1(e){return e<=0?()=>Mh:De((t,n)=>{let i=0;t.subscribe(dt(n,r=>{++i<=e&&(n.next(r),e<=i&&n.complete())}))})}(1)).subscribe(()=>e())}function Rt(e){for(let t in e)if(e[t]===Rt)return t;throw Error("Could not find renamed property on target object.")}function Pt(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(Pt).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return`${e.overriddenName}`;if(e.name)return`${e.name}`;const t=e.toString();if(null==t)return""+t;const n=t.indexOf("\n");return-1===n?t:t.substring(0,n)}function Dh(e,t){return null==e||""===e?null===t?"":t:null==t||""===t?e:e+" "+t}const eC=Rt({__forward_ref__:Rt});function Ch(e){return e.__forward_ref__=Ch,e.toString=function(){return Pt(this())},e}function Ne(e){return function Ah(e){return"function"==typeof e&&e.hasOwnProperty(eC)&&e.__forward_ref__===Ch}(e)?e():e}class Oe extends Error{constructor(t,n){super(function xu(e,t){return`NG0${Math.abs(e)}${t?": "+t.trim():""}`}(t,n)),this.code=t}}function We(e){return"string"==typeof e?e:null==e?"":String(e)}function wu(e,t){throw new Oe(-201,!1)}function li(e,t){null==e&&function wt(e,t,n,i){throw new Error(`ASSERTION ERROR: ${e}`+(null==i?"":` [Expected=> ${n} ${i} ${t} <=Actual]`))}(t,e,null,"!=")}function Wt(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function Os(e){return{providers:e.providers||[],imports:e.imports||[]}}function Ih(e){return o0(e,bu)||o0(e,a0)}function o0(e,t){return e.hasOwnProperty(t)?e[t]:null}function s0(e){return e&&(e.hasOwnProperty(Lh)||e.hasOwnProperty(cC))?e[Lh]:null}const bu=Rt({\u0275prov:Rt}),Lh=Rt({\u0275inj:Rt}),a0=Rt({ngInjectableDef:Rt}),cC=Rt({ngInjectorDef:Rt});var Be=(()=>((Be=Be||{})[Be.Default=0]="Default",Be[Be.Host=1]="Host",Be[Be.Self=2]="Self",Be[Be.SkipSelf=4]="SkipSelf",Be[Be.Optional=8]="Optional",Be))();let Rh;function ar(e){const t=Rh;return Rh=e,t}function c0(e,t,n){const i=Ih(e);return i&&"root"==i.providedIn?void 0===i.value?i.value=i.factory():i.value:n&Be.Optional?null:void 0!==t?t:void wu(Pt(e))}function fo(e){return{toString:e}.toString()}var Hi=(()=>((Hi=Hi||{})[Hi.OnPush=0]="OnPush",Hi[Hi.Default=1]="Default",Hi))(),cr=(()=>{return(e=cr||(cr={}))[e.Emulated=0]="Emulated",e[e.None=2]="None",e[e.ShadowDom=3]="ShadowDom",cr;var e})();const Ct=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),Bs={},xt=[],Mu=Rt({\u0275cmp:Rt}),Ph=Rt({\u0275dir:Rt}),Fh=Rt({\u0275pipe:Rt}),l0=Rt({\u0275mod:Rt}),Nr=Rt({\u0275fac:Rt}),vc=Rt({__NG_ELEMENT_ID__:Rt});let uC=0;function Nh(e){return fo(()=>{const n=!0===e.standalone,i={},r={type:e.type,providersResolver:null,decls:e.decls,vars:e.vars,factory:null,template:e.template||null,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:i,inputs:null,outputs:null,exportAs:e.exportAs||null,onPush:e.changeDetection===Hi.OnPush,directiveDefs:null,pipeDefs:null,standalone:n,dependencies:n&&e.dependencies||null,getStandaloneInjector:null,selectors:e.selectors||xt,viewQuery:e.viewQuery||null,features:e.features||null,data:e.data||{},encapsulation:e.encapsulation||cr.Emulated,id:"c"+uC++,styles:e.styles||xt,_:null,setInput:null,schemas:e.schemas||null,tView:null},o=e.dependencies,s=e.features;return r.inputs=f0(e.inputs,i),r.outputs=f0(e.outputs),s&&s.forEach(a=>a(r)),r.directiveDefs=o?()=>("function"==typeof o?o():o).map(u0).filter(d0):null,r.pipeDefs=o?()=>("function"==typeof o?o():o).map(Gn).filter(d0):null,r})}function u0(e){return Ft(e)||Un(e)}function d0(e){return null!==e}const fC={};function _c(e){return fo(()=>{const t={type:e.type,bootstrap:e.bootstrap||xt,declarations:e.declarations||xt,imports:e.imports||xt,exports:e.exports||xt,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null};return null!=e.id&&(fC[e.id]=e.type),t})}function f0(e,t){if(null==e)return Bs;const n={};for(const i in e)if(e.hasOwnProperty(i)){let r=e[i],o=r;Array.isArray(r)&&(o=r[1],r=r[0]),n[r]=i,t&&(t[r]=o)}return n}function Ft(e){return e[Mu]||null}function Un(e){return e[Ph]||null}function Gn(e){return e[Fh]||null}function ti(e){return Array.isArray(e)&&"object"==typeof e[1]}function Ui(e){return Array.isArray(e)&&!0===e[1]}function Gi(e){return null!==e.template}function yC(e){return 0!=(256&e[2])}function Xo(e,t){return e.hasOwnProperty(Nr)?e[Nr]:null}class xC{constructor(t,n,i){this.previousValue=t,this.currentValue=n,this.firstChange=i}isFirstChange(){return this.firstChange}}function m0(e){return e.type.prototype.ngOnChanges&&(e.setInput=bC),wC}function wC(){const e=y0(this),t=e?.current;if(t){const n=e.previous;if(n===Bs)e.previous=t;else for(let i in t)n[i]=t[i];e.current=null,this.ngOnChanges(t)}}function bC(e,t,n,i){const r=y0(e)||function MC(e,t){return e[g0]=t}(e,{previous:Bs,current:null}),o=r.current||(r.current={}),s=r.previous,a=this.declaredInputs[n],c=s[a];o[a]=new xC(c&&c.currentValue,t,s===Bs),e[i]=t}const g0="__ngSimpleChanges__";function y0(e){return e[g0]||null}function un(e){for(;Array.isArray(e);)e=e[0];return e}function Ai(e,t){return un(t[e.index])}function fi(e,t){const n=t[e];return ti(n)?n:n[0]}function jh(e){return 64==(64&e[2])}function _0(e){e[18]=0}function Wh(e,t){e[5]+=t;let n=e,i=e[3];for(;null!==i&&(1===t&&1===n[5]||-1===t&&0===n[5]);)i[5]+=t,n=i,i=i[3]}const Ue={lFrame:C0(null),bindingsEnabled:!0};function G(){return Ue.lFrame.lView}function yn(){let e=b0();for(;null!==e&&64===e.type;)e=e.parent;return e}function b0(){return Ue.lFrame.currentTNode}function lr(e,t){const n=Ue.lFrame;n.currentTNode=e,n.isParent=t}function HC(e,t){const n=Ue.lFrame;n.bindingIndex=n.bindingRootIndex=e,function Xh(e){Ue.lFrame.currentDirectiveIndex=e}(t)}function Zh(e){Ue.lFrame.currentQueryIndex=e}function UC(e){const t=e[1];return 2===t.type?t.declTNode:1===t.type?e[6]:null}function T0(e,t,n){if(n&Be.SkipSelf){let r=t,o=e;for(;!(r=r.parent,null!==r||n&Be.Host||(r=UC(o),null===r||(o=o[15],10&r.type))););if(null===r)return!1;t=r,e=o}const i=Ue.lFrame=D0();return i.currentTNode=t,i.lView=e,!0}function Jh(e){const t=D0(),n=e[1];Ue.lFrame=t,t.currentTNode=n.firstChild,t.lView=e,t.tView=n,t.contextLView=e,t.bindingIndex=n.bindingStartIndex,t.inI18n=!1}function D0(){const e=Ue.lFrame,t=null===e?null:e.child;return null===t?C0(e):t}function C0(e){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return null!==e&&(e.child=t),t}function A0(){const e=Ue.lFrame;return Ue.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}const I0=A0;function Qh(){const e=A0();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function jn(){return Ue.lFrame.selectedIndex}function po(e){Ue.lFrame.selectedIndex=e}function Pu(e,t,n){L0(e,t,3,n)}function Fu(e,t,n,i){(3&e[2])===n&&L0(e,t,n,i)}function Kh(e,t){let n=e[2];(3&n)===t&&(n&=2047,n+=1,e[2]=n)}function L0(e,t,n,i){const o=i??-1,s=t.length-1;let a=0;for(let c=void 0!==i?65535&e[18]:0;c<s;c++)if("number"==typeof t[c+1]){if(a=t[c],null!=i&&a>=i)break}else t[c]<0&&(e[18]+=65536),(a<o||-1==o)&&(ZC(e,n,t,c),e[18]=(4294901760&e[18])+c+2),c++}function ZC(e,t,n,i){const r=n[i]<0,o=n[i+1],a=e[r?-n[i]:n[i]];if(r){if(e[2]>>11<e[18]>>16&&(3&e[2])===t){e[2]+=2048;try{o.call(a)}finally{}}}else try{o.call(a)}finally{}}class Ec{constructor(t,n,i){this.factory=t,this.resolving=!1,this.canSeeViewProviders=n,this.injectImpl=i}}function Nu(e,t,n){let i=0;for(;i<n.length;){const r=n[i];if("number"==typeof r){if(0!==r)break;i++;const o=n[i++],s=n[i++],a=n[i++];e.setAttribute(t,s,a,o)}else{const o=r,s=n[++i];P0(o)?e.setProperty(t,o,s):e.setAttribute(t,o,s),i++}}return i}function P0(e){return 64===e.charCodeAt(0)}function js(e){return 32767&e}function Ws(e,t){let n=function tA(e){return e>>16}(e),i=t;for(;n>0;)i=i[15],n--;return i}let tp=!0;function Bu(e){const t=tp;return tp=e,t}let nA=0;const ur={};function np(e,t){e.push(0,0,0,0,0,0,0,0,t)}function ip(e,t){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null===t[e.injectorIndex+8]?-1:e.injectorIndex}function ku(e,t){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let n=0,i=null,r=t;for(;null!==r;){if(i=j0(r),null===i)return-1;if(n++,r=r[15],-1!==i.injectorIndex)return i.injectorIndex|n<<16}return-1}function k0(e,t,n){if(n&Be.Optional)return e;wu()}function H0(e,t,n,i){if(n&Be.Optional&&void 0===i&&(i=null),0==(n&(Be.Self|Be.Host))){const r=e[9],o=ar(void 0);try{return r?r.get(t,i,n&Be.Optional):c0(t,i,n&Be.Optional)}finally{ar(o)}}return k0(i,0,n)}function V0(e,t,n,i=Be.Default,r){if(null!==e){if(1024&t[2]){const s=function lA(e,t,n,i,r){let o=e,s=t;for(;null!==o&&null!==s&&1024&s[2]&&!(256&s[2]);){const a=U0(o,s,n,i|Be.Self,ur);if(a!==ur)return a;let c=o.parent;if(!c){const l=s[21];if(l){const d=l.get(n,ur,i);if(d!==ur)return d}c=j0(s),s=s[15]}o=c}return r}(e,t,n,i,ur);if(s!==ur)return s}const o=U0(e,t,n,i,ur);if(o!==ur)return o}return H0(t,n,i,r)}function U0(e,t,n,i,r){const o=function sA(e){if("string"==typeof e)return e.charCodeAt(0)||0;const t=e.hasOwnProperty(vc)?e[vc]:void 0;return"number"==typeof t?t>=0?255&t:aA:t}(n);if("function"==typeof o){if(!T0(t,e,i))return i&Be.Host?k0(r,0,i):H0(t,n,i,r);try{const s=o(i);if(null!=s||i&Be.Optional)return s;wu()}finally{I0()}}else if("number"==typeof o){let s=null,a=ip(e,t),c=-1,l=i&Be.Host?t[16][6]:null;for((-1===a||i&Be.SkipSelf)&&(c=-1===a?ku(e,t):t[a+8],-1!==c&&z0(i,!1)?(s=t[1],a=js(c),t=Ws(c,t)):a=-1);-1!==a;){const d=t[1];if(G0(o,a,d.data)){const u=oA(a,t,n,s,i,l);if(u!==ur)return u}c=t[a+8],-1!==c&&z0(i,t[1].data[a+8]===l)&&G0(o,a,t)?(s=d,a=js(c),t=Ws(c,t)):a=-1}}return r}function oA(e,t,n,i,r,o){const s=t[1],a=s.data[e+8],d=function Vu(e,t,n,i,r){const o=e.providerIndexes,s=t.data,a=1048575&o,c=e.directiveStart,d=o>>20,f=r?a+d:e.directiveEnd;for(let h=i?a:a+d;h<f;h++){const p=s[h];if(h<c&&n===p||h>=c&&p.type===n)return h}if(r){const h=s[c];if(h&&Gi(h)&&h.type===n)return c}return null}(a,s,n,null==i?function Du(e){return 2==(2&e.flags)}(a)&&tp:i!=s&&0!=(3&a.type),r&Be.Host&&o===a);return null!==d?Dc(t,s,d,a):ur}function Dc(e,t,n,i){let r=e[n];const o=t.data;if(function JC(e){return e instanceof Ec}(r)){const s=r;s.resolving&&function tC(e,t){const n=t?`. Dependency path: ${t.join(" > ")} > ${e}`:"";throw new Oe(-200,`Circular dependency in DI detected for ${e}${n}`)}(function _t(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():We(e)}(o[n]));const a=Bu(s.canSeeViewProviders);s.resolving=!0;const c=s.injectImpl?ar(s.injectImpl):null;T0(e,i,Be.Default);try{r=e[n]=s.factory(void 0,o,e,i),t.firstCreatePass&&n>=i.directiveStart&&function YC(e,t,n){const{ngOnChanges:i,ngOnInit:r,ngDoCheck:o}=t.type.prototype;if(i){const s=m0(t);(n.preOrderHooks||(n.preOrderHooks=[])).push(e,s),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,s)}r&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-e,r),o&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e,o),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,o))}(n,o[n],t)}finally{null!==c&&ar(c),Bu(a),s.resolving=!1,I0()}}return r}function G0(e,t,n){return!!(n[t+(e>>5)]&1<<e)}function z0(e,t){return!(e&Be.Self||e&Be.Host&&t)}class qs{constructor(t,n){this._tNode=t,this._lView=n}get(t,n,i){return V0(this._tNode,this._lView,t,i,n)}}function aA(){return new qs(yn(),G())}function j0(e){const t=e[1],n=t.type;return 2===n?t.declTNode:1===n?e[6]:null}class pt{constructor(t,n){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof n?this.__NG_ELEMENT_ID__=n:void 0!==n&&(this.\u0275prov=Wt({token:this,providedIn:n.providedIn||"root",factory:n.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function kr(e,t){e.forEach(n=>Array.isArray(n)?kr(n,t):t(n))}function Uu(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}const Lc={},zu="ngTempTokenPath",wA=/\n/gm,Z0="__source";let Rc,hp;function ju(e){const t=Rc;return Rc=e,t}function MA(e,t=Be.Default){if(void 0===Rc)throw new Oe(-203,!1);return null===Rc?c0(e,void 0,t):Rc.get(e,t&Be.Optional?null:void 0,t)}function bt(e,t=Be.Default){return(function lC(){return Rh}()||MA)(Ne(e),t)}function dp(e){const t=[];for(let n=0;n<e.length;n++){const i=Ne(e[n]);if(Array.isArray(i)){if(0===i.length)throw new Oe(900,!1);let r,o=Be.Default;for(let s=0;s<i.length;s++){const a=i[s],c=SA(a);"number"==typeof c?-1===c?r=a.token:o|=c:r=a}t.push(bt(r,o))}else t.push(bt(i))}return t}function SA(e){return e.__NG_DI_FLAG__}function wp(e){return e.ngOriginalError}class ea{constructor(){this._console=console}handleError(t){const n=this._findOriginalError(t);this._console.error("ERROR",t),n&&this._console.error("ORIGINAL ERROR",n)}_findOriginalError(t){let n=t&&wp(t);for(;n&&wp(n);)n=wp(n);return n||null}}const bp=new Map;let vI=0;const Ep="__ngContext__";function Fn(e,t){ti(t)?(e[Ep]=t[20],function xI(e){bp.set(e[20],e)}(t)):e[Ep]=t}function Hc(e){const t=e[Ep];return"number"==typeof t?function x_(e){return bp.get(e)||null}(t):t||null}function Sp(e){const t=Hc(e);return t?ti(t)?t:t.lView:null}const AI=(()=>(typeof requestAnimationFrame<"u"&&requestAnimationFrame||setTimeout).bind(Ct))();var ni=(()=>((ni=ni||{})[ni.Important=1]="Important",ni[ni.DashCase=2]="DashCase",ni))();function Dp(e,t){return undefined(e,t)}function Vc(e){const t=e[3];return Ui(t)?t[3]:t}function Cp(e){return A_(e[13])}function Ap(e){return A_(e[4])}function A_(e){for(;null!==e&&!Ui(e);)e=e[4];return e}function na(e,t,n,i,r){if(null!=i){let o,s=!1;Ui(i)?o=i:ti(i)&&(s=!0,i=i[0]);const a=un(i);0===e&&null!==n?null==r?N_(t,n,a):Yo(t,n,a,r||null,!0):1===e&&null!==n?Yo(t,n,a,r||null,!0):2===e?function G_(e,t,n){const i=function Ku(e,t){return e.parentNode(t)}(e,t);i&&function WI(e,t,n,i){e.removeChild(t,n,i)}(e,i,t,n)}(t,a,s):3===e&&t.destroyNode(a),null!=o&&function XI(e,t,n,i,r){const o=n[7];o!==un(n)&&na(t,e,i,o,r);for(let a=10;a<n.length;a++){const c=n[a];Uc(c[1],c,e,t,i,o)}}(t,e,o,n,r)}}function L_(e,t){const n=e[9],i=n.indexOf(t),r=t[3];512&t[2]&&(t[2]&=-513,Wh(r,-1)),n.splice(i,1)}function Pp(e,t){if(!(128&t[2])){t[2]&=-65,t[2]|=128,function jI(e,t){let n;if(null!=e&&null!=(n=e.destroyHooks))for(let i=0;i<n.length;i+=2){const r=t[n[i]];if(!(r instanceof Ec)){const o=n[i+1];if(Array.isArray(o))for(let s=0;s<o.length;s+=2){const a=r[o[s]],c=o[s+1];try{c.call(a)}finally{}}else try{o.call(r)}finally{}}}}(e,t),function zI(e,t){const n=e.cleanup,i=t[7];let r=-1;if(null!==n)for(let o=0;o<n.length-1;o+=2)if("string"==typeof n[o]){const s=n[o+1],a="function"==typeof s?s(t):un(t[s]),c=i[r=n[o+2]],l=n[o+3];"boolean"==typeof l?a.removeEventListener(n[o],c,l):l>=0?i[r=l]():i[r=-l].unsubscribe(),o+=2}else{const s=i[r=n[o+1]];n[o].call(s)}if(null!==i){for(let o=r+1;o<i.length;o++)i[o]();t[7]=null}}(e,t),1===t[1].type&&t[11].destroy();const n=t[17];if(null!==n&&Ui(t[3])){n!==t[3]&&L_(n,t);const i=t[19];null!==i&&i.detachView(e)}!function wI(e){bp.delete(e[20])}(t)}}function P_(e,t,n){return function F_(e,t,n){let i=t;for(;null!==i&&40&i.type;)i=(t=i).parent;if(null===i)return n[0];if(2&i.flags){const r=e.data[i.directiveStart].encapsulation;if(r===cr.None||r===cr.Emulated)return null}return Ai(i,n)}(e,t.parent,n)}function Yo(e,t,n,i,r){e.insertBefore(t,n,i,r)}function N_(e,t,n){e.appendChild(t,n)}function O_(e,t,n,i,r){null!==i?Yo(e,t,n,i,r):N_(e,t,n)}let H_=function k_(e,t,n){return 40&e.type?Ai(e,n):null};function ed(e,t,n,i){const r=P_(e,i,t),o=t[11],a=function B_(e,t,n){return H_(e,t,n)}(i.parent||t[6],i,t);if(null!=r)if(Array.isArray(n))for(let c=0;c<n.length;c++)O_(o,r,n[c],a,!1);else O_(o,r,n,a,!1)}function U_(e,t){return null!==t?e[16][6].projection[t.projection]:null}function Op(e,t,n,i,r,o,s){for(;null!=n;){const a=i[n.index],c=n.type;if(s&&0===t&&(a&&Fn(un(a),i),n.flags|=4),64!=(64&n.flags))if(8&c)Op(e,t,n.child,i,r,o,!1),na(t,e,r,a,o);else if(32&c){const l=Dp(n,i);let d;for(;d=l();)na(t,e,r,d,o);na(t,e,r,a,o)}else 16&c?z_(e,t,i,n,r,o):na(t,e,r,a,o);n=s?n.projectionNext:n.next}}function Uc(e,t,n,i,r,o){Op(n,i,e.firstChild,t,r,o,!1)}function z_(e,t,n,i,r,o){const s=n[16],c=s[6].projection[i.projection];if(Array.isArray(c))for(let l=0;l<c.length;l++)na(t,e,r,c[l],o);else Op(e,t,c,s[3],r,o,!0)}function Bp(e,t,n){""===n?e.removeAttribute(t,"class"):e.setAttribute(t,"class",n)}function zi(e){return 0==(1&e)}function Y_(e,t){return e?":not("+t.trim()+")":t}function rL(e){let t=e[0],n=1,i=2,r="",o=!1;for(;n<e.length;){let s=e[n];if("string"==typeof s)if(2&i){const a=e[++n];r+="["+s+(a.length>0?'="'+a+'"':"")+"]"}else 8&i?r+="."+s:4&i&&(r+=" "+s);else""!==r&&!zi(s)&&(t+=Y_(o,r),r=""),i=s,o=o||!zi(i);n++}return""!==r&&(t+=Y_(o,r)),t}const qe={};const ex=new pt("ENVIRONMENT_INITIALIZER"),tx=new pt("INJECTOR_DEF_TYPES");function hL(...e){return{\u0275providers:nx(0,e)}}function nx(e,...t){const n=[],i=new Set;let r;return kr(t,o=>{const s=o;kp(s,n,[],i)&&(r||(r=[]),r.push(s))}),void 0!==r&&ix(r,n),n}function ix(e,t){for(let n=0;n<e.length;n++){const{providers:r}=e[n];kr(r,o=>{t.push(o)})}}function kp(e,t,n,i){if(!(e=Ne(e)))return!1;let r=null,o=s0(e);const s=!o&&Ft(e);if(o||s){if(s&&!s.standalone)return!1;r=e}else{const c=e.ngModule;if(o=s0(c),!o)return!1;r=c}const a=i.has(r);if(s){if(a)return!1;if(i.add(r),s.dependencies){const c="function"==typeof s.dependencies?s.dependencies():s.dependencies;for(const l of c)kp(l,t,n,i)}}else{if(!o)return!1;{if(null!=o.imports&&!a){let l;i.add(r);try{kr(o.imports,d=>{kp(d,t,n,i)&&(l||(l=[]),l.push(d))})}finally{}void 0!==l&&ix(l,t)}if(!a){const l=Xo(r)||(()=>new r);t.push({provide:r,useFactory:l,deps:xt},{provide:tx,useValue:r,multi:!0},{provide:ex,useValue:()=>bt(r),multi:!0})}const c=o.providers;null==c||a||kr(c,d=>{t.push(d)})}}return r!==e&&void 0!==e.providers}const pL=Rt({provide:String,useValue:Rt});function Hp(e){return null!==e&&"object"==typeof e&&pL in e}function Zo(e){return"function"==typeof e}const Vp=new pt("INJECTOR",-1);class sx{get(t,n=Lc){if(n===Lc){const i=new Error(`NullInjectorError: No provider for ${Pt(t)}!`);throw i.name="NullInjectorError",i}return n}}const Up=new pt("Set Injector scope."),nd={},gL={};let Gp;function zp(){return void 0===Gp&&(Gp=new sx),Gp}class Gc{}class ax extends Gc{constructor(t,n,i,r){super(),this.parent=n,this.source=i,this.scopes=r,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,Wp(t,s=>this.processProvider(s)),this.records.set(Vp,ia(void 0,this)),r.has("environment")&&this.records.set(Gc,ia(void 0,this));const o=this.records.get(Up);null!=o&&"string"==typeof o.value&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(tx.multi,xt,Be.Self))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const t of this._ngOnDestroyHooks)t.ngOnDestroy();for(const t of this._onDestroyHooks)t()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(t){this._onDestroyHooks.push(t)}get(t,n=Lc,i=Be.Default){this.assertNotDestroyed();const r=ju(this),o=ar(void 0);try{if(!(i&Be.SkipSelf)){let a=this.records.get(t);if(void 0===a){const c=function wL(e){return"function"==typeof e||"object"==typeof e&&e instanceof pt}(t)&&Ih(t);a=c&&this.injectableDefInScope(c)?ia(jp(t),nd):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(i&Be.Self?zp():this.parent).get(t,n=i&Be.Optional&&n===Lc?null:n)}catch(s){if("NullInjectorError"===s.name){if((s[zu]=s[zu]||[]).unshift(Pt(t)),r)throw s;return function TA(e,t,n,i){const r=e[zu];throw t[Z0]&&r.unshift(t[Z0]),e.message=function DA(e,t,n,i=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.slice(2):e;let r=Pt(t);if(Array.isArray(t))r=t.map(Pt).join(" -> ");else if("object"==typeof t){let o=[];for(let s in t)if(t.hasOwnProperty(s)){let a=t[s];o.push(s+":"+("string"==typeof a?JSON.stringify(a):Pt(a)))}r=`{${o.join(", ")}}`}return`${n}${i?"("+i+")":""}[${r}]: ${e.replace(wA,"\n  ")}`}("\n"+e.message,r,n,i),e.ngTokenPath=r,e[zu]=null,e}(s,t,"R3InjectorError",this.source)}throw s}finally{ar(o),ju(r)}}resolveInjectorInitializers(){const t=ju(this),n=ar(void 0);try{const i=this.get(ex.multi,xt,Be.Self);for(const r of i)r()}finally{ju(t),ar(n)}}toString(){const t=[],n=this.records;for(const i of n.keys())t.push(Pt(i));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Oe(205,!1)}processProvider(t){let n=Zo(t=Ne(t))?t:Ne(t&&t.provide);const i=function vL(e){return Hp(e)?ia(void 0,e.useValue):ia(function cx(e,t,n){let i;if(Zo(e)){const r=Ne(e);return Xo(r)||jp(r)}if(Hp(e))i=()=>Ne(e.useValue);else if(function ox(e){return!(!e||!e.useFactory)}(e))i=()=>e.useFactory(...dp(e.deps||[]));else if(function rx(e){return!(!e||!e.useExisting)}(e))i=()=>bt(Ne(e.useExisting));else{const r=Ne(e&&(e.useClass||e.provide));if(!function _L(e){return!!e.deps}(e))return Xo(r)||jp(r);i=()=>new r(...dp(e.deps))}return i}(e),nd)}(t);if(Zo(t)||!0!==t.multi)this.records.get(n);else{let r=this.records.get(n);r||(r=ia(void 0,nd,!0),r.factory=()=>dp(r.multi),this.records.set(n,r)),n=t,r.multi.push(t)}this.records.set(n,i)}hydrate(t,n){return n.value===nd&&(n.value=gL,n.value=n.factory()),"object"==typeof n.value&&n.value&&function xL(e){return null!==e&&"object"==typeof e&&"function"==typeof e.ngOnDestroy}(n.value)&&this._ngOnDestroyHooks.add(n.value),n.value}injectableDefInScope(t){if(!t.providedIn)return!1;const n=Ne(t.providedIn);return"string"==typeof n?"any"===n||this.scopes.has(n):this.injectorDefTypes.has(n)}}function jp(e){const t=Ih(e),n=null!==t?t.factory:Xo(e);if(null!==n)return n;if(e instanceof pt)throw new Oe(204,!1);if(e instanceof Function)return function yL(e){const t=e.length;if(t>0)throw function Ic(e,t){const n=[];for(let i=0;i<e;i++)n.push(t);return n}(t,"?"),new Oe(204,!1);const n=function sC(e){const t=e&&(e[bu]||e[a0]);if(t){const n=function aC(e){if(e.hasOwnProperty("name"))return e.name;const t=(""+e).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(e);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),t}return null}(e);return null!==n?()=>n.factory(e):()=>new e}(e);throw new Oe(204,!1)}function ia(e,t,n=!1){return{factory:e,value:t,multi:n?[]:void 0}}function bL(e){return!!e.\u0275providers}function Wp(e,t){for(const n of e)Array.isArray(n)?Wp(n,t):bL(n)?Wp(n.\u0275providers,t):t(n)}function lx(e,t=null,n=null,i){const r=ux(e,t,n,i);return r.resolveInjectorInitializers(),r}function ux(e,t=null,n=null,i,r=new Set){const o=[n||xt,hL(e)];return i=i||("object"==typeof e?void 0:Pt(e)),new ax(o,t||zp(),i||null,r)}let fr=(()=>{class e{static create(n,i){if(Array.isArray(n))return lx({name:""},i,n,"");{const r=n.name??"";return lx({name:r},n.parent,n.providers,r)}}}return e.THROW_IF_NOT_FOUND=Lc,e.NULL=new sx,e.\u0275prov=Wt({token:e,providedIn:"any",factory:()=>bt(Vp)}),e.__NG_ELEMENT_ID__=-1,e})();function ot(e,t=Be.Default){const n=G();return null===n?bt(e,t):V0(yn(),n,Ne(e),t)}function Ix(e,t){const n=e.contentQueries;if(null!==n)for(let i=0;i<n.length;i+=2){const r=n[i],o=n[i+1];if(-1!==o){const s=e.data[o];Zh(r),s.contentQueries(2,t[o],o)}}}function ad(e,t,n,i,r,o,s,a,c,l,d){const u=t.blueprint.slice();return u[0]=r,u[2]=76|i,(null!==d||e&&1024&e[2])&&(u[2]|=1024),_0(u),u[3]=u[15]=e,u[8]=n,u[10]=s||e&&e[10],u[11]=a||e&&e[11],u[12]=c||e&&e[12]||null,u[9]=l||e&&e[9]||null,u[6]=o,u[20]=function _I(){return vI++}(),u[21]=d,u[16]=2==t.type?e[16]:u,u}function oa(e,t,n,i,r){let o=e.data[t];if(null===o)o=function um(e,t,n,i,r){const o=b0(),s=function qh(){return Ue.lFrame.isParent}(),c=e.data[t]=function nR(e,t,n,i,r,o){return{type:n,index:i,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,s?o:o&&o.parent,n,t,i,r);return null===e.firstChild&&(e.firstChild=c),null!==o&&(s?null==o.child&&null!==c.parent&&(o.child=c):null===o.next&&(o.next=c)),c}(e,t,n,i,r),function kC(){return Ue.lFrame.inI18n}()&&(o.flags|=64);else if(64&o.type){o.type=n,o.value=i,o.attrs=r;const s=function Mc(){const e=Ue.lFrame,t=e.currentTNode;return e.isParent?t:t.parent}();o.injectorIndex=null===s?-1:s.injectorIndex}return lr(o,!0),o}function sa(e,t,n,i){if(0===n)return-1;const r=t.length;for(let o=0;o<n;o++)t.push(i),e.blueprint.push(i),e.data.push(null);return r}function cd(e,t,n){Jh(t);try{const i=e.viewQuery;null!==i&&xm(1,i,n);const r=e.template;null!==r&&Lx(e,t,r,1,n),e.firstCreatePass&&(e.firstCreatePass=!1),e.staticContentQueries&&Ix(e,t),e.staticViewQueries&&xm(2,e.viewQuery,n);const o=e.components;null!==o&&function QL(e,t){for(let n=0;n<t.length;n++)xR(e,t[n])}(t,o)}catch(i){throw e.firstCreatePass&&(e.incompleteFirstPass=!0,e.firstCreatePass=!1),i}finally{t[2]&=-5,Qh()}}function zc(e,t,n,i){const r=t[2];if(128!=(128&r)){Jh(t);try{_0(t),function M0(e){return Ue.lFrame.bindingIndex=e}(e.bindingStartIndex),null!==n&&Lx(e,t,n,2,i);const s=3==(3&r);if(s){const l=e.preOrderCheckHooks;null!==l&&Pu(t,l,null)}else{const l=e.preOrderHooks;null!==l&&Fu(t,l,0,null),Kh(t,0)}if(function vR(e){for(let t=Cp(e);null!==t;t=Ap(t)){if(!t[2])continue;const n=t[9];for(let i=0;i<n.length;i++){const r=n[i],o=r[3];0==(512&r[2])&&Wh(o,1),r[2]|=512}}}(t),function yR(e){for(let t=Cp(e);null!==t;t=Ap(t))for(let n=10;n<t.length;n++){const i=t[n],r=i[1];jh(i)&&zc(r,i,r.template,i[8])}}(t),null!==e.contentQueries&&Ix(e,t),s){const l=e.contentCheckHooks;null!==l&&Pu(t,l)}else{const l=e.contentHooks;null!==l&&Fu(t,l,1),Kh(t,1)}!function ZL(e,t){const n=e.hostBindingOpCodes;if(null!==n)try{for(let i=0;i<n.length;i++){const r=n[i];if(r<0)po(~r);else{const o=r,s=n[++i],a=n[++i];HC(s,o),a(2,t[o])}}}finally{po(-1)}}(e,t);const a=e.components;null!==a&&function JL(e,t){for(let n=0;n<t.length;n++)_R(e,t[n])}(t,a);const c=e.viewQuery;if(null!==c&&xm(2,c,i),s){const l=e.viewCheckHooks;null!==l&&Pu(t,l)}else{const l=e.viewHooks;null!==l&&Fu(t,l,2),Kh(t,2)}!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),t[2]&=-41,512&t[2]&&(t[2]&=-513,Wh(t[3],-1))}finally{Qh()}}}function KL(e,t,n,i){const r=t[10],s=function v0(e){return 4==(4&e[2])}(t);try{!s&&r.begin&&r.begin(),s&&cd(e,t,i),zc(e,t,n,i)}finally{!s&&r.end&&r.end()}}function Lx(e,t,n,i,r){const o=jn(),s=2&i;try{po(-1),s&&t.length>22&&function Z_(e,t,n,i){if(!i)if(3==(3&t[2])){const o=e.preOrderCheckHooks;null!==o&&Pu(t,o,n)}else{const o=e.preOrderHooks;null!==o&&Fu(t,o,0,n)}po(n)}(e,t,22,!1),n(i,r)}finally{po(o)}}function hm(e,t,n,i,r,o,s,a,c,l){const d=22+i,u=d+r,f=function eR(e,t){const n=[];for(let i=0;i<t;i++)n.push(i<e?null:qe);return n}(d,u),h="function"==typeof l?l():l;return f[1]={type:e,blueprint:f,template:n,queries:null,viewQuery:a,declTNode:t,data:f.slice().fill(null,d),bindingStartIndex:d,expandoStartIndex:u,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof s?s():s,firstChild:null,schemas:c,consts:h,incompleteFirstPass:!1}}function Ox(e,t,n,i,r,o){const s=o.hostBindings;if(s){let a=e.hostBindingOpCodes;null===a&&(a=e.hostBindingOpCodes=[]);const c=~t.index;(function cR(e){let t=e.length;for(;t>0;){const n=e[--t];if("number"==typeof n&&n<0)return n}return 0})(a)!=c&&a.push(c),a.push(i,r,s)}}function _R(e,t){const n=fi(t,e);if(jh(n)){const i=n[1];48&n[2]?zc(i,n,i.template,n[8]):n[5]>0&&gm(n)}}function gm(e){for(let i=Cp(e);null!==i;i=Ap(i))for(let r=10;r<i.length;r++){const o=i[r];if(512&o[2]){const s=o[1];zc(s,o,s.template,o[8])}else o[5]>0&&gm(o)}const n=e[1].components;if(null!==n)for(let i=0;i<n.length;i++){const r=fi(n[i],e);jh(r)&&r[5]>0&&gm(r)}}function xR(e,t){const n=fi(t,e),i=n[1];(function wR(e,t){for(let n=t.length;n<e.blueprint.length;n++)t.push(e.blueprint[n])})(i,n),cd(i,n,n[8])}function _m(e,t,n){const i=t[10];i.begin&&i.begin();try{zc(e,t,e.template,n)}catch(r){throw function qx(e,t){const n=e[9],i=n?n.get(ea,null):null;i&&i.handleError(t)}(t,r),r}finally{i.end&&i.end()}}function Gx(e){!function vm(e){for(let t=0;t<e.components.length;t++){const n=e.components[t],i=Sp(n);if(null!==i){const r=i[1];KL(r,i,r.template,n)}}}(e[8])}function xm(e,t,n){Zh(0),t(e,n)}const MR=(()=>Promise.resolve(null))();function Ur(e,t,n){const i=function Iu(e,t){return un(t[e])}(t,e);!function I_(e,t,n){e.setValue(t,n)}(e[11],i,n)}function SR(e,t,n,i,r){const o=n[1],s=function aR(e,t,n){const i=yn();e.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),function Vx(e,t,n,i,r){e.data[i]=r;const o=r.factory||(r.factory=Xo(r.type)),s=new Ec(o,Gi(r),ot);e.blueprint[i]=s,n[i]=s,Ox(e,t,0,i,sa(e,n,r.hostVars,qe),r)}(e,i,t,sa(e,t,1,null),n));const r=Dc(t,e,i.directiveStart,i);Fn(r,t);const o=Ai(i,t);return o&&Fn(o,t),r}(o,n,t);if(i.components.push(s),e[8]=s,null!==r)for(const c of r)c(s,t);if(t.contentQueries){const c=yn();t.contentQueries(1,s,c.directiveStart)}const a=yn();return!o.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(po(a.index),Ox(n[1],a,0,a.directiveStart,a.directiveEnd,t),function Bx(e,t){null!==e.hostBindings&&e.hostBindings(1,t)}(t,s)),s}function DR(){const e=yn();!function Ru(e,t){for(let n=t.directiveStart,i=t.directiveEnd;n<i;n++){const o=e.data[n].type.prototype,{ngAfterContentInit:s,ngAfterContentChecked:a,ngAfterViewInit:c,ngAfterViewChecked:l,ngOnDestroy:d}=o;s&&(e.contentHooks||(e.contentHooks=[])).push(-n,s),a&&((e.contentHooks||(e.contentHooks=[])).push(n,a),(e.contentCheckHooks||(e.contentCheckHooks=[])).push(n,a)),c&&(e.viewHooks||(e.viewHooks=[])).push(-n,c),l&&((e.viewHooks||(e.viewHooks=[])).push(n,l),(e.viewCheckHooks||(e.viewCheckHooks=[])).push(n,l)),null!=d&&(e.destroyHooks||(e.destroyHooks=[])).push(n,d)}}(G()[1],e)}function ca(e,t,n,i){return function Nn(e,t,n){return!Object.is(e[t],n)&&(e[t]=n,!0)}(e,function zs(){return Ue.lFrame.bindingIndex++}(),n)?t+We(n)+i:qe}function Cm(e){return!!e&&"function"==typeof e.then}const $R=function lw(e){return!!e&&"function"==typeof e.subscribe};function Hw(e,t=""){const n=G(),i=function gt(){return Ue.lFrame.tView}(),r=e+22,o=i.firstCreatePass?oa(i,r,1,t,null):i.data[r],s=n[r]=function Ip(e,t){return e.createText(t)}(n[11],t);ed(i,n,s,o),lr(o,!1)}function pd(e,t,n){const i=G(),r=ca(i,e,t,n);return r!==qe&&Ur(i,jn(),r),pd}const va="en-US";let cb=va;class BF{resolveComponentFactory(t){throw function OF(e){const t=Error(`No component factory found for ${Pt(e)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=e,t}(t)}}let _d=(()=>{class e{}return e.NULL=new BF,e})();class es{}class Nb{}function VF(){return xa(yn(),G())}function xa(e,t){return new ts(Ai(e,t))}let ts=(()=>{class e{constructor(n){this.nativeElement=n}}return e.__NG_ELEMENT_ID__=VF,e})();class Ob{}let zF=(()=>{class e{}return e.\u0275prov=Wt({token:e,providedIn:"root",factory:()=>null}),e})();class Bm{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const jF=new Bm("14.0.5"),km={};function xd(e,t,n,i,r=!1){for(;null!==n;){const o=t[n.index];if(null!==o&&i.push(un(o)),Ui(o))for(let a=10;a<o.length;a++){const c=o[a],l=c[1].firstChild;null!==l&&xd(c[1],c,l,i)}const s=n.type;if(8&s)xd(e,t,n.child,i);else if(32&s){const a=Dp(n,t);let c;for(;c=a();)i.push(c)}else if(16&s){const a=U_(t,n);if(Array.isArray(a))i.push(...a);else{const c=Vc(t[16]);xd(c[1],c,a,i,!0)}}n=r?n.projectionNext:n.next}return i}class WF extends class Jc{constructor(t,n){this._lView=t,this._cdRefInjectingView=n,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,n=t[1];return xd(n,t,n.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 128==(128&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Ui(t)){const n=t[8],i=n?n.indexOf(this):-1;i>-1&&(function Rp(e,t){if(e.length<=10)return;const n=10+t,i=e[n];if(i){const r=i[17];null!==r&&r!==e&&L_(r,i),t>0&&(e[n-1][4]=i[4]);const o=Uu(e,10+t);!function BI(e,t){Uc(e,t,t[11],2,null,null),t[0]=null,t[6]=null}(i[1],i);const s=o[19];null!==s&&s.detachView(o[1]),i[3]=null,i[4]=null,i[2]&=-65}return i}(t,i),Uu(n,i))}this._attachedToViewContainer=!1}!function R_(e,t){if(!(128&t[2])){const n=t[11];n.destroyNode&&Uc(e,t,n,3,null,null),function VI(e){let t=e[13];if(!t)return Pp(e[1],e);for(;t;){let n=null;if(ti(t))n=t[13];else{const i=t[10];i&&(n=i)}if(!n){for(;t&&!t[4]&&t!==e;)ti(t)&&Pp(t[1],t),t=t[3];null===t&&(t=e),ti(t)&&Pp(t[1],t),n=t&&t[4]}t=n}}(t)}}(this._lView[1],this._lView)}onDestroy(t){!function Fx(e,t,n,i){const r=function zx(e){return e[7]||(e[7]=[])}(t);null===n?r.push(i):(r.push(n),e.firstCreatePass&&function jx(e){return e.cleanup||(e.cleanup=[])}(e).push(i,r.length-1))}(this._lView[1],this._lView,null,t)}markForCheck(){!function ym(e){for(;e;){e[2]|=32;const t=Vc(e);if(yC(e)&&!t)return e;e=t}return null}(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-65}reattach(){this._lView[2]|=64}detectChanges(){_m(this._lView[1],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Oe(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function HI(e,t){Uc(e,t,t[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Oe(902,!1);this._appRef=t}}{constructor(t){super(t),this._view=t}detectChanges(){Gx(this._view)}checkNoChanges(){}get context(){return null}}class Hm extends _d{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const n=Ft(t);return new Vm(n,this.ngModule)}}function kb(e){const t=[];for(let n in e)e.hasOwnProperty(n)&&t.push({propName:e[n],templateName:n});return t}class $F{constructor(t,n){this.injector=t,this.parentInjector=n}get(t,n,i){const r=this.injector.get(t,km,i);return r!==km||n===km?r:this.parentInjector.get(t,n,i)}}class Vm extends Nb{constructor(t,n){super(),this.componentDef=t,this.ngModule=n,this.componentType=t.type,this.selector=function oL(e){return e.map(rL).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!n}get inputs(){return kb(this.componentDef.inputs)}get outputs(){return kb(this.componentDef.outputs)}create(t,n,i,r){let o=(r=r||this.ngModule)instanceof Gc?r:r?.injector;o&&null!==this.componentDef.getStandaloneInjector&&(o=this.componentDef.getStandaloneInjector(o)||o);const s=o?new $F(t,o):t,a=s.get(Ob,null);if(null===a)throw new Oe(407,!1);const c=s.get(zF,null),l=a.createRenderer(null,this.componentDef),d=this.componentDef.selectors[0][0]||"div",u=i?function tR(e,t,n){return e.selectRootElement(t,n===cr.ShadowDom)}(l,i,this.componentDef.encapsulation):function Lp(e,t,n){return e.createElement(t,n)}(a.createRenderer(null,this.componentDef),d,function qF(e){const t=e.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(d)),f=this.componentDef.onPush?288:272,h=function TR(e,t){return{components:[],scheduler:e||AI,clean:MR,playerHandler:t||null,flags:0}}(),p=hm(0,null,null,1,0,null,null,null,null,null),y=ad(null,p,h,f,null,null,a,l,c,s,null);let v,g;Jh(y);try{const m=function ER(e,t,n,i,r,o){const s=n[1];n[22]=e;const c=oa(s,22,2,"#host",null),l=c.mergedAttrs=t.hostAttrs;null!==l&&(function ud(e,t,n){let i=n?e.styles:null,r=n?e.classes:null,o=0;if(null!==t)for(let s=0;s<t.length;s++){const a=t[s];"number"==typeof a?o=a:1==o?r=Dh(r,a):2==o&&(i=Dh(i,a+": "+t[++s]+";"))}n?e.styles=i:e.stylesWithoutHost=i,n?e.classes=r:e.classesWithoutHost=r}(c,l,!0),null!==e&&(Nu(r,e,l),null!==c.classes&&Bp(r,e,c.classes),null!==c.styles&&function j_(e,t,n){e.setAttribute(t,"style",n)}(r,e,c.styles)));const d=i.createRenderer(e,t),u=ad(n,function Px(e){const t=e.tView;return null===t||t.incompleteFirstPass?e.tView=hm(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts):t}(t),null,t.onPush?32:16,n[22],c,i,d,o||null,null,null);return s.firstCreatePass&&(function Hu(e,t,n){!function iA(e,t,n){let i;"string"==typeof n?i=n.charCodeAt(0)||0:n.hasOwnProperty(vc)&&(i=n[vc]),null==i&&(i=n[vc]=nA++);const r=255&i;t.data[e+(r>>5)]|=1<<r}(e,t,n)}(function Tc(e,t){const n=ip(e,t);if(-1!==n)return n;const i=t[1];i.firstCreatePass&&(e.injectorIndex=t.length,np(i.data,e),np(t,null),np(i.blueprint,null));const r=ku(e,t),o=e.injectorIndex;if(function N0(e){return-1!==e}(r)){const s=js(r),a=Ws(r,t),c=a[1].data;for(let l=0;l<8;l++)t[o+l]=a[s+l]|c[s+l]}return t[o+8]=r,o}(c,n),s,t.type),function kx(e,t){t.flags|=2,(e.components||(e.components=[])).push(t.index)}(s,c),function Hx(e,t,n){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+n,e.providerIndexes=t}(c,n.length,1)),function ld(e,t){return e[13]?e[14][4]=t:e[13]=t,e[14]=t,t}(n,u),n[22]=u}(u,this.componentDef,y,a,l);if(u)if(i)Nu(l,u,["ng-version",jF.full]);else{const{attrs:_,classes:w}=function sL(e){const t=[],n=[];let i=1,r=2;for(;i<e.length;){let o=e[i];if("string"==typeof o)2===r?""!==o&&t.push(o,e[++i]):8===r&&n.push(o);else{if(!zi(r))break;r=o}i++}return{attrs:t,classes:n}}(this.componentDef.selectors[0]);_&&Nu(l,u,_),w&&w.length>0&&Bp(l,u,w.join(" "))}if(g=function zh(e,t){return e.data[t]}(p,22),void 0!==n){const _=g.projection=[];for(let w=0;w<this.ngContentSelectors.length;w++){const b=n[w];_.push(null!=b?Array.from(b):null)}}v=SR(m,this.componentDef,y,h,[DR]),cd(p,y,null)}finally{Qh()}return new YF(this.componentType,v,xa(g,y),y,g)}}class YF extends class HF{}{constructor(t,n,i,r,o){super(),this.location=i,this._rootLView=r,this._tNode=o,this.instance=n,this.hostView=this.changeDetectorRef=new WF(r),this.componentType=t}get injector(){return new qs(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}class Hb extends es{constructor(t,n){super(),this._parent=n,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new Hm(this);const i=function ui(e,t){const n=e[l0]||null;if(!n&&!0===t)throw new Error(`Type ${Pt(e)} does not have '\u0275mod' property.`);return n}(t);this._bootstrapComponents=function Hr(e){return e instanceof Function?e():e}(i.bootstrap),this._r3Injector=ux(t,n,[{provide:es,useValue:this},{provide:_d,useValue:this.componentFactoryResolver}],Pt(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this.get(t)}get(t,n=fr.THROW_IF_NOT_FOUND,i=Be.Default){return t===fr||t===es||t===Vp?this:this._r3Injector.get(t,n,i)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(n=>n()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class Um extends class kF{}{constructor(t){super(),this.moduleType=t}create(t){return new Hb(this.moduleType,t)}}function zm(e){return t=>{setTimeout(e,void 0,t)}}const Gr=class SN extends Ie{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,n,i){let r=t,o=n||(()=>null),s=i;if(t&&"object"==typeof t){const c=t;r=c.next?.bind(c),o=c.error?.bind(c),s=c.complete?.bind(c)}this.__isAsync&&(o=zm(o),r&&(r=zm(r)),s&&(s=zm(s)));const a=super.subscribe({next:r,error:o,complete:s});return t instanceof en&&t.add(a),a}};function Md(...e){}const EM=new pt("Application Initializer");let Ed=(()=>{class e{constructor(n){this.appInits=n,this.resolve=Md,this.reject=Md,this.initialized=!1,this.done=!1,this.donePromise=new Promise((i,r)=>{this.resolve=i,this.reject=r})}runInitializers(){if(this.initialized)return;const n=[],i=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let r=0;r<this.appInits.length;r++){const o=this.appInits[r]();if(Cm(o))n.push(o);else if($R(o)){const s=new Promise((a,c)=>{o.subscribe({complete:a,error:c})});n.push(s)}}Promise.all(n).then(()=>{i()}).catch(r=>{this.reject(r)}),0===n.length&&i(),this.initialized=!0}}return e.\u0275fac=function(n){return new(n||e)(bt(EM,8))},e.\u0275prov=Wt({token:e,factory:e.\u0275fac,providedIn:"root"}),e})();const nl=new pt("AppId",{providedIn:"root",factory:function SM(){return`${tg()}${tg()}${tg()}`}});function tg(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const TM=new pt("Platform Initializer"),DM=new pt("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),u2=new pt("appBootstrapListener"),jr=new pt("LocaleId",{providedIn:"root",factory:()=>function EA(e,t=Be.Default){return bt(e,t)}(jr,Be.Optional|Be.SkipSelf)||function d2(){return typeof $localize<"u"&&$localize.locale||va}()}),g2=(()=>Promise.resolve(0))();function ng(e){typeof Zone>"u"?g2.then(()=>{e&&e.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",e)}class Dn{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:n=!1,shouldCoalesceRunChangeDetection:i=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Gr(!1),this.onMicrotaskEmpty=new Gr(!1),this.onStable=new Gr(!1),this.onError=new Gr(!1),typeof Zone>"u")throw new Oe(908,!1);Zone.assertZonePatched();const r=this;r._nesting=0,r._outer=r._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(r._inner=r._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(r._inner=r._inner.fork(Zone.longStackTraceZoneSpec)),r.shouldCoalesceEventChangeDetection=!i&&n,r.shouldCoalesceRunChangeDetection=i,r.lastRequestAnimationFrameId=-1,r.nativeRequestAnimationFrame=function y2(){let e=Ct.requestAnimationFrame,t=Ct.cancelAnimationFrame;if(typeof Zone<"u"&&e&&t){const n=e[Zone.__symbol__("OriginalDelegate")];n&&(e=n);const i=t[Zone.__symbol__("OriginalDelegate")];i&&(t=i)}return{nativeRequestAnimationFrame:e,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function x2(e){const t=()=>{!function _2(e){e.isCheckStableRunning||-1!==e.lastRequestAnimationFrameId||(e.lastRequestAnimationFrameId=e.nativeRequestAnimationFrame.call(Ct,()=>{e.fakeTopEventTask||(e.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{e.lastRequestAnimationFrameId=-1,rg(e),e.isCheckStableRunning=!0,ig(e),e.isCheckStableRunning=!1},void 0,()=>{},()=>{})),e.fakeTopEventTask.invoke()}),rg(e))}(e)};e._inner=e._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,i,r,o,s,a)=>{try{return IM(e),n.invokeTask(r,o,s,a)}finally{(e.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||e.shouldCoalesceRunChangeDetection)&&t(),LM(e)}},onInvoke:(n,i,r,o,s,a,c)=>{try{return IM(e),n.invoke(r,o,s,a,c)}finally{e.shouldCoalesceRunChangeDetection&&t(),LM(e)}},onHasTask:(n,i,r,o)=>{n.hasTask(r,o),i===r&&("microTask"==o.change?(e._hasPendingMicrotasks=o.microTask,rg(e),ig(e)):"macroTask"==o.change&&(e.hasPendingMacrotasks=o.macroTask))},onHandleError:(n,i,r,o)=>(n.handleError(r,o),e.runOutsideAngular(()=>e.onError.emit(o)),!1)})}(r)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Dn.isInAngularZone())throw new Oe(909,!1)}static assertNotInAngularZone(){if(Dn.isInAngularZone())throw new Oe(909,!1)}run(t,n,i){return this._inner.run(t,n,i)}runTask(t,n,i,r){const o=this._inner,s=o.scheduleEventTask("NgZoneEvent: "+r,t,v2,Md,Md);try{return o.runTask(s,n,i)}finally{o.cancelTask(s)}}runGuarded(t,n,i){return this._inner.runGuarded(t,n,i)}runOutsideAngular(t){return this._outer.run(t)}}const v2={};function ig(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function rg(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&-1!==e.lastRequestAnimationFrameId)}function IM(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function LM(e){e._nesting--,ig(e)}class w2{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Gr,this.onMicrotaskEmpty=new Gr,this.onStable=new Gr,this.onError=new Gr}run(t,n,i){return t.apply(n,i)}runGuarded(t,n,i){return t.apply(n,i)}runOutsideAngular(t){return t()}runTask(t,n,i,r){return t.apply(n,i)}}const RM=new pt(""),Sd=new pt("");let ag,og=(()=>{class e{constructor(n,i,r){this._ngZone=n,this.registry=i,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,ag||(function b2(e){ag=e}(r),r.addToWindow(i)),this._watchAngularEvents(),n.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Dn.assertNotInAngularZone(),ng(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())ng(()=>{for(;0!==this._callbacks.length;){let n=this._callbacks.pop();clearTimeout(n.timeoutId),n.doneCb(this._didWork)}this._didWork=!1});else{let n=this.getPendingTasks();this._callbacks=this._callbacks.filter(i=>!i.updateCb||!i.updateCb(n)||(clearTimeout(i.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(n=>({source:n.source,creationLocation:n.creationLocation,data:n.data})):[]}addCallback(n,i,r){let o=-1;i&&i>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(s=>s.timeoutId!==o),n(this._didWork,this.getPendingTasks())},i)),this._callbacks.push({doneCb:n,timeoutId:o,updateCb:r})}whenStable(n,i,r){if(r&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(n,i,r),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(n){this.registry.registerApplication(n,this)}unregisterApplication(n){this.registry.unregisterApplication(n)}findProviders(n,i,r){return[]}}return e.\u0275fac=function(n){return new(n||e)(bt(Dn),bt(sg),bt(Sd))},e.\u0275prov=Wt({token:e,factory:e.\u0275fac}),e})(),sg=(()=>{class e{constructor(){this._applications=new Map}registerApplication(n,i){this._applications.set(n,i)}unregisterApplication(n){this._applications.delete(n)}unregisterAllApplications(){this._applications.clear()}getTestability(n){return this._applications.get(n)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(n,i=!0){return ag?.findTestabilityInTree(this,n,i)??null}}return e.\u0275fac=function(n){return new(n||e)},e.\u0275prov=Wt({token:e,factory:e.\u0275fac,providedIn:"platform"}),e})(),_o=null;const PM=new pt("AllowMultipleToken"),cg=new pt("PlatformDestroyListeners");function NM(e,t,n=[]){const i=`Platform: ${t}`,r=new pt(i);return(o=[])=>{let s=lg();if(!s||s.injector.get(PM,!1)){const a=[...n,...o,{provide:r,useValue:!0}];e?e(a):function S2(e){if(_o&&!_o.get(PM,!1))throw new Oe(400,!1);_o=e;const t=e.get(BM);(function FM(e){const t=e.get(TM,null);t&&t.forEach(n=>n())})(e)}(function OM(e=[],t){return fr.create({name:t,providers:[{provide:Up,useValue:"platform"},{provide:cg,useValue:new Set([()=>_o=null])},...e]})}(a,i))}return function D2(e){const t=lg();if(!t)throw new Oe(401,!1);return t}()}}function lg(){return _o?.get(BM)??null}let BM=(()=>{class e{constructor(n){this._injector=n,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(n,i){const r=function C2(e,t){let n;return n="noop"===e?new w2:("zone.js"===e?void 0:e)||new Dn(t),n}(i?.ngZone,function kM(e){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!e||!e.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!e||!e.ngZoneRunCoalescing)||!1}}(i)),o=[{provide:Dn,useValue:r}];return r.run(()=>{const s=fr.create({providers:o,parent:this.injector,name:n.moduleType.name}),a=n.create(s),c=a.injector.get(ea,null);if(!c)throw new Oe(402,!1);return r.runOutsideAngular(()=>{const l=r.onError.subscribe({next:d=>{c.handleError(d)}});a.onDestroy(()=>{Td(this._modules,a),l.unsubscribe()})}),function HM(e,t,n){try{const i=n();return Cm(i)?i.catch(r=>{throw t.runOutsideAngular(()=>e.handleError(r)),r}):i}catch(i){throw t.runOutsideAngular(()=>e.handleError(i)),i}}(c,r,()=>{const l=a.injector.get(Ed);return l.runInitializers(),l.donePromise.then(()=>(function lb(e){li(e,"Expected localeId to be defined"),"string"==typeof e&&(cb=e.toLowerCase().replace(/_/g,"-"))}(a.injector.get(jr,va)||va),this._moduleDoBootstrap(a),a))})})}bootstrapModule(n,i=[]){const r=VM({},i);return function M2(e,t,n){const i=new Um(n);return Promise.resolve(i)}(0,0,n).then(o=>this.bootstrapModuleFactory(o,r))}_moduleDoBootstrap(n){const i=n.injector.get(ug);if(n._bootstrapComponents.length>0)n._bootstrapComponents.forEach(r=>i.bootstrap(r));else{if(!n.instance.ngDoBootstrap)throw new Oe(403,!1);n.instance.ngDoBootstrap(i)}this._modules.push(n)}onDestroy(n){this._destroyListeners.push(n)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Oe(404,!1);this._modules.slice().forEach(i=>i.destroy()),this._destroyListeners.forEach(i=>i());const n=this._injector.get(cg,null);n&&(n.forEach(i=>i()),n.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return e.\u0275fac=function(n){return new(n||e)(bt(fr))},e.\u0275prov=Wt({token:e,factory:e.\u0275fac,providedIn:"platform"}),e})();function VM(e,t){return Array.isArray(t)?t.reduce(VM,e):{...e,...t}}let ug=(()=>{class e{constructor(n,i,r){this._zone=n,this._injector=i,this._exceptionHandler=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new fe(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),s=new fe(a=>{let c;this._zone.runOutsideAngular(()=>{c=this._zone.onStable.subscribe(()=>{Dn.assertNotInAngularZone(),ng(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const l=this._zone.onUnstable.subscribe(()=>{Dn.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{c.unsubscribe(),l.unsubscribe()}});this.isStable=J1(o,s.pipe(function K1(e={}){const{connector:t=(()=>new Ie),resetOnError:n=!0,resetOnComplete:i=!0,resetOnRefCountZero:r=!0}=e;return o=>{let s=null,a=null,c=null,l=0,d=!1,u=!1;const f=()=>{a?.unsubscribe(),a=null},h=()=>{f(),s=c=null,d=u=!1},p=()=>{const y=s;h(),y?.unsubscribe()};return De((y,v)=>{l++,!u&&!d&&f();const g=c=c??t();v.add(()=>{l--,0===l&&!u&&!d&&(a=Sh(p,r))}),g.subscribe(v),s||(s=new Ps({next:m=>g.next(m),error:m=>{u=!0,f(),a=Sh(h,n,m),g.error(m)},complete:()=>{d=!0,f(),a=Sh(h,i),g.complete()}}),r0(y).subscribe(s))})(o)}}()))}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(n,i){const r=n instanceof Nb;if(!this._injector.get(Ed).done)throw!r&&function tl(e){const t=Ft(e)||Un(e)||Gn(e);return null!==t&&t.standalone}(n),new Oe(405,false);let s;s=r?n:this._injector.get(_d).resolveComponentFactory(n),this.componentTypes.push(s.componentType);const a=function E2(e){return e.isBoundToModule}(s)?void 0:this._injector.get(es),l=s.create(fr.NULL,[],i||s.selector,a),d=l.location.nativeElement,u=l.injector.get(RM,null);return u?.registerApplication(d),l.onDestroy(()=>{this.detachView(l.hostView),Td(this.components,l),u?.unregisterApplication(d)}),this._loadComponent(l),l}tick(){if(this._runningTick)throw new Oe(101,!1);try{this._runningTick=!0;for(let n of this._views)n.detectChanges()}catch(n){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(n))}finally{this._runningTick=!1}}attachView(n){const i=n;this._views.push(i),i.attachToAppRef(this)}detachView(n){const i=n;Td(this._views,i),i.detachFromAppRef()}_loadComponent(n){this.attachView(n.hostView),this.tick(),this.components.push(n),this._injector.get(u2,[]).concat(this._bootstrapListeners).forEach(r=>r(n))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(n=>n()),this._views.slice().forEach(n=>n.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(n){return this._destroyListeners.push(n),()=>Td(this._destroyListeners,n)}destroy(){if(this._destroyed)throw new Oe(406,!1);const n=this._injector;n.destroy&&!n.destroyed&&n.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return e.\u0275fac=function(n){return new(n||e)(bt(Dn),bt(fr),bt(ea))},e.\u0275prov=Wt({token:e,factory:e.\u0275fac,providedIn:"root"}),e})();function Td(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}let GM=!0;const q2=NM(null,"core",[]);let $2=(()=>{class e{constructor(n){}}return e.\u0275fac=function(n){return new(n||e)(bt(ug))},e.\u0275mod=_c({type:e}),e.\u0275inj=Os({}),e})(),Id=null;function rl(){return Id}const vr=new pt("DocumentToken");let y3=(()=>{class e{}return e.\u0275fac=function(n){return new(n||e)},e.\u0275mod=_c({type:e}),e.\u0275inj=Os({}),e})();class Cg extends class M3 extends class Z2{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){!function Y2(e){Id||(Id=e)}(new Cg)}onAndCancel(t,n,i){return t.addEventListener(n,i,!1),()=>{t.removeEventListener(n,i,!1)}}dispatchEvent(t,n){t.dispatchEvent(n)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,n){return(n=n||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,n){return"window"===n?window:"document"===n?t:"body"===n?t.body:null}getBaseHref(t){const n=function E3(){return al=al||document.querySelector("base"),al?al.getAttribute("href"):null}();return null==n?null:function S3(e){Vd=Vd||document.createElement("a"),Vd.setAttribute("href",e);const t=Vd.pathname;return"/"===t.charAt(0)?t:`/${t}`}(n)}resetBaseElement(){al=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function BO(e,t){t=encodeURIComponent(t);for(const n of e.split(";")){const i=n.indexOf("="),[r,o]=-1==i?[n,""]:[n.slice(0,i),n.slice(i+1)];if(r.trim()===t)return decodeURIComponent(o)}return null}(document.cookie,t)}}let Vd,al=null;const gE=new pt("TRANSITION_ID"),D3=[{provide:EM,useFactory:function T3(e,t,n){return()=>{n.get(Ed).donePromise.then(()=>{const i=rl(),r=t.querySelectorAll(`style[ng-transition="${e}"]`);for(let o=0;o<r.length;o++)i.remove(r[o])})}},deps:[gE,vr,fr],multi:!0}];let A3=(()=>{class e{build(){return new XMLHttpRequest}}return e.\u0275fac=function(n){return new(n||e)},e.\u0275prov=Wt({token:e,factory:e.\u0275fac}),e})();const Ud=new pt("EventManagerPlugins");let Gd=(()=>{class e{constructor(n,i){this._zone=i,this._eventNameToPlugin=new Map,n.forEach(r=>r.manager=this),this._plugins=n.slice().reverse()}addEventListener(n,i,r){return this._findPluginFor(i).addEventListener(n,i,r)}addGlobalEventListener(n,i,r){return this._findPluginFor(i).addGlobalEventListener(n,i,r)}getZone(){return this._zone}_findPluginFor(n){const i=this._eventNameToPlugin.get(n);if(i)return i;const r=this._plugins;for(let o=0;o<r.length;o++){const s=r[o];if(s.supports(n))return this._eventNameToPlugin.set(n,s),s}throw new Error(`No event manager plugin found for event ${n}`)}}return e.\u0275fac=function(n){return new(n||e)(bt(Ud),bt(Dn))},e.\u0275prov=Wt({token:e,factory:e.\u0275fac}),e})();class yE{constructor(t){this._doc=t}addGlobalEventListener(t,n,i){const r=rl().getGlobalEventTarget(this._doc,t);if(!r)throw new Error(`Unsupported event target ${r} for event ${n}`);return this.addEventListener(r,n,i)}}let vE=(()=>{class e{constructor(){this._stylesSet=new Set}addStyles(n){const i=new Set;n.forEach(r=>{this._stylesSet.has(r)||(this._stylesSet.add(r),i.add(r))}),this.onStylesAdded(i)}onStylesAdded(n){}getAllStyles(){return Array.from(this._stylesSet)}}return e.\u0275fac=function(n){return new(n||e)},e.\u0275prov=Wt({token:e,factory:e.\u0275fac}),e})(),cl=(()=>{class e extends vE{constructor(n){super(),this._doc=n,this._hostNodes=new Map,this._hostNodes.set(n.head,[])}_addStylesToHost(n,i,r){n.forEach(o=>{const s=this._doc.createElement("style");s.textContent=o,r.push(i.appendChild(s))})}addHost(n){const i=[];this._addStylesToHost(this._stylesSet,n,i),this._hostNodes.set(n,i)}removeHost(n){const i=this._hostNodes.get(n);i&&i.forEach(_E),this._hostNodes.delete(n)}onStylesAdded(n){this._hostNodes.forEach((i,r)=>{this._addStylesToHost(n,r,i)})}ngOnDestroy(){this._hostNodes.forEach(n=>n.forEach(_E))}}return e.\u0275fac=function(n){return new(n||e)(bt(vr))},e.\u0275prov=Wt({token:e,factory:e.\u0275fac}),e})();function _E(e){rl().remove(e)}const Ag={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},Ig=/%COMP%/g;function zd(e,t,n){for(let i=0;i<t.length;i++){let r=t[i];Array.isArray(r)?zd(e,r,n):(r=r.replace(Ig,e),n.push(r))}return n}function bE(e){return t=>{if("__ngUnwrap__"===t)return e;!1===e(t)&&(t.preventDefault(),t.returnValue=!1)}}let Lg=(()=>{class e{constructor(n,i,r){this.eventManager=n,this.sharedStylesHost=i,this.appId=r,this.rendererByCompId=new Map,this.defaultRenderer=new Rg(n)}createRenderer(n,i){if(!n||!i)return this.defaultRenderer;switch(i.encapsulation){case cr.Emulated:{let r=this.rendererByCompId.get(i.id);return r||(r=new N3(this.eventManager,this.sharedStylesHost,i,this.appId),this.rendererByCompId.set(i.id,r)),r.applyToHost(n),r}case 1:case cr.ShadowDom:return new O3(this.eventManager,this.sharedStylesHost,n,i);default:if(!this.rendererByCompId.has(i.id)){const r=zd(i.id,i.styles,[]);this.sharedStylesHost.addStyles(r),this.rendererByCompId.set(i.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return e.\u0275fac=function(n){return new(n||e)(bt(Gd),bt(cl),bt(nl))},e.\u0275prov=Wt({token:e,factory:e.\u0275fac}),e})();class Rg{constructor(t){this.eventManager=t,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,n){return n?document.createElementNS(Ag[n]||n,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,n){(EE(t)?t.content:t).appendChild(n)}insertBefore(t,n,i){t&&(EE(t)?t.content:t).insertBefore(n,i)}removeChild(t,n){t&&t.removeChild(n)}selectRootElement(t,n){let i="string"==typeof t?document.querySelector(t):t;if(!i)throw new Error(`The selector "${t}" did not match any elements`);return n||(i.textContent=""),i}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,n,i,r){if(r){n=r+":"+n;const o=Ag[r];o?t.setAttributeNS(o,n,i):t.setAttribute(n,i)}else t.setAttribute(n,i)}removeAttribute(t,n,i){if(i){const r=Ag[i];r?t.removeAttributeNS(r,n):t.removeAttribute(`${i}:${n}`)}else t.removeAttribute(n)}addClass(t,n){t.classList.add(n)}removeClass(t,n){t.classList.remove(n)}setStyle(t,n,i,r){r&(ni.DashCase|ni.Important)?t.style.setProperty(n,i,r&ni.Important?"important":""):t.style[n]=i}removeStyle(t,n,i){i&ni.DashCase?t.style.removeProperty(n):t.style[n]=""}setProperty(t,n,i){t[n]=i}setValue(t,n){t.nodeValue=n}listen(t,n,i){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,n,bE(i)):this.eventManager.addEventListener(t,n,bE(i))}}function EE(e){return"TEMPLATE"===e.tagName&&void 0!==e.content}class N3 extends Rg{constructor(t,n,i,r){super(t),this.component=i;const o=zd(r+"-"+i.id,i.styles,[]);n.addStyles(o),this.contentAttr=function R3(e){return"_ngcontent-%COMP%".replace(Ig,e)}(r+"-"+i.id),this.hostAttr=function P3(e){return"_nghost-%COMP%".replace(Ig,e)}(r+"-"+i.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,n){const i=super.createElement(t,n);return super.setAttribute(i,this.contentAttr,""),i}}class O3 extends Rg{constructor(t,n,i,r){super(t),this.sharedStylesHost=n,this.hostEl=i,this.shadowRoot=i.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const o=zd(r.id,r.styles,[]);for(let s=0;s<o.length;s++){const a=document.createElement("style");a.textContent=o[s],this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,n){return super.appendChild(this.nodeOrShadowRoot(t),n)}insertBefore(t,n,i){return super.insertBefore(this.nodeOrShadowRoot(t),n,i)}removeChild(t,n){return super.removeChild(this.nodeOrShadowRoot(t),n)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let B3=(()=>{class e extends yE{constructor(n){super(n)}supports(n){return!0}addEventListener(n,i,r){return n.addEventListener(i,r,!1),()=>this.removeEventListener(n,i,r)}removeEventListener(n,i,r){return n.removeEventListener(i,r)}}return e.\u0275fac=function(n){return new(n||e)(bt(vr))},e.\u0275prov=Wt({token:e,factory:e.\u0275fac}),e})();const SE=["alt","control","meta","shift"],H3={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},TE={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},V3={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};let U3=(()=>{class e extends yE{constructor(n){super(n)}supports(n){return null!=e.parseEventName(n)}addEventListener(n,i,r){const o=e.parseEventName(i),s=e.eventCallback(o.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>rl().onAndCancel(n,o.domEventName,s))}static parseEventName(n){const i=n.toLowerCase().split("."),r=i.shift();if(0===i.length||"keydown"!==r&&"keyup"!==r)return null;const o=e._normalizeKey(i.pop());let s="";if(SE.forEach(c=>{const l=i.indexOf(c);l>-1&&(i.splice(l,1),s+=c+".")}),s+=o,0!=i.length||0===o.length)return null;const a={};return a.domEventName=r,a.fullKey=s,a}static getEventFullKey(n){let i="",r=function G3(e){let t=e.key;if(null==t){if(t=e.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===e.location&&TE.hasOwnProperty(t)&&(t=TE[t]))}return H3[t]||t}(n);return r=r.toLowerCase()," "===r?r="space":"."===r&&(r="dot"),SE.forEach(o=>{o!=r&&V3[o](n)&&(i+=o+".")}),i+=r,i}static eventCallback(n,i,r){return o=>{e.getEventFullKey(o)===n&&r.runGuarded(()=>i(o))}}static _normalizeKey(n){return"esc"===n?"escape":n}}return e.\u0275fac=function(n){return new(n||e)(bt(vr))},e.\u0275prov=Wt({token:e,factory:e.\u0275fac}),e})();const q3=NM(q2,"browser",[{provide:DM,useValue:"browser"},{provide:TM,useValue:function z3(){Cg.makeCurrent()},multi:!0},{provide:vr,useFactory:function W3(){return function BA(e){hp=e}(document),document},deps:[]}]),CE=new pt(""),AE=[{provide:Sd,useClass:class C3{addToWindow(t){Ct.getAngularTestability=(i,r=!0)=>{const o=t.findTestabilityInTree(i,r);if(null==o)throw new Error("Could not find testability for element.");return o},Ct.getAllAngularTestabilities=()=>t.getAllTestabilities(),Ct.getAllAngularRootElements=()=>t.getAllRootElements(),Ct.frameworkStabilizers||(Ct.frameworkStabilizers=[]),Ct.frameworkStabilizers.push(i=>{const r=Ct.getAllAngularTestabilities();let o=r.length,s=!1;const a=function(c){s=s||c,o--,0==o&&i(s)};r.forEach(function(c){c.whenStable(a)})})}findTestabilityInTree(t,n,i){return null==n?null:t.getTestability(n)??(i?rl().isShadowRoot(n)?this.findTestabilityInTree(t,n.host,!0):this.findTestabilityInTree(t,n.parentElement,!0):null)}},deps:[]},{provide:RM,useClass:og,deps:[Dn,sg,Sd]},{provide:og,useClass:og,deps:[Dn,sg,Sd]}],IE=[{provide:Up,useValue:"root"},{provide:ea,useFactory:function j3(){return new ea},deps:[]},{provide:Ud,useClass:B3,multi:!0,deps:[vr,Dn,DM]},{provide:Ud,useClass:U3,multi:!0,deps:[vr]},{provide:Lg,useClass:Lg,deps:[Gd,cl,nl]},{provide:Ob,useExisting:Lg},{provide:vE,useExisting:cl},{provide:cl,useClass:cl,deps:[vr]},{provide:Gd,useClass:Gd,deps:[Ud,Dn]},{provide:class b3{},useClass:A3,deps:[]},[]];let $3=(()=>{class e{constructor(n){}static withServerTransition(n){return{ngModule:e,providers:[{provide:nl,useValue:n.appId},{provide:gE,useExisting:nl},D3]}}}return e.\u0275fac=function(n){return new(n||e)(bt(CE,12))},e.\u0275mod=_c({type:e}),e.\u0275inj=Os({providers:[...IE,...AE],imports:[y3,$2]}),e})();typeof window<"u"&&window;const PE="124",rB={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},oB={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},FE=0,Ng=1,NE=2,sB=3,aB=0,Og=1,OE=2,Ma=3,Ea=0,wn=1,ll=2,Bg=1,cB=2,$r=0,Sa=1,kg=2,Hg=3,Vg=4,BE=5,is=100,kE=101,HE=102,Ug=103,Gg=104,VE=200,UE=201,GE=202,zE=203,zg=204,jg=205,jE=206,WE=207,qE=208,$E=209,XE=210,YE=0,ZE=1,JE=2,jd=3,QE=4,KE=5,eS=6,tS=7,ul=0,nS=1,iS=2,rs=0,rS=1,oS=2,sS=3,aS=4,cS=5,Wd=300,dl=301,fl=302,qd=303,$d=304,Ta=306,hl=307,pl=1e3,Xn=1001,ml=1002,bn=1003,Xd=1004,lB=1004,Yd=1005,uB=1005,En=1006,Wg=1007,dB=1007,Da=1008,fB=1008,Ca=1009,lS=1010,uS=1011,gl=1012,dS=1013,yl=1014,Xr=1015,vl=1016,fS=1017,hS=1018,pS=1019,Aa=1020,mS=1021,wo=1022,gi=1023,gS=1024,yS=1025,vS=gi,os=1026,Ia=1027,_S=1028,xS=1029,wS=1030,bS=1031,MS=1032,ES=1033,qg=33776,$g=33777,Xg=33778,Yg=33779,Zg=35840,Jg=35841,Qg=35842,Kg=35843,SS=36196,ey=37492,ty=37496,TS=37808,DS=37809,CS=37810,AS=37811,IS=37812,LS=37813,RS=37814,PS=37815,FS=37816,NS=37817,OS=37818,BS=37819,kS=37820,HS=37821,VS=36492,US=37840,GS=37841,zS=37842,jS=37843,WS=37844,qS=37845,$S=37846,XS=37847,YS=37848,ZS=37849,JS=37850,QS=37851,KS=37852,eT=37853,tT=2200,nT=2201,iT=2202,_l=2300,xl=2301,Zd=2302,ss=2400,as=2401,wl=2402,Jd=2500,ny=2501,rT=0,hB=1,pB=2,Yn=3e3,bl=3001,Qd=3007,Kd=3002,oT=3003,iy=3004,ry=3005,oy=3006,sT=3200,aT=3201,cs=0,cT=1,mB=0,ef=7680,gB=7681,yB=7682,vB=7683,_B=34055,xB=34056,wB=5386,bB=512,MB=513,EB=514,SB=515,TB=516,DB=517,CB=518,lT=519,Ml=35044,ls=35048,AB=35040,IB=35045,LB=35049,RB=35041,PB=35046,FB=35050,NB=35042,OB="100",sy="300 es";function _r(){}Object.assign(_r.prototype,{addEventListener:function(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(t)&&n[e].push(t)},hasEventListener:function(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(t)},removeEventListener:function(e,t){if(void 0===this._listeners)return;const i=this._listeners[e];if(void 0!==i){const r=i.indexOf(t);-1!==r&&i.splice(r,1)}},dispatchEvent:function(e){if(void 0===this._listeners)return;const n=this._listeners[e.type];if(void 0!==n){e.target=this;const i=n.slice(0);for(let r=0,o=i.length;r<o;r++)i[r].call(this,e)}}});const Cn=[];for(let e=0;e<256;e++)Cn[e]=(e<16?"0":"")+e.toString(16);let tf=1234567;const ke={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(Cn[255&e]+Cn[e>>8&255]+Cn[e>>16&255]+Cn[e>>24&255]+"-"+Cn[255&t]+Cn[t>>8&255]+"-"+Cn[t>>16&15|64]+Cn[t>>24&255]+"-"+Cn[63&n|128]+Cn[n>>8&255]+"-"+Cn[n>>16&255]+Cn[n>>24&255]+Cn[255&i]+Cn[i>>8&255]+Cn[i>>16&255]+Cn[i>>24&255]).toUpperCase()},clamp:function(e,t,n){return Math.max(t,Math.min(n,e))},euclideanModulo:function(e,t){return(e%t+t)%t},mapLinear:function(e,t,n,i,r){return i+(e-t)*(r-i)/(n-t)},lerp:function(e,t,n){return(1-n)*e+n*t},smoothstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*(3-2*e)},smootherstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*e*(e*(6*e-15)+10)},randInt:function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function(e,t){return e+Math.random()*(t-e)},randFloatSpread:function(e){return e*(.5-Math.random())},seededRandom:function(e){return void 0!==e&&(tf=e%2147483647),tf=16807*tf%2147483647,(tf-1)/2147483646},degToRad:function(e){return e*ke.DEG2RAD},radToDeg:function(e){return e*ke.RAD2DEG},isPowerOfTwo:function(e){return 0==(e&e-1)&&0!==e},ceilPowerOfTwo:function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},floorPowerOfTwo:function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))},setQuaternionFromProperEuler:function(e,t,n,i,r){const o=Math.cos,s=Math.sin,a=o(n/2),c=s(n/2),l=o((t+i)/2),d=s((t+i)/2),u=o((t-i)/2),f=s((t-i)/2),h=o((i-t)/2),p=s((i-t)/2);switch(r){case"XYX":e.set(a*d,c*u,c*f,a*l);break;case"YZY":e.set(c*f,a*d,c*u,a*l);break;case"ZXZ":e.set(c*u,c*f,a*d,a*l);break;case"XZX":e.set(a*d,c*p,c*h,a*l);break;case"YXY":e.set(c*h,a*d,c*p,a*l);break;case"ZYZ":e.set(c*p,c*h,a*d,a*l);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}};class V{constructor(t=0,n=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=t,this.y=n}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,n){return this.x=t,this.y=n,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,n){switch(t){case 0:this.x=n;break;case 1:this.y=n;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,n){return void 0!==n?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,n)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this}addScaledVector(t,n){return this.x+=t.x*n,this.y+=t.y*n,this}sub(t,n){return void 0!==n?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,n)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const n=this.x,i=this.y,r=t.elements;return this.x=r[0]*n+r[3]*i+r[6],this.y=r[1]*n+r[4]*i+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this}clampScalar(t,n){return this.x=Math.max(t,Math.min(n,this.x)),this.y=Math.max(t,Math.min(n,this.y)),this}clampLength(t,n){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(n,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const n=this.x-t.x,i=this.y-t.y;return n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this}lerpVectors(t,n,i){return this.x=t.x+(n.x-t.x)*i,this.y=t.y+(n.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,n=0){return this.x=t[n],this.y=t[n+1],this}toArray(t=[],n=0){return t[n]=this.x,t[n+1]=this.y,t}fromBufferAttribute(t,n,i){return void 0!==i&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(n),this.y=t.getY(n),this}rotateAround(t,n){const i=Math.cos(n),r=Math.sin(n),o=this.x-t.x,s=this.y-t.y;return this.x=o*i-s*r+t.x,this.y=o*r+s*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class Zn{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,n,i,r,o,s,a,c,l){const d=this.elements;return d[0]=t,d[1]=r,d[2]=a,d[3]=n,d[4]=o,d[5]=c,d[6]=i,d[7]=s,d[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return(new this.constructor).fromArray(this.elements)}copy(t){const n=this.elements,i=t.elements;return n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=i[3],n[4]=i[4],n[5]=i[5],n[6]=i[6],n[7]=i[7],n[8]=i[8],this}extractBasis(t,n,i){return t.setFromMatrix3Column(this,0),n.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const n=t.elements;return this.set(n[0],n[4],n[8],n[1],n[5],n[9],n[2],n[6],n[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,n){const i=t.elements,r=n.elements,o=this.elements,s=i[0],a=i[3],c=i[6],l=i[1],d=i[4],u=i[7],f=i[2],h=i[5],p=i[8],y=r[0],v=r[3],g=r[6],m=r[1],_=r[4],w=r[7],b=r[2],x=r[5],D=r[8];return o[0]=s*y+a*m+c*b,o[3]=s*v+a*_+c*x,o[6]=s*g+a*w+c*D,o[1]=l*y+d*m+u*b,o[4]=l*v+d*_+u*x,o[7]=l*g+d*w+u*D,o[2]=f*y+h*m+p*b,o[5]=f*v+h*_+p*x,o[8]=f*g+h*w+p*D,this}multiplyScalar(t){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=t,n[4]*=t,n[7]*=t,n[2]*=t,n[5]*=t,n[8]*=t,this}determinant(){const t=this.elements,n=t[0],i=t[1],r=t[2],o=t[3],s=t[4],a=t[5],c=t[6],l=t[7],d=t[8];return n*s*d-n*a*l-i*o*d+i*a*c+r*o*l-r*s*c}invert(){const t=this.elements,n=t[0],i=t[1],r=t[2],o=t[3],s=t[4],a=t[5],c=t[6],l=t[7],d=t[8],u=d*s-a*l,f=a*c-d*o,h=l*o-s*c,p=n*u+i*f+r*h;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const y=1/p;return t[0]=u*y,t[1]=(r*l-d*i)*y,t[2]=(a*i-r*s)*y,t[3]=f*y,t[4]=(d*n-r*c)*y,t[5]=(r*o-a*n)*y,t[6]=h*y,t[7]=(i*c-l*n)*y,t[8]=(s*n-i*o)*y,this}transpose(){let t;const n=this.elements;return t=n[1],n[1]=n[3],n[3]=t,t=n[2],n[2]=n[6],n[6]=t,t=n[5],n[5]=n[7],n[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).copy(this).invert().transpose()}transposeIntoArray(t){const n=this.elements;return t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8],this}setUvTransform(t,n,i,r,o,s,a){const c=Math.cos(o),l=Math.sin(o);return this.set(i*c,i*l,-i*(c*s+l*a)+s+t,-r*l,r*c,-r*(-l*s+c*a)+a+n,0,0,1),this}scale(t,n){const i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=n,i[4]*=n,i[7]*=n,this}rotate(t){const n=Math.cos(t),i=Math.sin(t),r=this.elements,o=r[0],s=r[3],a=r[6],c=r[1],l=r[4],d=r[7];return r[0]=n*o+i*c,r[3]=n*s+i*l,r[6]=n*a+i*d,r[1]=-i*o+n*c,r[4]=-i*s+n*l,r[7]=-i*a+n*d,this}translate(t,n){const i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=n*i[2],i[4]+=n*i[5],i[7]+=n*i[8],this}equals(t){const n=this.elements,i=t.elements;for(let r=0;r<9;r++)if(n[r]!==i[r])return!1;return!0}fromArray(t,n=0){for(let i=0;i<9;i++)this.elements[i]=t[i+n];return this}toArray(t=[],n=0){const i=this.elements;return t[n]=i[0],t[n+1]=i[1],t[n+2]=i[2],t[n+3]=i[3],t[n+4]=i[4],t[n+5]=i[5],t[n+6]=i[6],t[n+7]=i[7],t[n+8]=i[8],t}}let La;const us={getDataURL:function(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===La&&(La=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),La.width=e.width,La.height=e.height;const n=La.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=La}return t.width>2048||t.height>2048?t.toDataURL("image/jpeg",.6):t.toDataURL("image/png")}};let BB=0;function At(e=At.DEFAULT_IMAGE,t=At.DEFAULT_MAPPING,n=Xn,i=Xn,r=En,o=Da,s=gi,a=Ca,c=1,l=Yn){Object.defineProperty(this,"id",{value:BB++}),this.uuid=ke.generateUUID(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=o,this.anisotropy=c,this.format=s,this.internalFormat=null,this.type=a,this.offset=new V(0,0),this.repeat=new V(1,1),this.center=new V(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Zn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=l,this.version=0,this.onUpdate=null}function ay(e){return typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap?us.getDataURL(e):e.data?{data:Array.prototype.slice.call(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}At.DEFAULT_IMAGE=void 0,At.DEFAULT_MAPPING=Wd,At.prototype=Object.assign(Object.create(_r.prototype),{constructor:At,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this},toJSON:function(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const i=this.image;if(void 0===i.uuid&&(i.uuid=ke.generateUUID()),!t&&void 0===e.images[i.uuid]){let r;if(Array.isArray(i)){r=[];for(let o=0,s=i.length;o<s;o++)r.push(ay(i[o].isDataTexture?i[o].image:i[o]))}else r=ay(i);e.images[i.uuid]={uuid:i.uuid,url:r}}n.image=i.uuid}return t||(e.textures[this.uuid]=n),n},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(e){if(this.mapping!==Wd)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case pl:e.x=e.x-Math.floor(e.x);break;case Xn:e.x=e.x<0?0:1;break;case ml:e.x=1===Math.abs(Math.floor(e.x)%2)?Math.ceil(e.x)-e.x:e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case pl:e.y=e.y-Math.floor(e.y);break;case Xn:e.y=e.y<0?0:1;break;case ml:e.y=1===Math.abs(Math.floor(e.y)%2)?Math.ceil(e.y)-e.y:e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}}),Object.defineProperty(At.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}});class It{constructor(t=0,n=0,i=0,r=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=t,this.y=n,this.z=i,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,n,i,r){return this.x=t,this.y=n,this.z=i,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,n){switch(t){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;case 3:this.w=n;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,n){return void 0!==n?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,n)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this.z=t.z+n.z,this.w=t.w+n.w,this}addScaledVector(t,n){return this.x+=t.x*n,this.y+=t.y*n,this.z+=t.z*n,this.w+=t.w*n,this}sub(t,n){return void 0!==n?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,n)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this.z=t.z-n.z,this.w=t.w-n.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const n=this.x,i=this.y,r=this.z,o=this.w,s=t.elements;return this.x=s[0]*n+s[4]*i+s[8]*r+s[12]*o,this.y=s[1]*n+s[5]*i+s[9]*r+s[13]*o,this.z=s[2]*n+s[6]*i+s[10]*r+s[14]*o,this.w=s[3]*n+s[7]*i+s[11]*r+s[15]*o,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const n=Math.sqrt(1-t.w*t.w);return n<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/n,this.y=t.y/n,this.z=t.z/n),this}setAxisAngleFromRotationMatrix(t){let n,i,r,o;const c=t.elements,l=c[0],d=c[4],u=c[8],f=c[1],h=c[5],p=c[9],y=c[2],v=c[6],g=c[10];if(Math.abs(d-f)<.01&&Math.abs(u-y)<.01&&Math.abs(p-v)<.01){if(Math.abs(d+f)<.1&&Math.abs(u+y)<.1&&Math.abs(p+v)<.1&&Math.abs(l+h+g-3)<.1)return this.set(1,0,0,0),this;n=Math.PI;const _=(l+1)/2,w=(h+1)/2,b=(g+1)/2,x=(d+f)/4,D=(u+y)/4,I=(p+v)/4;return _>w&&_>b?_<.01?(i=0,r=.707106781,o=.707106781):(i=Math.sqrt(_),r=x/i,o=D/i):w>b?w<.01?(i=.707106781,r=0,o=.707106781):(r=Math.sqrt(w),i=x/r,o=I/r):b<.01?(i=.707106781,r=.707106781,o=0):(o=Math.sqrt(b),i=D/o,r=I/o),this.set(i,r,o,n),this}let m=Math.sqrt((v-p)*(v-p)+(u-y)*(u-y)+(f-d)*(f-d));return Math.abs(m)<.001&&(m=1),this.x=(v-p)/m,this.y=(u-y)/m,this.z=(f-d)/m,this.w=Math.acos((l+h+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this.z=Math.max(t.z,Math.min(n.z,this.z)),this.w=Math.max(t.w,Math.min(n.w,this.w)),this}clampScalar(t,n){return this.x=Math.max(t,Math.min(n,this.x)),this.y=Math.max(t,Math.min(n,this.y)),this.z=Math.max(t,Math.min(n,this.z)),this.w=Math.max(t,Math.min(n,this.w)),this}clampLength(t,n){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(n,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this.z+=(t.z-this.z)*n,this.w+=(t.w-this.w)*n,this}lerpVectors(t,n,i){return this.x=t.x+(n.x-t.x)*i,this.y=t.y+(n.y-t.y)*i,this.z=t.z+(n.z-t.z)*i,this.w=t.w+(n.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,n=0){return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this.w=t[n+3],this}toArray(t=[],n=0){return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t[n+3]=this.w,t}fromBufferAttribute(t,n,i){return void 0!==i&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(n),this.y=t.getY(n),this.z=t.getZ(n),this.w=t.getW(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}function yi(e,t,n){this.width=e,this.height=t,this.scissor=new It(0,0,e,t),this.scissorTest=!1,this.viewport=new It(0,0,e,t),this.texture=new At(void 0,(n=n||{}).mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:En,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}function cy(e,t,n){yi.call(this,e,t,n),this.samples=4}yi.prototype=Object.assign(Object.create(_r.prototype),{constructor:yi,isWebGLRenderTarget:!0,setSize:function(e,t){(this.width!==e||this.height!==t)&&(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),cy.prototype=Object.assign(Object.create(yi.prototype),{constructor:cy,isWebGLMultisampleRenderTarget:!0,copy:function(e){return yi.prototype.copy.call(this,e),this.samples=e.samples,this}});class On{constructor(t=0,n=0,i=0,r=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=t,this._y=n,this._z=i,this._w=r}static slerp(t,n,i,r){return i.copy(t).slerp(n,r)}static slerpFlat(t,n,i,r,o,s,a){let c=i[r+0],l=i[r+1],d=i[r+2],u=i[r+3];const f=o[s+0],h=o[s+1],p=o[s+2],y=o[s+3];if(u!==y||c!==f||l!==h||d!==p){let v=1-a;const g=c*f+l*h+d*p+u*y,m=g>=0?1:-1,_=1-g*g;if(_>Number.EPSILON){const b=Math.sqrt(_),x=Math.atan2(b,g*m);v=Math.sin(v*x)/b,a=Math.sin(a*x)/b}const w=a*m;if(c=c*v+f*w,l=l*v+h*w,d=d*v+p*w,u=u*v+y*w,v===1-a){const b=1/Math.sqrt(c*c+l*l+d*d+u*u);c*=b,l*=b,d*=b,u*=b}}t[n]=c,t[n+1]=l,t[n+2]=d,t[n+3]=u}static multiplyQuaternionsFlat(t,n,i,r,o,s){const a=i[r],c=i[r+1],l=i[r+2],d=i[r+3],u=o[s],f=o[s+1],h=o[s+2],p=o[s+3];return t[n]=a*p+d*u+c*h-l*f,t[n+1]=c*p+d*f+l*u-a*h,t[n+2]=l*p+d*h+a*f-c*u,t[n+3]=d*p-a*u-c*f-l*h,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,n,i,r){return this._x=t,this._y=n,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,n){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,r=t._y,o=t._z,s=t._order,a=Math.cos,c=Math.sin,l=a(i/2),d=a(r/2),u=a(o/2),f=c(i/2),h=c(r/2),p=c(o/2);switch(s){case"XYZ":this._x=f*d*u+l*h*p,this._y=l*h*u-f*d*p,this._z=l*d*p+f*h*u,this._w=l*d*u-f*h*p;break;case"YXZ":this._x=f*d*u+l*h*p,this._y=l*h*u-f*d*p,this._z=l*d*p-f*h*u,this._w=l*d*u+f*h*p;break;case"ZXY":this._x=f*d*u-l*h*p,this._y=l*h*u+f*d*p,this._z=l*d*p+f*h*u,this._w=l*d*u-f*h*p;break;case"ZYX":this._x=f*d*u-l*h*p,this._y=l*h*u+f*d*p,this._z=l*d*p-f*h*u,this._w=l*d*u+f*h*p;break;case"YZX":this._x=f*d*u+l*h*p,this._y=l*h*u+f*d*p,this._z=l*d*p-f*h*u,this._w=l*d*u-f*h*p;break;case"XZY":this._x=f*d*u-l*h*p,this._y=l*h*u-f*d*p,this._z=l*d*p+f*h*u,this._w=l*d*u+f*h*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==n&&this._onChangeCallback(),this}setFromAxisAngle(t,n){const i=n/2,r=Math.sin(i);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const n=t.elements,i=n[0],r=n[4],o=n[8],s=n[1],a=n[5],c=n[9],l=n[2],d=n[6],u=n[10],f=i+a+u;if(f>0){const h=.5/Math.sqrt(f+1);this._w=.25/h,this._x=(d-c)*h,this._y=(o-l)*h,this._z=(s-r)*h}else if(i>a&&i>u){const h=2*Math.sqrt(1+i-a-u);this._w=(d-c)/h,this._x=.25*h,this._y=(r+s)/h,this._z=(o+l)/h}else if(a>u){const h=2*Math.sqrt(1+a-i-u);this._w=(o-l)/h,this._x=(r+s)/h,this._y=.25*h,this._z=(c+d)/h}else{const h=2*Math.sqrt(1+u-i-a);this._w=(s-r)/h,this._x=(o+l)/h,this._y=(c+d)/h,this._z=.25*h}return this._onChangeCallback(),this}setFromUnitVectors(t,n){let r=t.dot(n)+1;return r<1e-6?(r=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=r):(this._x=0,this._y=-t.z,this._z=t.y,this._w=r)):(this._x=t.y*n.z-t.z*n.y,this._y=t.z*n.x-t.x*n.z,this._z=t.x*n.y-t.y*n.x,this._w=r),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(ke.clamp(this.dot(t),-1,1)))}rotateTowards(t,n){const i=this.angleTo(t);if(0===i)return this;const r=Math.min(1,n/i);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,n){return void 0!==n?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,n)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,n){const i=t._x,r=t._y,o=t._z,s=t._w,a=n._x,c=n._y,l=n._z,d=n._w;return this._x=i*d+s*a+r*l-o*c,this._y=r*d+s*c+o*a-i*l,this._z=o*d+s*l+i*c-r*a,this._w=s*d-i*a-r*c-o*l,this._onChangeCallback(),this}slerp(t,n){if(0===n)return this;if(1===n)return this.copy(t);const i=this._x,r=this._y,o=this._z,s=this._w;let a=s*t._w+i*t._x+r*t._y+o*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=s,this._x=i,this._y=r,this._z=o,this;const c=1-a*a;if(c<=Number.EPSILON){const h=1-n;return this._w=h*s+n*this._w,this._x=h*i+n*this._x,this._y=h*r+n*this._y,this._z=h*o+n*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(c),d=Math.atan2(l,a),u=Math.sin((1-n)*d)/l,f=Math.sin(n*d)/l;return this._w=s*u+this._w*f,this._x=i*u+this._x*f,this._y=r*u+this._y*f,this._z=o*u+this._z*f,this._onChangeCallback(),this}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,n=0){return this._x=t[n],this._y=t[n+1],this._z=t[n+2],this._w=t[n+3],this._onChangeCallback(),this}toArray(t=[],n=0){return t[n]=this._x,t[n+1]=this._y,t[n+2]=this._z,t[n+3]=this._w,t}fromBufferAttribute(t,n){return this._x=t.getX(n),this._y=t.getY(n),this._z=t.getZ(n),this._w=t.getW(n),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}class M{constructor(t=0,n=0,i=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=t,this.y=n,this.z=i}set(t,n,i){return void 0===i&&(i=this.z),this.x=t,this.y=n,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,n){switch(t){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,n){return void 0!==n?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,n)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this.z=t.z+n.z,this}addScaledVector(t,n){return this.x+=t.x*n,this.y+=t.y*n,this.z+=t.z*n,this}sub(t,n){return void 0!==n?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,n)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this.z=t.z-n.z,this}multiply(t,n){return void 0!==n?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,n)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,n){return this.x=t.x*n.x,this.y=t.y*n.y,this.z=t.z*n.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(uT.setFromEuler(t))}applyAxisAngle(t,n){return this.applyQuaternion(uT.setFromAxisAngle(t,n))}applyMatrix3(t){const n=this.x,i=this.y,r=this.z,o=t.elements;return this.x=o[0]*n+o[3]*i+o[6]*r,this.y=o[1]*n+o[4]*i+o[7]*r,this.z=o[2]*n+o[5]*i+o[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const n=this.x,i=this.y,r=this.z,o=t.elements,s=1/(o[3]*n+o[7]*i+o[11]*r+o[15]);return this.x=(o[0]*n+o[4]*i+o[8]*r+o[12])*s,this.y=(o[1]*n+o[5]*i+o[9]*r+o[13])*s,this.z=(o[2]*n+o[6]*i+o[10]*r+o[14])*s,this}applyQuaternion(t){const n=this.x,i=this.y,r=this.z,o=t.x,s=t.y,a=t.z,c=t.w,l=c*n+s*r-a*i,d=c*i+a*n-o*r,u=c*r+o*i-s*n,f=-o*n-s*i-a*r;return this.x=l*c+f*-o+d*-a-u*-s,this.y=d*c+f*-s+u*-o-l*-a,this.z=u*c+f*-a+l*-s-d*-o,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const n=this.x,i=this.y,r=this.z,o=t.elements;return this.x=o[0]*n+o[4]*i+o[8]*r,this.y=o[1]*n+o[5]*i+o[9]*r,this.z=o[2]*n+o[6]*i+o[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this.z=Math.max(t.z,Math.min(n.z,this.z)),this}clampScalar(t,n){return this.x=Math.max(t,Math.min(n,this.x)),this.y=Math.max(t,Math.min(n,this.y)),this.z=Math.max(t,Math.min(n,this.z)),this}clampLength(t,n){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(n,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this.z+=(t.z-this.z)*n,this}lerpVectors(t,n,i){return this.x=t.x+(n.x-t.x)*i,this.y=t.y+(n.y-t.y)*i,this.z=t.z+(n.z-t.z)*i,this}cross(t,n){return void 0!==n?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,n)):this.crossVectors(this,t)}crossVectors(t,n){const i=t.x,r=t.y,o=t.z,s=n.x,a=n.y,c=n.z;return this.x=r*c-o*a,this.y=o*s-i*c,this.z=i*a-r*s,this}projectOnVector(t){const n=t.lengthSq();if(0===n)return this.set(0,0,0);const i=t.dot(this)/n;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return ly.copy(this).projectOnVector(t),this.sub(ly)}reflect(t){return this.sub(ly.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const n=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===n)return Math.PI/2;const i=this.dot(t)/n;return Math.acos(ke.clamp(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const n=this.x-t.x,i=this.y-t.y,r=this.z-t.z;return n*n+i*i+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,n,i){const r=Math.sin(n)*t;return this.x=r*Math.sin(i),this.y=Math.cos(n)*t,this.z=r*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,n,i){return this.x=t*Math.sin(n),this.y=i,this.z=t*Math.cos(n),this}setFromMatrixPosition(t){const n=t.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this}setFromMatrixScale(t){const n=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=n,this.y=i,this.z=r,this}setFromMatrixColumn(t,n){return this.fromArray(t.elements,4*n)}setFromMatrix3Column(t,n){return this.fromArray(t.elements,3*n)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,n=0){return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this}toArray(t=[],n=0){return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t}fromBufferAttribute(t,n,i){return void 0!==i&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(n),this.y=t.getY(n),this.z=t.getZ(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const ly=new M,uT=new On;class xr{constructor(t,n){Object.defineProperty(this,"isBox3",{value:!0}),this.min=void 0!==t?t:new M(1/0,1/0,1/0),this.max=void 0!==n?n:new M(-1/0,-1/0,-1/0)}set(t,n){return this.min.copy(t),this.max.copy(n),this}setFromArray(t){let n=1/0,i=1/0,r=1/0,o=-1/0,s=-1/0,a=-1/0;for(let c=0,l=t.length;c<l;c+=3){const d=t[c],u=t[c+1],f=t[c+2];d<n&&(n=d),u<i&&(i=u),f<r&&(r=f),d>o&&(o=d),u>s&&(s=u),f>a&&(a=f)}return this.min.set(n,i,r),this.max.set(o,s,a),this}setFromBufferAttribute(t){let n=1/0,i=1/0,r=1/0,o=-1/0,s=-1/0,a=-1/0;for(let c=0,l=t.count;c<l;c++){const d=t.getX(c),u=t.getY(c),f=t.getZ(c);d<n&&(n=d),u<i&&(i=u),f<r&&(r=f),d>o&&(o=d),u>s&&(s=u),f>a&&(a=f)}return this.min.set(n,i,r),this.max.set(o,s,a),this}setFromPoints(t){this.makeEmpty();for(let n=0,i=t.length;n<i;n++)this.expandByPoint(t[n]);return this}setFromCenterAndSize(t,n){const i=El.copy(n).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return void 0===t&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new M),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return void 0===t&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new M),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const n=t.geometry;void 0!==n&&(null===n.boundingBox&&n.computeBoundingBox(),dy.copy(n.boundingBox),dy.applyMatrix4(t.matrixWorld),this.union(dy));const i=t.children;for(let r=0,o=i.length;r<o;r++)this.expandByObject(i[r]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,n){return void 0===n&&(console.warn("THREE.Box3: .getParameter() target is now required"),n=new M),n.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,El),El.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let n,i;return t.normal.x>0?(n=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(n=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(n+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(n+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(n+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(n+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),n<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Sl),nf.subVectors(this.max,Sl),Ra.subVectors(t.a,Sl),Pa.subVectors(t.b,Sl),Fa.subVectors(t.c,Sl),bo.subVectors(Pa,Ra),Mo.subVectors(Fa,Pa),ds.subVectors(Ra,Fa);let n=[0,-bo.z,bo.y,0,-Mo.z,Mo.y,0,-ds.z,ds.y,bo.z,0,-bo.x,Mo.z,0,-Mo.x,ds.z,0,-ds.x,-bo.y,bo.x,0,-Mo.y,Mo.x,0,-ds.y,ds.x,0];return!(!uy(n,Ra,Pa,Fa,nf)||(n=[1,0,0,0,1,0,0,0,1],!uy(n,Ra,Pa,Fa,nf)))&&(rf.crossVectors(bo,Mo),n=[rf.x,rf.y,rf.z],uy(n,Ra,Pa,Fa,nf))}clampPoint(t,n){return void 0===n&&(console.warn("THREE.Box3: .clampPoint() target is now required"),n=new M),n.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return El.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return void 0===t&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=.5*this.getSize(El).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(Yr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Yr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Yr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Yr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Yr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Yr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Yr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Yr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Yr)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}function uy(e,t,n,i,r){for(let o=0,s=e.length-3;o<=s;o+=3){fs.fromArray(e,o);const a=r.x*Math.abs(fs.x)+r.y*Math.abs(fs.y)+r.z*Math.abs(fs.z),c=t.dot(fs),l=n.dot(fs),d=i.dot(fs);if(Math.max(-Math.max(c,l,d),Math.min(c,l,d))>a)return!1}return!0}const Yr=[new M,new M,new M,new M,new M,new M,new M,new M],El=new M,dy=new xr,Ra=new M,Pa=new M,Fa=new M,bo=new M,Mo=new M,ds=new M,Sl=new M,nf=new M,rf=new M,fs=new M,kB=new xr;class Zr{constructor(t,n){this.center=void 0!==t?t:new M,this.radius=void 0!==n?n:-1}set(t,n){return this.center.copy(t),this.radius=n,this}setFromPoints(t,n){const i=this.center;void 0!==n?i.copy(n):kB.setFromPoints(t).getCenter(i);let r=0;for(let o=0,s=t.length;o<s;o++)r=Math.max(r,i.distanceToSquared(t[o]));return this.radius=Math.sqrt(r),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const n=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=n*n}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,n){const i=this.center.distanceToSquared(t);return void 0===n&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),n=new M),n.copy(t),i>this.radius*this.radius&&(n.sub(this.center).normalize(),n.multiplyScalar(this.radius).add(this.center)),n}getBoundingBox(t){return void 0===t&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new xr),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}}const Jr=new M,fy=new M,of=new M,Eo=new M,hy=new M,sf=new M,py=new M;class Na{constructor(t,n){this.origin=void 0!==t?t:new M,this.direction=void 0!==n?n:new M(0,0,-1)}set(t,n){return this.origin.copy(t),this.direction.copy(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,n){return void 0===n&&(console.warn("THREE.Ray: .at() target is now required"),n=new M),n.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Jr)),this}closestPointToPoint(t,n){void 0===n&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),n=new M),n.subVectors(t,this.origin);const i=n.dot(this.direction);return i<0?n.copy(this.origin):n.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const n=Jr.subVectors(t,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(t):(Jr.copy(this.direction).multiplyScalar(n).add(this.origin),Jr.distanceToSquared(t))}distanceSqToSegment(t,n,i,r){fy.copy(t).add(n).multiplyScalar(.5),of.copy(n).sub(t).normalize(),Eo.copy(this.origin).sub(fy);const o=.5*t.distanceTo(n),s=-this.direction.dot(of),a=Eo.dot(this.direction),c=-Eo.dot(of),l=Eo.lengthSq(),d=Math.abs(1-s*s);let u,f,h,p;if(d>0)if(u=s*c-a,f=s*a-c,p=o*d,u>=0)if(f>=-p)if(f<=p){const y=1/d;u*=y,f*=y,h=u*(u+s*f+2*a)+f*(s*u+f+2*c)+l}else f=o,u=Math.max(0,-(s*f+a)),h=-u*u+f*(f+2*c)+l;else f=-o,u=Math.max(0,-(s*f+a)),h=-u*u+f*(f+2*c)+l;else f<=-p?(u=Math.max(0,-(-s*o+a)),f=u>0?-o:Math.min(Math.max(-o,-c),o),h=-u*u+f*(f+2*c)+l):f<=p?(u=0,f=Math.min(Math.max(-o,-c),o),h=f*(f+2*c)+l):(u=Math.max(0,-(s*o+a)),f=u>0?o:Math.min(Math.max(-o,-c),o),h=-u*u+f*(f+2*c)+l);else f=s>0?-o:o,u=Math.max(0,-(s*f+a)),h=-u*u+f*(f+2*c)+l;return i&&i.copy(this.direction).multiplyScalar(u).add(this.origin),r&&r.copy(of).multiplyScalar(f).add(fy),h}intersectSphere(t,n){Jr.subVectors(t.center,this.origin);const i=Jr.dot(this.direction),r=Jr.dot(Jr)-i*i,o=t.radius*t.radius;if(r>o)return null;const s=Math.sqrt(o-r),a=i-s,c=i+s;return a<0&&c<0?null:this.at(a<0?c:a,n)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const n=t.normal.dot(this.direction);if(0===n)return 0===t.distanceToPoint(this.origin)?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/n;return i>=0?i:null}intersectPlane(t,n){const i=this.distanceToPlane(t);return null===i?null:this.at(i,n)}intersectsPlane(t){const n=t.distanceToPoint(this.origin);return 0===n||t.normal.dot(this.direction)*n<0}intersectBox(t,n){let i,r,o,s,a,c;const l=1/this.direction.x,d=1/this.direction.y,u=1/this.direction.z,f=this.origin;return l>=0?(i=(t.min.x-f.x)*l,r=(t.max.x-f.x)*l):(i=(t.max.x-f.x)*l,r=(t.min.x-f.x)*l),d>=0?(o=(t.min.y-f.y)*d,s=(t.max.y-f.y)*d):(o=(t.max.y-f.y)*d,s=(t.min.y-f.y)*d),i>s||o>r||((o>i||i!=i)&&(i=o),(s<r||r!=r)&&(r=s),u>=0?(a=(t.min.z-f.z)*u,c=(t.max.z-f.z)*u):(a=(t.max.z-f.z)*u,c=(t.min.z-f.z)*u),i>c||a>r)||((a>i||i!=i)&&(i=a),(c<r||r!=r)&&(r=c),r<0)?null:this.at(i>=0?i:r,n)}intersectsBox(t){return null!==this.intersectBox(t,Jr)}intersectTriangle(t,n,i,r,o){hy.subVectors(n,t),sf.subVectors(i,t),py.crossVectors(hy,sf);let a,s=this.direction.dot(py);if(s>0){if(r)return null;a=1}else{if(!(s<0))return null;a=-1,s=-s}Eo.subVectors(this.origin,t);const c=a*this.direction.dot(sf.crossVectors(Eo,sf));if(c<0)return null;const l=a*this.direction.dot(hy.cross(Eo));if(l<0||c+l>s)return null;const d=-a*Eo.dot(py);return d<0?null:this.at(d/s,o)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}class Ze{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,n,i,r,o,s,a,c,l,d,u,f,h,p,y,v){const g=this.elements;return g[0]=t,g[4]=n,g[8]=i,g[12]=r,g[1]=o,g[5]=s,g[9]=a,g[13]=c,g[2]=l,g[6]=d,g[10]=u,g[14]=f,g[3]=h,g[7]=p,g[11]=y,g[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Ze).fromArray(this.elements)}copy(t){const n=this.elements,i=t.elements;return n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=i[3],n[4]=i[4],n[5]=i[5],n[6]=i[6],n[7]=i[7],n[8]=i[8],n[9]=i[9],n[10]=i[10],n[11]=i[11],n[12]=i[12],n[13]=i[13],n[14]=i[14],n[15]=i[15],this}copyPosition(t){const n=this.elements,i=t.elements;return n[12]=i[12],n[13]=i[13],n[14]=i[14],this}extractBasis(t,n,i){return t.setFromMatrixColumn(this,0),n.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,n,i){return this.set(t.x,n.x,i.x,0,t.y,n.y,i.y,0,t.z,n.z,i.z,0,0,0,0,1),this}extractRotation(t){const n=this.elements,i=t.elements,r=1/Oa.setFromMatrixColumn(t,0).length(),o=1/Oa.setFromMatrixColumn(t,1).length(),s=1/Oa.setFromMatrixColumn(t,2).length();return n[0]=i[0]*r,n[1]=i[1]*r,n[2]=i[2]*r,n[3]=0,n[4]=i[4]*o,n[5]=i[5]*o,n[6]=i[6]*o,n[7]=0,n[8]=i[8]*s,n[9]=i[9]*s,n[10]=i[10]*s,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const n=this.elements,i=t.x,r=t.y,o=t.z,s=Math.cos(i),a=Math.sin(i),c=Math.cos(r),l=Math.sin(r),d=Math.cos(o),u=Math.sin(o);if("XYZ"===t.order){const f=s*d,h=s*u,p=a*d,y=a*u;n[0]=c*d,n[4]=-c*u,n[8]=l,n[1]=h+p*l,n[5]=f-y*l,n[9]=-a*c,n[2]=y-f*l,n[6]=p+h*l,n[10]=s*c}else if("YXZ"===t.order){const f=c*d,h=c*u,p=l*d,y=l*u;n[0]=f+y*a,n[4]=p*a-h,n[8]=s*l,n[1]=s*u,n[5]=s*d,n[9]=-a,n[2]=h*a-p,n[6]=y+f*a,n[10]=s*c}else if("ZXY"===t.order){const f=c*d,h=c*u,p=l*d,y=l*u;n[0]=f-y*a,n[4]=-s*u,n[8]=p+h*a,n[1]=h+p*a,n[5]=s*d,n[9]=y-f*a,n[2]=-s*l,n[6]=a,n[10]=s*c}else if("ZYX"===t.order){const f=s*d,h=s*u,p=a*d,y=a*u;n[0]=c*d,n[4]=p*l-h,n[8]=f*l+y,n[1]=c*u,n[5]=y*l+f,n[9]=h*l-p,n[2]=-l,n[6]=a*c,n[10]=s*c}else if("YZX"===t.order){const f=s*c,h=s*l,p=a*c,y=a*l;n[0]=c*d,n[4]=y-f*u,n[8]=p*u+h,n[1]=u,n[5]=s*d,n[9]=-a*d,n[2]=-l*d,n[6]=h*u+p,n[10]=f-y*u}else if("XZY"===t.order){const f=s*c,h=s*l,p=a*c,y=a*l;n[0]=c*d,n[4]=-u,n[8]=l*d,n[1]=f*u+y,n[5]=s*d,n[9]=h*u-p,n[2]=p*u-h,n[6]=a*d,n[10]=y*u+f}return n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromQuaternion(t){return this.compose(HB,t,VB)}lookAt(t,n,i){const r=this.elements;return vi.subVectors(t,n),0===vi.lengthSq()&&(vi.z=1),vi.normalize(),So.crossVectors(i,vi),0===So.lengthSq()&&(1===Math.abs(i.z)?vi.x+=1e-4:vi.z+=1e-4,vi.normalize(),So.crossVectors(i,vi)),So.normalize(),af.crossVectors(vi,So),r[0]=So.x,r[4]=af.x,r[8]=vi.x,r[1]=So.y,r[5]=af.y,r[9]=vi.y,r[2]=So.z,r[6]=af.z,r[10]=vi.z,this}multiply(t,n){return void 0!==n?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,n)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,n){const i=t.elements,r=n.elements,o=this.elements,s=i[0],a=i[4],c=i[8],l=i[12],d=i[1],u=i[5],f=i[9],h=i[13],p=i[2],y=i[6],v=i[10],g=i[14],m=i[3],_=i[7],w=i[11],b=i[15],x=r[0],D=r[4],I=r[8],R=r[12],U=r[1],P=r[5],F=r[9],N=r[13],L=r[2],A=r[6],B=r[10],W=r[14],Y=r[3],oe=r[7],he=r[11],ue=r[15];return o[0]=s*x+a*U+c*L+l*Y,o[4]=s*D+a*P+c*A+l*oe,o[8]=s*I+a*F+c*B+l*he,o[12]=s*R+a*N+c*W+l*ue,o[1]=d*x+u*U+f*L+h*Y,o[5]=d*D+u*P+f*A+h*oe,o[9]=d*I+u*F+f*B+h*he,o[13]=d*R+u*N+f*W+h*ue,o[2]=p*x+y*U+v*L+g*Y,o[6]=p*D+y*P+v*A+g*oe,o[10]=p*I+y*F+v*B+g*he,o[14]=p*R+y*N+v*W+g*ue,o[3]=m*x+_*U+w*L+b*Y,o[7]=m*D+_*P+w*A+b*oe,o[11]=m*I+_*F+w*B+b*he,o[15]=m*R+_*N+w*W+b*ue,this}multiplyScalar(t){const n=this.elements;return n[0]*=t,n[4]*=t,n[8]*=t,n[12]*=t,n[1]*=t,n[5]*=t,n[9]*=t,n[13]*=t,n[2]*=t,n[6]*=t,n[10]*=t,n[14]*=t,n[3]*=t,n[7]*=t,n[11]*=t,n[15]*=t,this}determinant(){const t=this.elements,n=t[0],i=t[4],r=t[8],o=t[12],s=t[1],a=t[5],c=t[9],l=t[13],d=t[2],u=t[6],f=t[10],h=t[14];return t[3]*(+o*c*u-r*l*u-o*a*f+i*l*f+r*a*h-i*c*h)+t[7]*(+n*c*h-n*l*f+o*s*f-r*s*h+r*l*d-o*c*d)+t[11]*(+n*l*u-n*a*h-o*s*u+i*s*h+o*a*d-i*l*d)+t[15]*(-r*a*d-n*c*u+n*a*f+r*s*u-i*s*f+i*c*d)}transpose(){const t=this.elements;let n;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[6],t[6]=t[9],t[9]=n,n=t[3],t[3]=t[12],t[12]=n,n=t[7],t[7]=t[13],t[13]=n,n=t[11],t[11]=t[14],t[14]=n,this}setPosition(t,n,i){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=n,r[14]=i),this}invert(){const t=this.elements,n=t[0],i=t[1],r=t[2],o=t[3],s=t[4],a=t[5],c=t[6],l=t[7],d=t[8],u=t[9],f=t[10],h=t[11],p=t[12],y=t[13],v=t[14],g=t[15],m=u*v*l-y*f*l+y*c*h-a*v*h-u*c*g+a*f*g,_=p*f*l-d*v*l-p*c*h+s*v*h+d*c*g-s*f*g,w=d*y*l-p*u*l+p*a*h-s*y*h-d*a*g+s*u*g,b=p*u*c-d*y*c-p*a*f+s*y*f+d*a*v-s*u*v,x=n*m+i*_+r*w+o*b;if(0===x)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const D=1/x;return t[0]=m*D,t[1]=(y*f*o-u*v*o-y*r*h+i*v*h+u*r*g-i*f*g)*D,t[2]=(a*v*o-y*c*o+y*r*l-i*v*l-a*r*g+i*c*g)*D,t[3]=(u*c*o-a*f*o-u*r*l+i*f*l+a*r*h-i*c*h)*D,t[4]=_*D,t[5]=(d*v*o-p*f*o+p*r*h-n*v*h-d*r*g+n*f*g)*D,t[6]=(p*c*o-s*v*o-p*r*l+n*v*l+s*r*g-n*c*g)*D,t[7]=(s*f*o-d*c*o+d*r*l-n*f*l-s*r*h+n*c*h)*D,t[8]=w*D,t[9]=(p*u*o-d*y*o-p*i*h+n*y*h+d*i*g-n*u*g)*D,t[10]=(s*y*o-p*a*o+p*i*l-n*y*l-s*i*g+n*a*g)*D,t[11]=(d*a*o-s*u*o-d*i*l+n*u*l+s*i*h-n*a*h)*D,t[12]=b*D,t[13]=(d*y*r-p*u*r+p*i*f-n*y*f-d*i*v+n*u*v)*D,t[14]=(p*a*r-s*y*r-p*i*c+n*y*c+s*i*v-n*a*v)*D,t[15]=(s*u*r-d*a*r+d*i*c-n*u*c-s*i*f+n*a*f)*D,this}scale(t){const n=this.elements,i=t.x,r=t.y,o=t.z;return n[0]*=i,n[4]*=r,n[8]*=o,n[1]*=i,n[5]*=r,n[9]*=o,n[2]*=i,n[6]*=r,n[10]*=o,n[3]*=i,n[7]*=r,n[11]*=o,this}getMaxScaleOnAxis(){const t=this.elements;return Math.sqrt(Math.max(t[0]*t[0]+t[1]*t[1]+t[2]*t[2],t[4]*t[4]+t[5]*t[5]+t[6]*t[6],t[8]*t[8]+t[9]*t[9]+t[10]*t[10]))}makeTranslation(t,n,i){return this.set(1,0,0,t,0,1,0,n,0,0,1,i,0,0,0,1),this}makeRotationX(t){const n=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,n,-i,0,0,i,n,0,0,0,0,1),this}makeRotationY(t){const n=Math.cos(t),i=Math.sin(t);return this.set(n,0,i,0,0,1,0,0,-i,0,n,0,0,0,0,1),this}makeRotationZ(t){const n=Math.cos(t),i=Math.sin(t);return this.set(n,-i,0,0,i,n,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,n){const i=Math.cos(n),r=Math.sin(n),o=1-i,s=t.x,a=t.y,c=t.z,l=o*s,d=o*a;return this.set(l*s+i,l*a-r*c,l*c+r*a,0,l*a+r*c,d*a+i,d*c-r*s,0,l*c-r*a,d*c+r*s,o*c*c+i,0,0,0,0,1),this}makeScale(t,n,i){return this.set(t,0,0,0,0,n,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,n,i){return this.set(1,n,i,0,t,1,i,0,t,n,1,0,0,0,0,1),this}compose(t,n,i){const r=this.elements,o=n._x,s=n._y,a=n._z,c=n._w,l=o+o,d=s+s,u=a+a,f=o*l,h=o*d,p=o*u,y=s*d,v=s*u,g=a*u,m=c*l,_=c*d,w=c*u,b=i.x,x=i.y,D=i.z;return r[0]=(1-(y+g))*b,r[1]=(h+w)*b,r[2]=(p-_)*b,r[3]=0,r[4]=(h-w)*x,r[5]=(1-(f+g))*x,r[6]=(v+m)*x,r[7]=0,r[8]=(p+_)*D,r[9]=(v-m)*D,r[10]=(1-(f+y))*D,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,n,i){const r=this.elements;let o=Oa.set(r[0],r[1],r[2]).length();const s=Oa.set(r[4],r[5],r[6]).length(),a=Oa.set(r[8],r[9],r[10]).length();this.determinant()<0&&(o=-o),t.x=r[12],t.y=r[13],t.z=r[14],Zi.copy(this);const l=1/o,d=1/s,u=1/a;return Zi.elements[0]*=l,Zi.elements[1]*=l,Zi.elements[2]*=l,Zi.elements[4]*=d,Zi.elements[5]*=d,Zi.elements[6]*=d,Zi.elements[8]*=u,Zi.elements[9]*=u,Zi.elements[10]*=u,n.setFromRotationMatrix(Zi),i.x=o,i.y=s,i.z=a,this}makePerspective(t,n,i,r,o,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*o/(i-r),d=(n+t)/(n-t),u=(i+r)/(i-r),f=-(s+o)/(s-o),h=-2*s*o/(s-o);return a[0]=2*o/(n-t),a[4]=0,a[8]=d,a[12]=0,a[1]=0,a[5]=l,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=f,a[14]=h,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,n,i,r,o,s){const a=this.elements,c=1/(n-t),l=1/(i-r),d=1/(s-o),u=(n+t)*c,f=(i+r)*l,h=(s+o)*d;return a[0]=2*c,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-f,a[2]=0,a[6]=0,a[10]=-2*d,a[14]=-h,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const n=this.elements,i=t.elements;for(let r=0;r<16;r++)if(n[r]!==i[r])return!1;return!0}fromArray(t,n=0){for(let i=0;i<16;i++)this.elements[i]=t[i+n];return this}toArray(t=[],n=0){const i=this.elements;return t[n]=i[0],t[n+1]=i[1],t[n+2]=i[2],t[n+3]=i[3],t[n+4]=i[4],t[n+5]=i[5],t[n+6]=i[6],t[n+7]=i[7],t[n+8]=i[8],t[n+9]=i[9],t[n+10]=i[10],t[n+11]=i[11],t[n+12]=i[12],t[n+13]=i[13],t[n+14]=i[14],t[n+15]=i[15],t}}const Oa=new M,Zi=new Ze,HB=new M(0,0,0),VB=new M(1,1,1),So=new M,af=new M,vi=new M;let dT=(()=>{class e{constructor(n=0,i=0,r=0,o=e.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=n,this._y=i,this._z=r,this._order=o}get x(){return this._x}set x(n){this._x=n,this._onChangeCallback()}get y(){return this._y}set y(n){this._y=n,this._onChangeCallback()}get z(){return this._z}set z(n){this._z=n,this._onChangeCallback()}get order(){return this._order}set order(n){this._order=n,this._onChangeCallback()}set(n,i,r,o){return this._x=n,this._y=i,this._z=r,this._order=o||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(n){return this._x=n._x,this._y=n._y,this._z=n._z,this._order=n._order,this._onChangeCallback(),this}setFromRotationMatrix(n,i,r){const o=ke.clamp,s=n.elements,a=s[0],c=s[4],l=s[8],d=s[1],u=s[5],f=s[9],h=s[2],p=s[6],y=s[10];switch(i=i||this._order){case"XYZ":this._y=Math.asin(o(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-f,y),this._z=Math.atan2(-c,a)):(this._x=Math.atan2(p,u),this._z=0);break;case"YXZ":this._x=Math.asin(-o(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(l,y),this._z=Math.atan2(d,u)):(this._y=Math.atan2(-h,a),this._z=0);break;case"ZXY":this._x=Math.asin(o(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(-h,y),this._z=Math.atan2(-c,u)):(this._y=0,this._z=Math.atan2(d,a));break;case"ZYX":this._y=Math.asin(-o(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(p,y),this._z=Math.atan2(d,a)):(this._x=0,this._z=Math.atan2(-c,u));break;case"YZX":this._z=Math.asin(o(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(-f,u),this._y=Math.atan2(-h,a)):(this._x=0,this._y=Math.atan2(l,y));break;case"XZY":this._z=Math.asin(-o(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(p,u),this._y=Math.atan2(l,a)):(this._x=Math.atan2(-f,y),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+i)}return this._order=i,!1!==r&&this._onChangeCallback(),this}setFromQuaternion(n,i,r){return fT.makeRotationFromQuaternion(n),this.setFromRotationMatrix(fT,i,r)}setFromVector3(n,i){return this.set(n.x,n.y,n.z,i||this._order)}reorder(n){return hT.setFromEuler(this),this.setFromQuaternion(hT,n)}equals(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._order===this._order}fromArray(n){return this._x=n[0],this._y=n[1],this._z=n[2],void 0!==n[3]&&(this._order=n[3]),this._onChangeCallback(),this}toArray(n=[],i=0){return n[i]=this._x,n[i+1]=this._y,n[i+2]=this._z,n[i+3]=this._order,n}toVector3(n){return n?n.set(this._x,this._y,this._z):new M(this._x,this._y,this._z)}_onChange(n){return this._onChangeCallback=n,this}_onChangeCallback(){}}return e.DefaultOrder="XYZ",e.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"],e})();const fT=new Ze,hT=new On;class my{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}}let UB=0;const pT=new M,Ba=new On,Qr=new Ze,cf=new M,Tl=new M,GB=new M,zB=new On,mT=new M(1,0,0),gT=new M(0,1,0),yT=new M(0,0,1),jB={type:"added"},vT={type:"removed"};function ge(){Object.defineProperty(this,"id",{value:UB++}),this.uuid=ke.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ge.DefaultUp.clone();const e=new M,t=new dT,n=new On,i=new M(1,1,1);t._onChange(function r(){n.setFromEuler(t,!1)}),n._onChange(function o(){t.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Ze},normalMatrix:{value:new Zn}}),this.matrix=new Ze,this.matrixWorld=new Ze,this.matrixAutoUpdate=ge.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new my,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}ge.DefaultUp=new M(0,1,0),ge.DefaultMatrixAutoUpdate=!0,ge.prototype=Object.assign(Object.create(_r.prototype),{constructor:ge,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(e){return this.quaternion.premultiply(e),this},setRotationFromAxisAngle:function(e,t){this.quaternion.setFromAxisAngle(e,t)},setRotationFromEuler:function(e){this.quaternion.setFromEuler(e,!0)},setRotationFromMatrix:function(e){this.quaternion.setFromRotationMatrix(e)},setRotationFromQuaternion:function(e){this.quaternion.copy(e)},rotateOnAxis:function(e,t){return Ba.setFromAxisAngle(e,t),this.quaternion.multiply(Ba),this},rotateOnWorldAxis:function(e,t){return Ba.setFromAxisAngle(e,t),this.quaternion.premultiply(Ba),this},rotateX:function(e){return this.rotateOnAxis(mT,e)},rotateY:function(e){return this.rotateOnAxis(gT,e)},rotateZ:function(e){return this.rotateOnAxis(yT,e)},translateOnAxis:function(e,t){return pT.copy(e).applyQuaternion(this.quaternion),this.position.add(pT.multiplyScalar(t)),this},translateX:function(e){return this.translateOnAxis(mT,e)},translateY:function(e){return this.translateOnAxis(gT,e)},translateZ:function(e){return this.translateOnAxis(yT,e)},localToWorld:function(e){return e.applyMatrix4(this.matrixWorld)},worldToLocal:function(e){return e.applyMatrix4(Qr.copy(this.matrixWorld).invert())},lookAt:function(e,t,n){e.isVector3?cf.copy(e):cf.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Tl.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Qr.lookAt(Tl,cf,this.up):Qr.lookAt(cf,Tl,this.up),this.quaternion.setFromRotationMatrix(Qr),i&&(Qr.extractRotation(i.matrixWorld),Ba.setFromRotationMatrix(Qr),this.quaternion.premultiply(Ba.invert()))},add:function(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(jB)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)},remove:function(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(vT)),this},clear:function(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(vT)}return this.children.length=0,this},attach:function(e){return this.updateWorldMatrix(!0,!1),Qr.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),Qr.multiply(e.parent.matrixWorld)),e.applyMatrix4(Qr),e.updateWorldMatrix(!1,!1),this.add(e),this},getObjectById:function(e){return this.getObjectByProperty("id",e)},getObjectByName:function(e){return this.getObjectByProperty("name",e)},getObjectByProperty:function(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const o=this.children[n].getObjectByProperty(e,t);if(void 0!==o)return o}},getWorldPosition:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new M),this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new On),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Tl,e,GB),e},getWorldScale:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new M),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Tl,zB,e),e},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new M),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)},traverseVisible:function(e){if(!1===this.visible)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)},traverseAncestors:function(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)},updateWorldMatrix:function(e,t){const n=this.parent;if(!0===e&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){const i=this.children;for(let r=0,o=i.length;r<o;r++)i[r].updateWorldMatrix(!1,!0)}},toJSON:function(e){const t=void 0===e||"string"==typeof e,n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function r(s,a){return void 0===s[a.uuid]&&(s[a.uuid]=a.toJSON(e)),a.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const s=this.geometry.parameters;if(void 0!==s&&void 0!==s.shapes){const a=s.shapes;if(Array.isArray(a))for(let c=0,l=a.length;c<l;c++)r(e.shapes,a[c]);else r(e.shapes,a)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const s=[];for(let a=0,c=this.material.length;a<c;a++)s.push(r(e.materials,this.material[a]));i.material=s}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let s=0;s<this.children.length;s++)i.children.push(this.children[s].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let s=0;s<this.animations.length;s++)i.animations.push(r(e.animations,this.animations[s]))}if(t){const s=o(e.geometries),a=o(e.materials),c=o(e.textures),l=o(e.images),d=o(e.shapes),u=o(e.skeletons),f=o(e.animations);s.length>0&&(n.geometries=s),a.length>0&&(n.materials=a),c.length>0&&(n.textures=c),l.length>0&&(n.images=l),d.length>0&&(n.shapes=d),u.length>0&&(n.skeletons=u),f.length>0&&(n.animations=f)}return n.object=i,n;function o(s){const a=[];for(const c in s){const l=s[c];delete l.metadata,a.push(l)}return a}},clone:function(e){return(new this.constructor).copy(this,e)},copy:function(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let n=0;n<e.children.length;n++)this.add(e.children[n].clone());return this}});const gy=new M,WB=new M,qB=new Zn;class wr{constructor(t,n){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=void 0!==t?t:new M(1,0,0),this.constant=void 0!==n?n:0}set(t,n){return this.normal.copy(t),this.constant=n,this}setComponents(t,n,i,r){return this.normal.set(t,n,i),this.constant=r,this}setFromNormalAndCoplanarPoint(t,n){return this.normal.copy(t),this.constant=-n.dot(this.normal),this}setFromCoplanarPoints(t,n,i){const r=gy.subVectors(i,n).cross(WB.subVectors(t,n)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,n){return void 0===n&&(console.warn("THREE.Plane: .projectPoint() target is now required"),n=new M),n.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,n){void 0===n&&(console.warn("THREE.Plane: .intersectLine() target is now required"),n=new M);const i=t.delta(gy),r=this.normal.dot(i);if(0===r)return 0===this.distanceToPoint(t.start)?n.copy(t.start):void 0;const o=-(t.start.dot(this.normal)+this.constant)/r;return o<0||o>1?void 0:n.copy(i).multiplyScalar(o).add(t.start)}intersectsLine(t){const n=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return n<0&&i>0||i<0&&n>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return void 0===t&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new M),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,n){const i=n||qB.getNormalMatrix(t),r=this.coplanarPoint(gy).applyMatrix4(t),o=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(o),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}const Ji=new M,Kr=new M,yy=new M,eo=new M,ka=new M,Ha=new M,_T=new M,vy=new M,_y=new M,xy=new M;class An{constructor(t,n,i){this.a=void 0!==t?t:new M,this.b=void 0!==n?n:new M,this.c=void 0!==i?i:new M}static getNormal(t,n,i,r){void 0===r&&(console.warn("THREE.Triangle: .getNormal() target is now required"),r=new M),r.subVectors(i,n),Ji.subVectors(t,n),r.cross(Ji);const o=r.lengthSq();return o>0?r.multiplyScalar(1/Math.sqrt(o)):r.set(0,0,0)}static getBarycoord(t,n,i,r,o){Ji.subVectors(r,n),Kr.subVectors(i,n),yy.subVectors(t,n);const s=Ji.dot(Ji),a=Ji.dot(Kr),c=Ji.dot(yy),l=Kr.dot(Kr),d=Kr.dot(yy),u=s*l-a*a;if(void 0===o&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),o=new M),0===u)return o.set(-2,-1,-1);const f=1/u,h=(l*c-a*d)*f,p=(s*d-a*c)*f;return o.set(1-h-p,p,h)}static containsPoint(t,n,i,r){return this.getBarycoord(t,n,i,r,eo),eo.x>=0&&eo.y>=0&&eo.x+eo.y<=1}static getUV(t,n,i,r,o,s,a,c){return this.getBarycoord(t,n,i,r,eo),c.set(0,0),c.addScaledVector(o,eo.x),c.addScaledVector(s,eo.y),c.addScaledVector(a,eo.z),c}static isFrontFacing(t,n,i,r){return Ji.subVectors(i,n),Kr.subVectors(t,n),Ji.cross(Kr).dot(r)<0}set(t,n,i){return this.a.copy(t),this.b.copy(n),this.c.copy(i),this}setFromPointsAndIndices(t,n,i,r){return this.a.copy(t[n]),this.b.copy(t[i]),this.c.copy(t[r]),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Ji.subVectors(this.c,this.b),Kr.subVectors(this.a,this.b),.5*Ji.cross(Kr).length()}getMidpoint(t){return void 0===t&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new M),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return An.getNormal(this.a,this.b,this.c,t)}getPlane(t){return void 0===t&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new wr),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,n){return An.getBarycoord(t,this.a,this.b,this.c,n)}getUV(t,n,i,r,o){return An.getUV(t,this.a,this.b,this.c,n,i,r,o)}containsPoint(t){return An.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return An.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,n){void 0===n&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),n=new M);const i=this.a,r=this.b,o=this.c;let s,a;ka.subVectors(r,i),Ha.subVectors(o,i),vy.subVectors(t,i);const c=ka.dot(vy),l=Ha.dot(vy);if(c<=0&&l<=0)return n.copy(i);_y.subVectors(t,r);const d=ka.dot(_y),u=Ha.dot(_y);if(d>=0&&u<=d)return n.copy(r);const f=c*u-d*l;if(f<=0&&c>=0&&d<=0)return s=c/(c-d),n.copy(i).addScaledVector(ka,s);xy.subVectors(t,o);const h=ka.dot(xy),p=Ha.dot(xy);if(p>=0&&h<=p)return n.copy(o);const y=h*l-c*p;if(y<=0&&l>=0&&p<=0)return a=l/(l-p),n.copy(i).addScaledVector(Ha,a);const v=d*p-h*u;if(v<=0&&u-d>=0&&h-p>=0)return _T.subVectors(o,r),a=(u-d)/(u-d+(h-p)),n.copy(r).addScaledVector(_T,a);const g=1/(v+y+f);return s=y*g,a=f*g,n.copy(i).addScaledVector(ka,s).addScaledVector(Ha,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const xT={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Qi={h:0,s:0,l:0},lf={h:0,s:0,l:0};function wy(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function by(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function My(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}let ae=(()=>{class e{constructor(n,i,r){return Object.defineProperty(this,"isColor",{value:!0}),void 0===i&&void 0===r?this.set(n):this.setRGB(n,i,r)}set(n){return n&&n.isColor?this.copy(n):"number"==typeof n?this.setHex(n):"string"==typeof n&&this.setStyle(n),this}setScalar(n){return this.r=n,this.g=n,this.b=n,this}setHex(n){return n=Math.floor(n),this.r=(n>>16&255)/255,this.g=(n>>8&255)/255,this.b=(255&n)/255,this}setRGB(n,i,r){return this.r=n,this.g=i,this.b=r,this}setHSL(n,i,r){if(n=ke.euclideanModulo(n,1),i=ke.clamp(i,0,1),r=ke.clamp(r,0,1),0===i)this.r=this.g=this.b=r;else{const o=r<=.5?r*(1+i):r+i-r*i,s=2*r-o;this.r=wy(s,o,n+1/3),this.g=wy(s,o,n),this.b=wy(s,o,n-1/3)}return this}setStyle(n){function i(o){void 0!==o&&parseFloat(o)<1&&console.warn("THREE.Color: Alpha component of "+n+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(n)){let o;const a=r[2];switch(r[1]){case"rgb":case"rgba":if(o=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(o[1],10))/255,this.g=Math.min(255,parseInt(o[2],10))/255,this.b=Math.min(255,parseInt(o[3],10))/255,i(o[4]),this;if(o=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(o[1],10))/100,this.g=Math.min(100,parseInt(o[2],10))/100,this.b=Math.min(100,parseInt(o[3],10))/100,i(o[4]),this;break;case"hsl":case"hsla":if(o=/^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const c=parseFloat(o[1])/360,l=parseInt(o[2],10)/100,d=parseInt(o[3],10)/100;return i(o[4]),this.setHSL(c,l,d)}}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(n)){const o=r[1],s=o.length;if(3===s)return this.r=parseInt(o.charAt(0)+o.charAt(0),16)/255,this.g=parseInt(o.charAt(1)+o.charAt(1),16)/255,this.b=parseInt(o.charAt(2)+o.charAt(2),16)/255,this;if(6===s)return this.r=parseInt(o.charAt(0)+o.charAt(1),16)/255,this.g=parseInt(o.charAt(2)+o.charAt(3),16)/255,this.b=parseInt(o.charAt(4)+o.charAt(5),16)/255,this}return n&&n.length>0?this.setColorName(n):this}setColorName(n){const i=xT[n];return void 0!==i?this.setHex(i):console.warn("THREE.Color: Unknown color "+n),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(n){return this.r=n.r,this.g=n.g,this.b=n.b,this}copyGammaToLinear(n,i=2){return this.r=Math.pow(n.r,i),this.g=Math.pow(n.g,i),this.b=Math.pow(n.b,i),this}copyLinearToGamma(n,i=2){const r=i>0?1/i:1;return this.r=Math.pow(n.r,r),this.g=Math.pow(n.g,r),this.b=Math.pow(n.b,r),this}convertGammaToLinear(n){return this.copyGammaToLinear(this,n),this}convertLinearToGamma(n){return this.copyLinearToGamma(this,n),this}copySRGBToLinear(n){return this.r=by(n.r),this.g=by(n.g),this.b=by(n.b),this}copyLinearToSRGB(n){return this.r=My(n.r),this.g=My(n.g),this.b=My(n.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(n){void 0===n&&(console.warn("THREE.Color: .getHSL() target is now required"),n={h:0,s:0,l:0});const i=this.r,r=this.g,o=this.b,s=Math.max(i,r,o),a=Math.min(i,r,o);let c,l;const d=(a+s)/2;if(a===s)c=0,l=0;else{const u=s-a;switch(l=d<=.5?u/(s+a):u/(2-s-a),s){case i:c=(r-o)/u+(r<o?6:0);break;case r:c=(o-i)/u+2;break;case o:c=(i-r)/u+4}c/=6}return n.h=c,n.s=l,n.l=d,n}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(n,i,r){return this.getHSL(Qi),Qi.h+=n,Qi.s+=i,Qi.l+=r,this.setHSL(Qi.h,Qi.s,Qi.l),this}add(n){return this.r+=n.r,this.g+=n.g,this.b+=n.b,this}addColors(n,i){return this.r=n.r+i.r,this.g=n.g+i.g,this.b=n.b+i.b,this}addScalar(n){return this.r+=n,this.g+=n,this.b+=n,this}sub(n){return this.r=Math.max(0,this.r-n.r),this.g=Math.max(0,this.g-n.g),this.b=Math.max(0,this.b-n.b),this}multiply(n){return this.r*=n.r,this.g*=n.g,this.b*=n.b,this}multiplyScalar(n){return this.r*=n,this.g*=n,this.b*=n,this}lerp(n,i){return this.r+=(n.r-this.r)*i,this.g+=(n.g-this.g)*i,this.b+=(n.b-this.b)*i,this}lerpHSL(n,i){this.getHSL(Qi),n.getHSL(lf);const r=ke.lerp(Qi.h,lf.h,i),o=ke.lerp(Qi.s,lf.s,i),s=ke.lerp(Qi.l,lf.l,i);return this.setHSL(r,o,s),this}equals(n){return n.r===this.r&&n.g===this.g&&n.b===this.b}fromArray(n,i=0){return this.r=n[i],this.g=n[i+1],this.b=n[i+2],this}toArray(n=[],i=0){return n[i]=this.r,n[i+1]=this.g,n[i+2]=this.b,n}fromBufferAttribute(n,i){return this.r=n.getX(i),this.g=n.getY(i),this.b=n.getZ(i),!0===n.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}return e.NAMES=xT,e})();ae.prototype.r=1,ae.prototype.g=1,ae.prototype.b=1;class Dl{constructor(t,n,i,r,o,s=0){this.a=t,this.b=n,this.c=i,this.normal=r&&r.isVector3?r:new M,this.vertexNormals=Array.isArray(r)?r:[],this.color=o&&o.isColor?o:new ae,this.vertexColors=Array.isArray(o)?o:[],this.materialIndex=s}clone(){return(new this.constructor).copy(this)}copy(t){this.a=t.a,this.b=t.b,this.c=t.c,this.normal.copy(t.normal),this.color.copy(t.color),this.materialIndex=t.materialIndex;for(let n=0,i=t.vertexNormals.length;n<i;n++)this.vertexNormals[n]=t.vertexNormals[n].clone();for(let n=0,i=t.vertexColors.length;n<i;n++)this.vertexColors[n]=t.vertexColors[n].clone();return this}}let $B=0;function Pe(){Object.defineProperty(this,"id",{value:$B++}),this.uuid=ke.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=Sa,this.side=Ea,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=zg,this.blendDst=jg,this.blendEquation=is,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=jd,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=lT,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ef,this.stencilZFail=ef,this.stencilZPass=ef,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}function Pi(e){Pe.call(this),this.type="MeshBasicMaterial",this.color=new ae(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ul,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}Pe.prototype=Object.assign(Object.create(_r.prototype),{constructor:Pe,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Bg;continue}const i=this[t];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}},toJSON:function(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function i(r){const o=[];for(const s in r){const a=r[s];delete a.metadata,o.push(a)}return o}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,n.reflectivity=this.reflectivity,n.refractionRatio=this.refractionRatio,void 0!==this.combine&&(n.combine=this.combine),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.size&&(n.size=this.size),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Sa&&(n.blending=this.blending),!0===this.flatShading&&(n.flatShading=this.flatShading),this.side!==Ea&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(n.morphTargets=!0),!0===this.morphNormals&&(n.morphNormals=!0),!0===this.skinning&&(n.skinning=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t){const r=i(e.textures),o=i(e.images);r.length>0&&(n.textures=r),o.length>0&&(n.images=o)}return n},clone:function(){return(new this.constructor).copy(this)},copy:function(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.flatShading=e.flatShading,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const i=t.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(Pe.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),(Pi.prototype=Object.create(Pe.prototype)).constructor=Pi,Pi.prototype.isMeshBasicMaterial=!0,Pi.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this};const Bt=new M,uf=new V;function Ee(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===n,this.usage=Ml,this.updateRange={offset:0,count:-1},this.version=0}function Cl(e,t,n){Ee.call(this,new Int8Array(e),t,n)}function Al(e,t,n){Ee.call(this,new Uint8Array(e),t,n)}function Il(e,t,n){Ee.call(this,new Uint8ClampedArray(e),t,n)}function Ll(e,t,n){Ee.call(this,new Int16Array(e),t,n)}function hs(e,t,n){Ee.call(this,new Uint16Array(e),t,n)}function Rl(e,t,n){Ee.call(this,new Int32Array(e),t,n)}function ps(e,t,n){Ee.call(this,new Uint32Array(e),t,n)}function Pl(e,t,n){Ee.call(this,new Uint16Array(e),t,n)}function te(e,t,n){Ee.call(this,new Float32Array(e),t,n)}function Fl(e,t,n){Ee.call(this,new Float64Array(e),t,n)}Object.defineProperty(Ee.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(Ee.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[n+i];return this},copyArray:function(e){return this.array.set(e),this},copyColorsArray:function(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let o=e[i];void 0===o&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),o=new ae),t[n++]=o.r,t[n++]=o.g,t[n++]=o.b}return this},copyVector2sArray:function(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let o=e[i];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),o=new V),t[n++]=o.x,t[n++]=o.y}return this},copyVector3sArray:function(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let o=e[i];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),o=new M),t[n++]=o.x,t[n++]=o.y,t[n++]=o.z}return this},copyVector4sArray:function(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let o=e[i];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),o=new It),t[n++]=o.x,t[n++]=o.y,t[n++]=o.z,t[n++]=o.w}return this},applyMatrix3:function(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++)uf.fromBufferAttribute(this,t),uf.applyMatrix3(e),this.setXY(t,uf.x,uf.y);else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++)Bt.fromBufferAttribute(this,t),Bt.applyMatrix3(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this},applyMatrix4:function(e){for(let t=0,n=this.count;t<n;t++)Bt.x=this.getX(t),Bt.y=this.getY(t),Bt.z=this.getZ(t),Bt.applyMatrix4(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this},applyNormalMatrix:function(e){for(let t=0,n=this.count;t<n;t++)Bt.x=this.getX(t),Bt.y=this.getY(t),Bt.z=this.getZ(t),Bt.applyNormalMatrix(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this},transformDirection:function(e){for(let t=0,n=this.count;t<n;t++)Bt.x=this.getX(t),Bt.y=this.getY(t),Bt.z=this.getZ(t),Bt.transformDirection(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this},set:function(e,t=0){return this.array.set(e,t),this},getX:function(e){return this.array[e*this.itemSize]},setX:function(e,t){return this.array[e*this.itemSize]=t,this},getY:function(e){return this.array[e*this.itemSize+1]},setY:function(e,t){return this.array[e*this.itemSize+1]=t,this},getZ:function(e){return this.array[e*this.itemSize+2]},setZ:function(e,t){return this.array[e*this.itemSize+2]=t,this},getW:function(e){return this.array[e*this.itemSize+3]},setW:function(e,t){return this.array[e*this.itemSize+3]=t,this},setXY:function(e,t,n){return this.array[0+(e*=this.itemSize)]=t,this.array[e+1]=n,this},setXYZ:function(e,t,n,i){return this.array[0+(e*=this.itemSize)]=t,this.array[e+1]=n,this.array[e+2]=i,this},setXYZW:function(e,t,n,i,r){return this.array[0+(e*=this.itemSize)]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=r,this},onUpload:function(e){return this.onUploadCallback=e,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),(Cl.prototype=Object.create(Ee.prototype)).constructor=Cl,(Al.prototype=Object.create(Ee.prototype)).constructor=Al,(Il.prototype=Object.create(Ee.prototype)).constructor=Il,(Ll.prototype=Object.create(Ee.prototype)).constructor=Ll,(hs.prototype=Object.create(Ee.prototype)).constructor=hs,(Rl.prototype=Object.create(Ee.prototype)).constructor=Rl,(ps.prototype=Object.create(Ee.prototype)).constructor=ps,(Pl.prototype=Object.create(Ee.prototype)).constructor=Pl,Pl.prototype.isFloat16BufferAttribute=!0,(te.prototype=Object.create(Ee.prototype)).constructor=te,(Fl.prototype=Object.create(Ee.prototype)).constructor=Fl;class XB{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(t){const n=[];let i,r,o;const s=t.faces;for(r=0;r<s.length;r++){const a=s[r];a.materialIndex!==o&&(o=a.materialIndex,void 0!==i&&(i.count=3*r-i.start,n.push(i)),i={start:3*r,materialIndex:o})}void 0!==i&&(i.count=3*r-i.start,n.push(i)),this.groups=n}fromGeometry(t){const n=t.faces,i=t.vertices,r=t.faceVertexUvs,o=r[0]&&r[0].length>0,s=r[1]&&r[1].length>0,a=t.morphTargets,c=a.length;let l;if(c>0){l=[];for(let g=0;g<c;g++)l[g]={name:a[g].name,data:[]};this.morphTargets.position=l}const d=t.morphNormals,u=d.length;let f;if(u>0){f=[];for(let g=0;g<u;g++)f[g]={name:d[g].name,data:[]};this.morphTargets.normal=f}const h=t.skinIndices,p=t.skinWeights,y=h.length===i.length,v=p.length===i.length;i.length>0&&0===n.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let g=0;g<n.length;g++){const m=n[g];this.vertices.push(i[m.a],i[m.b],i[m.c]);const _=m.vertexNormals;if(3===_.length)this.normals.push(_[0],_[1],_[2]);else{const b=m.normal;this.normals.push(b,b,b)}const w=m.vertexColors;if(3===w.length)this.colors.push(w[0],w[1],w[2]);else{const b=m.color;this.colors.push(b,b,b)}if(!0===o){const b=r[0][g];void 0!==b?this.uvs.push(b[0],b[1],b[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",g),this.uvs.push(new V,new V,new V))}if(!0===s){const b=r[1][g];void 0!==b?this.uvs2.push(b[0],b[1],b[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",g),this.uvs2.push(new V,new V,new V))}for(let b=0;b<c;b++){const x=a[b].vertices;l[b].data.push(x[m.a],x[m.b],x[m.c])}for(let b=0;b<u;b++){const x=d[b].vertexNormals[g];f[b].data.push(x.a,x.b,x.c)}y&&this.skinIndices.push(h[m.a],h[m.b],h[m.c]),v&&this.skinWeights.push(p[m.a],p[m.b],p[m.c])}return this.computeGroups(t),this.verticesNeedUpdate=t.verticesNeedUpdate,this.normalsNeedUpdate=t.normalsNeedUpdate,this.colorsNeedUpdate=t.colorsNeedUpdate,this.uvsNeedUpdate=t.uvsNeedUpdate,this.groupsNeedUpdate=t.groupsNeedUpdate,null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),this}}function wT(e){if(0===e.length)return-1/0;let t=e[0];for(let n=1,i=e.length;n<i;++n)e[n]>t&&(t=e[n]);return t}const YB={Int8Array,Uint8Array,Uint8ClampedArray:typeof Uint8ClampedArray<"u"?Uint8ClampedArray:Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Nl(e,t){return new YB[e](t)}let ZB=1;const br=new Ze,Ey=new ge,Va=new M,_i=new xr,Ol=new xr,Sn=new M;function Me(){Object.defineProperty(this,"id",{value:ZB+=2}),this.uuid=ke.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}Me.prototype=Object.assign(Object.create(_r.prototype),{constructor:Me,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(e){return this.index=Array.isArray(e)?new(wT(e)>65535?ps:hs)(e,1):e,this},getAttribute:function(e){return this.attributes[e]},setAttribute:function(e,t){return this.attributes[e]=t,this},deleteAttribute:function(e){return delete this.attributes[e],this},hasAttribute:function(e){return void 0!==this.attributes[e]},addGroup:function(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})},clearGroups:function(){this.groups=[]},setDrawRange:function(e,t){this.drawRange.start=e,this.drawRange.count=t},applyMatrix4:function(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const r=(new Zn).getNormalMatrix(e);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(e),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(e){return br.makeRotationX(e),this.applyMatrix4(br),this},rotateY:function(e){return br.makeRotationY(e),this.applyMatrix4(br),this},rotateZ:function(e){return br.makeRotationZ(e),this.applyMatrix4(br),this},translate:function(e,t,n){return br.makeTranslation(e,t,n),this.applyMatrix4(br),this},scale:function(e,t,n){return br.makeScale(e,t,n),this.applyMatrix4(br),this},lookAt:function(e){return Ey.lookAt(e),Ey.updateMatrix(),this.applyMatrix4(Ey.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Va).negate(),this.translate(Va.x,Va.y,Va.z),this},setFromObject:function(e){const t=e.geometry;if(e.isPoints||e.isLine){const n=new te(3*t.vertices.length,3),i=new te(3*t.colors.length,3);if(this.setAttribute("position",n.copyVector3sArray(t.vertices)),this.setAttribute("color",i.copyColorsArray(t.colors)),t.lineDistances&&t.lineDistances.length===t.vertices.length){const r=new te(t.lineDistances.length,1);this.setAttribute("lineDistance",r.copyArray(t.lineDistances))}null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone())}else e.isMesh&&t&&t.isGeometry&&this.fromGeometry(t);return this},setFromPoints:function(e){const t=[];for(let n=0,i=e.length;n<i;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new te(t,3)),this},updateFromObject:function(e){let t=e.geometry;if(e.isMesh){let n=t.__directGeometry;if(!0===t.elementsNeedUpdate&&(n=void 0,t.elementsNeedUpdate=!1),void 0===n)return this.fromGeometry(t);n.verticesNeedUpdate=t.verticesNeedUpdate,n.normalsNeedUpdate=t.normalsNeedUpdate,n.colorsNeedUpdate=t.colorsNeedUpdate,n.uvsNeedUpdate=t.uvsNeedUpdate,n.groupsNeedUpdate=t.groupsNeedUpdate,t.verticesNeedUpdate=!1,t.normalsNeedUpdate=!1,t.colorsNeedUpdate=!1,t.uvsNeedUpdate=!1,t.groupsNeedUpdate=!1,t=n}if(!0===t.verticesNeedUpdate){const n=this.attributes.position;void 0!==n&&(n.copyVector3sArray(t.vertices),n.needsUpdate=!0),t.verticesNeedUpdate=!1}if(!0===t.normalsNeedUpdate){const n=this.attributes.normal;void 0!==n&&(n.copyVector3sArray(t.normals),n.needsUpdate=!0),t.normalsNeedUpdate=!1}if(!0===t.colorsNeedUpdate){const n=this.attributes.color;void 0!==n&&(n.copyColorsArray(t.colors),n.needsUpdate=!0),t.colorsNeedUpdate=!1}if(t.uvsNeedUpdate){const n=this.attributes.uv;void 0!==n&&(n.copyVector2sArray(t.uvs),n.needsUpdate=!0),t.uvsNeedUpdate=!1}if(t.lineDistancesNeedUpdate){const n=this.attributes.lineDistance;void 0!==n&&(n.copyArray(t.lineDistances),n.needsUpdate=!0),t.lineDistancesNeedUpdate=!1}return t.groupsNeedUpdate&&(t.computeGroups(e.geometry),this.groups=t.groups,t.groupsNeedUpdate=!1),this},fromGeometry:function(e){return e.__directGeometry=(new XB).fromGeometry(e),this.fromDirectGeometry(e.__directGeometry)},fromDirectGeometry:function(e){const t=new Float32Array(3*e.vertices.length);if(this.setAttribute("position",new Ee(t,3).copyVector3sArray(e.vertices)),e.normals.length>0){const n=new Float32Array(3*e.normals.length);this.setAttribute("normal",new Ee(n,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const n=new Float32Array(3*e.colors.length);this.setAttribute("color",new Ee(n,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const n=new Float32Array(2*e.uvs.length);this.setAttribute("uv",new Ee(n,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const n=new Float32Array(2*e.uvs2.length);this.setAttribute("uv2",new Ee(n,2).copyVector2sArray(e.uvs2))}this.groups=e.groups;for(const n in e.morphTargets){const i=[],r=e.morphTargets[n];for(let o=0,s=r.length;o<s;o++){const a=r[o],c=new te(3*a.data.length,3);c.name=a.name,i.push(c.copyVector3sArray(a.data))}this.morphAttributes[n]=i}if(e.skinIndices.length>0){const n=new te(4*e.skinIndices.length,4);this.setAttribute("skinIndex",n.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const n=new te(4*e.skinWeights.length,4);this.setAttribute("skinWeight",n.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new xr);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new M(-1/0,-1/0,-1/0),new M(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++)_i.setFromBufferAttribute(t[n]),this.morphTargetsRelative?(Sn.addVectors(this.boundingBox.min,_i.min),this.boundingBox.expandByPoint(Sn),Sn.addVectors(this.boundingBox.max,_i.max),this.boundingBox.expandByPoint(Sn)):(this.boundingBox.expandByPoint(_i.min),this.boundingBox.expandByPoint(_i.max))}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Zr);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new M,1/0);if(e){const n=this.boundingSphere.center;if(_i.setFromBufferAttribute(e),t)for(let r=0,o=t.length;r<o;r++)Ol.setFromBufferAttribute(t[r]),this.morphTargetsRelative?(Sn.addVectors(_i.min,Ol.min),_i.expandByPoint(Sn),Sn.addVectors(_i.max,Ol.max),_i.expandByPoint(Sn)):(_i.expandByPoint(Ol.min),_i.expandByPoint(Ol.max));_i.getCenter(n);let i=0;for(let r=0,o=e.count;r<o;r++)Sn.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(Sn));if(t)for(let r=0,o=t.length;r<o;r++){const s=t[r],a=this.morphTargetsRelative;for(let c=0,l=s.count;c<l;c++)Sn.fromBufferAttribute(s,c),a&&(Va.fromBufferAttribute(e,c),Sn.add(Va)),i=Math.max(i,n.distanceToSquared(Sn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeVertexNormals:function(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n)n=new Ee(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let u=0,f=n.count;u<f;u++)n.setXYZ(u,0,0,0);const i=new M,r=new M,o=new M,s=new M,a=new M,c=new M,l=new M,d=new M;if(e)for(let u=0,f=e.count;u<f;u+=3){const h=e.getX(u+0),p=e.getX(u+1),y=e.getX(u+2);i.fromBufferAttribute(t,h),r.fromBufferAttribute(t,p),o.fromBufferAttribute(t,y),l.subVectors(o,r),d.subVectors(i,r),l.cross(d),s.fromBufferAttribute(n,h),a.fromBufferAttribute(n,p),c.fromBufferAttribute(n,y),s.add(l),a.add(l),c.add(l),n.setXYZ(h,s.x,s.y,s.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(y,c.x,c.y,c.z)}else for(let u=0,f=t.count;u<f;u+=3)i.fromBufferAttribute(t,u+0),r.fromBufferAttribute(t,u+1),o.fromBufferAttribute(t,u+2),l.subVectors(o,r),d.subVectors(i,r),l.cross(d),n.setXYZ(u+0,l.x,l.y,l.z),n.setXYZ(u+1,l.x,l.y,l.z),n.setXYZ(u+2,l.x,l.y,l.z);this.normalizeNormals(),n.needsUpdate=!0}},merge:function(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(void 0===e.attributes[i])continue;const o=n[i].array,s=e.attributes[i],a=s.array,c=s.itemSize*t,l=Math.min(a.length,o.length-c);for(let d=0,u=c;d<l;d++,u++)o[u]=a[d]}return this},normalizeNormals:function(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Sn.fromBufferAttribute(e,t),Sn.normalize(),e.setXYZ(t,Sn.x,Sn.y,Sn.z)},toNonIndexed:function(){function e(s,a){const c=s.array,l=s.itemSize,d=s.normalized,u=new c.constructor(a.length*l);let f=0,h=0;for(let p=0,y=a.length;p<y;p++){f=a[p]*l;for(let v=0;v<l;v++)u[h++]=c[f++]}return new Ee(u,l,d)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),this;const t=new Me,n=this.index.array,i=this.attributes;for(const s in i){const c=e(i[s],n);t.setAttribute(s,c)}const r=this.morphAttributes;for(const s in r){const a=[],c=r[s];for(let l=0,d=c.length;l<d;l++){const f=e(c[l],n);a.push(f)}t.morphAttributes[s]=a}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let s=0,a=o.length;s<a;s++){const c=o[s];t.addGroup(c.start,c.count,c.materialIndex)}return t},toJSON:function(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const a=this.parameters;for(const c in a)void 0!==a[c]&&(e[c]=a[c]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const a in n){const c=n[a],l=c.toJSON(e.data);""!==c.name&&(l.name=c.name),e.data.attributes[a]=l}const i={};let r=!1;for(const a in this.morphAttributes){const c=this.morphAttributes[a],l=[];for(let d=0,u=c.length;d<u;d++){const f=c[d],h=f.toJSON(e.data);""!==f.name&&(h.name=f.name),l.push(h)}l.length>0&&(i[a]=l,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const s=this.boundingSphere;return null!==s&&(e.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),e},clone:function(){return(new Me).copy(this)},copy:function(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone(t));const i=e.attributes;for(const c in i)this.setAttribute(c,i[c].clone(t));const r=e.morphAttributes;for(const c in r){const l=[],d=r[c];for(let u=0,f=d.length;u<f;u++)l.push(d[u].clone(t));this.morphAttributes[c]=l}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,l=o.length;c<l;c++){const d=o[c];this.addGroup(d.start,d.count,d.materialIndex)}const s=e.boundingBox;null!==s&&(this.boundingBox=s.clone());const a=e.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const bT=new Ze,ms=new Na,Sy=new Zr,To=new M,Do=new M,Co=new M,Ty=new M,Dy=new M,Cy=new M,df=new M,ff=new M,hf=new M,Ua=new V,Ga=new V,za=new V,Bl=new M,pf=new M;function Gt(e=new Me,t=new Pi){ge.call(this),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}function MT(e,t,n,i,r,o,s,a){let c;if(c=t.side===wn?i.intersectTriangle(s,o,r,!0,a):i.intersectTriangle(r,o,s,t.side!==ll,a),null===c)return null;pf.copy(a),pf.applyMatrix4(e.matrixWorld);const l=n.ray.origin.distanceTo(pf);return l<n.near||l>n.far?null:{distance:l,point:pf.clone(),object:e}}function mf(e,t,n,i,r,o,s,a,c,l,d,u){To.fromBufferAttribute(r,l),Do.fromBufferAttribute(r,d),Co.fromBufferAttribute(r,u);const f=e.morphTargetInfluences;if(t.morphTargets&&o&&f){df.set(0,0,0),ff.set(0,0,0),hf.set(0,0,0);for(let p=0,y=o.length;p<y;p++){const v=f[p],g=o[p];0!==v&&(Ty.fromBufferAttribute(g,l),Dy.fromBufferAttribute(g,d),Cy.fromBufferAttribute(g,u),s?(df.addScaledVector(Ty,v),ff.addScaledVector(Dy,v),hf.addScaledVector(Cy,v)):(df.addScaledVector(Ty.sub(To),v),ff.addScaledVector(Dy.sub(Do),v),hf.addScaledVector(Cy.sub(Co),v)))}To.add(df),Do.add(ff),Co.add(hf)}e.isSkinnedMesh&&(e.boneTransform(l,To),e.boneTransform(d,Do),e.boneTransform(u,Co));const h=MT(e,t,n,i,To,Do,Co,Bl);if(h){a&&(Ua.fromBufferAttribute(a,l),Ga.fromBufferAttribute(a,d),za.fromBufferAttribute(a,u),h.uv=An.getUV(Bl,To,Do,Co,Ua,Ga,za,new V)),c&&(Ua.fromBufferAttribute(c,l),Ga.fromBufferAttribute(c,d),za.fromBufferAttribute(c,u),h.uv2=An.getUV(Bl,To,Do,Co,Ua,Ga,za,new V));const p=new Dl(l,d,u);An.getNormal(To,Do,Co,p.normal),h.face=p}return h}Gt.prototype=Object.assign(Object.create(ge.prototype),{constructor:Gt,isMesh:!0,copy:function(e){return ge.prototype.copy.call(this,e),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const s=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[s]=r}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(e,t){const n=this.geometry,i=this.material,r=this.matrixWorld;if(void 0===i||(null===n.boundingSphere&&n.computeBoundingSphere(),Sy.copy(n.boundingSphere),Sy.applyMatrix4(r),!1===e.ray.intersectsSphere(Sy))||(bT.copy(r).invert(),ms.copy(e.ray).applyMatrix4(bT),null!==n.boundingBox&&!1===ms.intersectsBox(n.boundingBox)))return;let o;if(n.isBufferGeometry){const s=n.index,a=n.attributes.position,c=n.morphAttributes.position,l=n.morphTargetsRelative,d=n.attributes.uv,u=n.attributes.uv2,f=n.groups,h=n.drawRange;if(null!==s)if(Array.isArray(i))for(let p=0,y=f.length;p<y;p++){const v=f[p],g=i[v.materialIndex];for(let w=Math.max(v.start,h.start),b=Math.min(v.start+v.count,h.start+h.count);w<b;w+=3){const x=s.getX(w),D=s.getX(w+1),I=s.getX(w+2);o=mf(this,g,e,ms,a,c,l,d,u,x,D,I),o&&(o.faceIndex=Math.floor(w/3),o.face.materialIndex=v.materialIndex,t.push(o))}}else for(let v=Math.max(0,h.start),g=Math.min(s.count,h.start+h.count);v<g;v+=3){const m=s.getX(v),_=s.getX(v+1),w=s.getX(v+2);o=mf(this,i,e,ms,a,c,l,d,u,m,_,w),o&&(o.faceIndex=Math.floor(v/3),t.push(o))}else if(void 0!==a)if(Array.isArray(i))for(let p=0,y=f.length;p<y;p++){const v=f[p],g=i[v.materialIndex];for(let w=Math.max(v.start,h.start),b=Math.min(v.start+v.count,h.start+h.count);w<b;w+=3)o=mf(this,g,e,ms,a,c,l,d,u,w,w+1,w+2),o&&(o.faceIndex=Math.floor(w/3),o.face.materialIndex=v.materialIndex,t.push(o))}else for(let v=Math.max(0,h.start),g=Math.min(a.count,h.start+h.count);v<g;v+=3)o=mf(this,i,e,ms,a,c,l,d,u,v,v+1,v+2),o&&(o.faceIndex=Math.floor(v/3),t.push(o))}else if(n.isGeometry){const s=Array.isArray(i),a=n.vertices,c=n.faces;let l;const d=n.faceVertexUvs[0];d.length>0&&(l=d);for(let u=0,f=c.length;u<f;u++){const h=c[u],p=s?i[h.materialIndex]:i;if(void 0===p)continue;const y=a[h.a],v=a[h.b],g=a[h.c];if(o=MT(this,p,e,ms,y,v,g,Bl),o){if(l&&l[u]){const m=l[u];Ua.copy(m[0]),Ga.copy(m[1]),za.copy(m[2]),o.uv=An.getUV(Bl,y,v,g,Ua,Ga,za,new V)}o.face=h,o.faceIndex=u,t.push(o)}}}}});class kl extends Me{constructor(t=1,n=1,i=1,r=1,o=1,s=1){super(),this.type="BoxBufferGeometry",this.parameters={width:t,height:n,depth:i,widthSegments:r,heightSegments:o,depthSegments:s};const a=this;r=Math.floor(r),o=Math.floor(o),s=Math.floor(s);const c=[],l=[],d=[],u=[];let f=0,h=0;function p(y,v,g,m,_,w,b,x,D,I,R){const U=w/D,P=b/I,F=w/2,N=b/2,L=x/2,A=D+1,B=I+1;let W=0,Y=0;const oe=new M;for(let he=0;he<B;he++){const ue=he*P-N;for(let Je=0;Je<A;Je++)oe[y]=(Je*U-F)*m,oe[v]=ue*_,oe[g]=L,l.push(oe.x,oe.y,oe.z),oe[y]=0,oe[v]=0,oe[g]=x>0?1:-1,d.push(oe.x,oe.y,oe.z),u.push(Je/D),u.push(1-he/I),W+=1}for(let he=0;he<I;he++)for(let ue=0;ue<D;ue++){const nt=f+ue+A*(he+1),Qt=f+(ue+1)+A*(he+1),z=f+(ue+1)+A*he;c.push(f+ue+A*he,nt,z),c.push(nt,Qt,z),Y+=6}a.addGroup(h,Y,R),h+=Y,f+=W}p("z","y","x",-1,-1,i,n,t,s,o,0),p("z","y","x",1,-1,i,n,-t,s,o,1),p("x","z","y",1,1,t,i,n,r,s,2),p("x","z","y",1,-1,t,i,-n,r,s,3),p("x","y","z",1,-1,t,n,i,r,o,4),p("x","y","z",-1,-1,t,n,-i,r,o,5),this.setIndex(c),this.setAttribute("position",new te(l,3)),this.setAttribute("normal",new te(d,3)),this.setAttribute("uv",new te(u,2))}}function ja(e){const t={};for(const n in e){t[n]={};for(const i in e[n]){const r=e[n][i];t[n][i]=r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture)?r.clone():Array.isArray(r)?r.slice():r}}return t}function Bn(e){const t={};for(let n=0;n<e.length;n++){const i=ja(e[n]);for(const r in i)t[r]=i[r]}return t}const ET={clone:ja,merge:Bn};function Jn(e){Pe.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}function Mr(){ge.call(this),this.type="Camera",this.matrixWorldInverse=new Ze,this.projectionMatrix=new Ze,this.projectionMatrixInverse=new Ze}function pn(e=50,t=1,n=.1,i=2e3){Mr.call(this),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}function gs(e,t,n){if(ge.call(this),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const i=new pn(90,1,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new M(1,0,0)),this.add(i);const r=new pn(90,1,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new M(-1,0,0)),this.add(r);const o=new pn(90,1,e,t);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new M(0,1,0)),this.add(o);const s=new pn(90,1,e,t);s.layers=this.layers,s.up.set(0,0,-1),s.lookAt(new M(0,-1,0)),this.add(s);const a=new pn(90,1,e,t);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new M(0,0,1)),this.add(a);const c=new pn(90,1,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new M(0,0,-1)),this.add(c),this.update=function(l,d){null===this.parent&&this.updateMatrixWorld();const u=l.xr.enabled,f=l.getRenderTarget();l.xr.enabled=!1;const h=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,l.setRenderTarget(n,0),l.render(d,i),l.setRenderTarget(n,1),l.render(d,r),l.setRenderTarget(n,2),l.render(d,o),l.setRenderTarget(n,3),l.render(d,s),l.setRenderTarget(n,4),l.render(d,a),n.texture.generateMipmaps=h,l.setRenderTarget(n,5),l.render(d,c),l.setRenderTarget(f),l.xr.enabled=u}}function Er(e,t,n,i,r,o,s,a,c,l){At.call(this,e=void 0!==e?e:[],t=void 0!==t?t:dl,n,i,r,o,s=void 0!==s?s:wo,a,c,l),this.flipY=!1,this._needsFlipEnvMap=!0}function to(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),yi.call(this,e,e,t),this.texture=new Er(void 0,(t=t||{}).mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture._needsFlipEnvMap=!1}function no(e,t,n,i,r,o,s,a,c,l,d,u){At.call(this,null,o,s,a,c,l,i,r,d,u),this.image={data:e||null,width:t||1,height:n||1},this.magFilter=void 0!==c?c:bn,this.minFilter=void 0!==l?l:bn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}(Jn.prototype=Object.create(Pe.prototype)).constructor=Jn,Jn.prototype.isShaderMaterial=!0,Jn.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=ja(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this},Jn.prototype.toJSON=function(e){const t=Pe.prototype.toJSON.call(this,e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;t.uniforms[i]=o&&o.isTexture?{type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?{type:"c",value:o.getHex()}:o&&o.isVector2?{type:"v2",value:o.toArray()}:o&&o.isVector3?{type:"v3",value:o.toArray()}:o&&o.isVector4?{type:"v4",value:o.toArray()}:o&&o.isMatrix3?{type:"m3",value:o.toArray()}:o&&o.isMatrix4?{type:"m4",value:o.toArray()}:{value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)!0===this.extensions[i]&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t},Mr.prototype=Object.assign(Object.create(ge.prototype),{constructor:Mr,isCamera:!0,copy:function(e,t){return ge.prototype.copy.call(this,e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new M),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(e){ge.prototype.updateMatrixWorld.call(this,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(e,t){ge.prototype.updateWorldMatrix.call(this,e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return(new this.constructor).copy(this)}}),pn.prototype=Object.assign(Object.create(Mr.prototype),{constructor:pn,isPerspectiveCamera:!0,copy:function(e,t){return Mr.prototype.copy.call(this,e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this},setFocalLength:function(e){const t=.5*this.getFilmHeight()/e;this.fov=2*ke.RAD2DEG*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){const e=Math.tan(.5*ke.DEG2RAD*this.fov);return.5*this.getFilmHeight()/e},getEffectiveFOV:function(){return 2*ke.RAD2DEG*Math.atan(Math.tan(.5*ke.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(e,t,n,i,r,o){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=this.near;let t=e*Math.tan(.5*ke.DEG2RAD*this.fov)/this.zoom,n=2*t,i=this.aspect*n,r=-.5*i;const o=this.view;if(null!==this.view&&this.view.enabled){const a=o.fullWidth,c=o.fullHeight;r+=o.offsetX*i/a,t-=o.offsetY*n/c,i*=o.width/a,n*=o.height/c}const s=this.filmOffset;0!==s&&(r+=e*s/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(e){const t=ge.prototype.toJSON.call(this,e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}),(gs.prototype=Object.create(ge.prototype)).constructor=gs,(Er.prototype=Object.create(At.prototype)).constructor=Er,Er.prototype.isCubeTexture=!0,Object.defineProperty(Er.prototype,"images",{get:function(){return this.image},set:function(e){this.image=e}}),(to.prototype=Object.create(yi.prototype)).constructor=to,to.prototype.isWebGLCubeRenderTarget=!0,to.prototype.fromEquirectangularTexture=function(e,t){this.texture.type=t.type,this.texture.format=gi,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n_uniforms={tEquirect:{value:null}},n_vertexShader="\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",n_fragmentShader="\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t",i=new kl(5,5,5),r=new Jn({name:"CubemapFromEquirect",uniforms:ja(n_uniforms),vertexShader:n_vertexShader,fragmentShader:n_fragmentShader,side:wn,blending:$r});r.uniforms.tEquirect.value=t;const o=new Gt(i,r),s=t.minFilter;return t.minFilter===Da&&(t.minFilter=En),new gs(1,10,this).update(e,o),t.minFilter=s,o.geometry.dispose(),o.material.dispose(),this},to.prototype.clear=function(e,t,n,i){const r=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,n,i);e.setRenderTarget(r)},(no.prototype=Object.create(At.prototype)).constructor=no,no.prototype.isDataTexture=!0;const $a=new Zr,gf=new M;class Hl{constructor(t,n,i,r,o,s){this.planes=[void 0!==t?t:new wr,void 0!==n?n:new wr,void 0!==i?i:new wr,void 0!==r?r:new wr,void 0!==o?o:new wr,void 0!==s?s:new wr]}set(t,n,i,r,o,s){const a=this.planes;return a[0].copy(t),a[1].copy(n),a[2].copy(i),a[3].copy(r),a[4].copy(o),a[5].copy(s),this}clone(){return(new this.constructor).copy(this)}copy(t){const n=this.planes;for(let i=0;i<6;i++)n[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t){const n=this.planes,i=t.elements,r=i[0],o=i[1],s=i[2],a=i[3],c=i[4],l=i[5],d=i[6],u=i[7],f=i[8],h=i[9],p=i[10],y=i[11],v=i[12],g=i[13],m=i[14],_=i[15];return n[0].setComponents(a-r,u-c,y-f,_-v).normalize(),n[1].setComponents(a+r,u+c,y+f,_+v).normalize(),n[2].setComponents(a+o,u+l,y+h,_+g).normalize(),n[3].setComponents(a-o,u-l,y-h,_-g).normalize(),n[4].setComponents(a-s,u-d,y-p,_-m).normalize(),n[5].setComponents(a+s,u+d,y+p,_+m).normalize(),this}intersectsObject(t){const n=t.geometry;return null===n.boundingSphere&&n.computeBoundingSphere(),$a.copy(n.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere($a)}intersectsSprite(t){return $a.center.set(0,0,0),$a.radius=.7071067811865476,$a.applyMatrix4(t.matrixWorld),this.intersectsSphere($a)}intersectsSphere(t){const n=this.planes,i=t.center,r=-t.radius;for(let o=0;o<6;o++)if(n[o].distanceToPoint(i)<r)return!1;return!0}intersectsBox(t){const n=this.planes;for(let i=0;i<6;i++){const r=n[i];if(gf.x=r.normal.x>0?t.max.x:t.min.x,gf.y=r.normal.y>0?t.max.y:t.min.y,gf.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint(gf)<0)return!1}return!0}containsPoint(t){const n=this.planes;for(let i=0;i<6;i++)if(n[i].distanceToPoint(t)<0)return!1;return!0}}function ST(){let e=null,t=!1,n=null,i=null;function r(o,s){n(o,s),i=e.requestAnimationFrame(r)}return{start:function(){!0!==t&&null!==n&&(i=e.requestAnimationFrame(r),t=!0)},stop:function(){e.cancelAnimationFrame(i),t=!1},setAnimationLoop:function(o){n=o},setContext:function(o){e=o}}}function KB(e,t){const n=t.isWebGL2,i=new WeakMap;return{get:function s(l){return l.isInterleavedBufferAttribute&&(l=l.data),i.get(l)},remove:function a(l){l.isInterleavedBufferAttribute&&(l=l.data);const d=i.get(l);d&&(e.deleteBuffer(d.buffer),i.delete(l))},update:function c(l,d){if(l.isGLBufferAttribute){const f=i.get(l);return void((!f||f.version<l.version)&&i.set(l,{buffer:l.buffer,type:l.type,bytesPerElement:l.elementSize,version:l.version}))}l.isInterleavedBufferAttribute&&(l=l.data);const u=i.get(l);void 0===u?i.set(l,function r(l,d){const u=l.array,f=l.usage,h=e.createBuffer();e.bindBuffer(d,h),e.bufferData(d,u,f),l.onUploadCallback();let p=5126;return u instanceof Float32Array?p=5126:u instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):u instanceof Uint16Array?l.isFloat16BufferAttribute?n?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:u instanceof Int16Array?p=5122:u instanceof Uint32Array?p=5125:u instanceof Int32Array?p=5124:u instanceof Int8Array?p=5120:u instanceof Uint8Array&&(p=5121),{buffer:h,type:p,bytesPerElement:u.BYTES_PER_ELEMENT,version:l.version}}(l,d)):u.version<l.version&&(function o(l,d,u){const f=d.array,h=d.updateRange;e.bindBuffer(u,l),-1===h.count?e.bufferSubData(u,0,f):(n?e.bufferSubData(u,h.offset*f.BYTES_PER_ELEMENT,f,h.offset,h.count):e.bufferSubData(u,h.offset*f.BYTES_PER_ELEMENT,f.subarray(h.offset,h.offset+h.count)),h.count=-1)}(u.buffer,l,d),u.version=l.version)}}}class yf extends Me{constructor(t=1,n=1,i=1,r=1){super(),this.type="PlaneBufferGeometry",this.parameters={width:t,height:n,widthSegments:i,heightSegments:r};const o=t/2,s=n/2,a=Math.floor(i),c=Math.floor(r),l=a+1,d=c+1,u=t/a,f=n/c,h=[],p=[],y=[],v=[];for(let g=0;g<d;g++){const m=g*f-s;for(let _=0;_<l;_++)p.push(_*u-o,-m,0),y.push(0,0,1),v.push(_/a),v.push(1-g/c)}for(let g=0;g<c;g++)for(let m=0;m<a;m++){const w=m+l*(g+1),b=m+1+l*(g+1),x=m+1+l*g;h.push(m+l*g,w,x),h.push(w,b,x)}this.setIndex(h),this.setAttribute("position",new te(p,3)),this.setAttribute("normal",new te(y,3)),this.setAttribute("uv",new te(v,2))}}const ct={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},J={common:{diffuse:{value:new ae(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Zn},uv2Transform:{value:new Zn},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new V(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ae(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ae(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Zn}},sprite:{diffuse:{value:new ae(15658734)},opacity:{value:1},center:{value:new V(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Zn}}},Ki={basic:{uniforms:Bn([J.common,J.specularmap,J.envmap,J.aomap,J.lightmap,J.fog]),vertexShader:ct.meshbasic_vert,fragmentShader:ct.meshbasic_frag},lambert:{uniforms:Bn([J.common,J.specularmap,J.envmap,J.aomap,J.lightmap,J.emissivemap,J.fog,J.lights,{emissive:{value:new ae(0)}}]),vertexShader:ct.meshlambert_vert,fragmentShader:ct.meshlambert_frag},phong:{uniforms:Bn([J.common,J.specularmap,J.envmap,J.aomap,J.lightmap,J.emissivemap,J.bumpmap,J.normalmap,J.displacementmap,J.fog,J.lights,{emissive:{value:new ae(0)},specular:{value:new ae(1118481)},shininess:{value:30}}]),vertexShader:ct.meshphong_vert,fragmentShader:ct.meshphong_frag},standard:{uniforms:Bn([J.common,J.envmap,J.aomap,J.lightmap,J.emissivemap,J.bumpmap,J.normalmap,J.displacementmap,J.roughnessmap,J.metalnessmap,J.fog,J.lights,{emissive:{value:new ae(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ct.meshphysical_vert,fragmentShader:ct.meshphysical_frag},toon:{uniforms:Bn([J.common,J.aomap,J.lightmap,J.emissivemap,J.bumpmap,J.normalmap,J.displacementmap,J.gradientmap,J.fog,J.lights,{emissive:{value:new ae(0)}}]),vertexShader:ct.meshtoon_vert,fragmentShader:ct.meshtoon_frag},matcap:{uniforms:Bn([J.common,J.bumpmap,J.normalmap,J.displacementmap,J.fog,{matcap:{value:null}}]),vertexShader:ct.meshmatcap_vert,fragmentShader:ct.meshmatcap_frag},points:{uniforms:Bn([J.points,J.fog]),vertexShader:ct.points_vert,fragmentShader:ct.points_frag},dashed:{uniforms:Bn([J.common,J.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ct.linedashed_vert,fragmentShader:ct.linedashed_frag},depth:{uniforms:Bn([J.common,J.displacementmap]),vertexShader:ct.depth_vert,fragmentShader:ct.depth_frag},normal:{uniforms:Bn([J.common,J.bumpmap,J.normalmap,J.displacementmap,{opacity:{value:1}}]),vertexShader:ct.normal_vert,fragmentShader:ct.normal_frag},sprite:{uniforms:Bn([J.sprite,J.fog]),vertexShader:ct.sprite_vert,fragmentShader:ct.sprite_frag},background:{uniforms:{uvTransform:{value:new Zn},t2D:{value:null}},vertexShader:ct.background_vert,fragmentShader:ct.background_frag},cube:{uniforms:Bn([J.envmap,{opacity:{value:1}}]),vertexShader:ct.cube_vert,fragmentShader:ct.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ct.equirect_vert,fragmentShader:ct.equirect_frag},distanceRGBA:{uniforms:Bn([J.common,J.displacementmap,{referencePosition:{value:new M},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ct.distanceRGBA_vert,fragmentShader:ct.distanceRGBA_frag},shadow:{uniforms:Bn([J.lights,J.fog,{color:{value:new ae(0)},opacity:{value:1}}]),vertexShader:ct.shadow_vert,fragmentShader:ct.shadow_frag}};function wV(e,t,n,i,r){const o=new ae(0);let a,c,s=0,l=null,d=0,u=null;function h(p,y){n.buffers.color.setClear(p.r,p.g,p.b,y,r)}return{getClearColor:function(){return o},setClearColor:function(p,y=1){o.set(p),s=y,h(o,s)},getClearAlpha:function(){return s},setClearAlpha:function(p){s=p,h(o,s)},render:function f(p,y,v,g){let m=!0===y.isScene?y.background:null;m&&m.isTexture&&(m=t.get(m));const _=e.xr,w=_.getSession&&_.getSession();w&&"additive"===w.environmentBlendMode&&(m=null),null===m?h(o,s):m&&m.isColor&&(h(m,1),g=!0),(e.autoClear||g)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),m&&(m.isCubeTexture||m.isWebGLCubeRenderTarget||m.mapping===Ta)?(void 0===c&&(c=new Gt(new kl(1,1,1),new Jn({name:"BackgroundCubeMaterial",uniforms:ja(Ki.cube.uniforms),vertexShader:Ki.cube.vertexShader,fragmentShader:Ki.cube.fragmentShader,side:wn,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(b,x,D){this.matrixWorld.copyPosition(D.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),m.isWebGLCubeRenderTarget&&(m=m.texture),c.material.uniforms.envMap.value=m,c.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m._needsFlipEnvMap?-1:1,(l!==m||d!==m.version||u!==e.toneMapping)&&(c.material.needsUpdate=!0,l=m,d=m.version,u=e.toneMapping),p.unshift(c,c.geometry,c.material,0,0,null)):m&&m.isTexture&&(void 0===a&&(a=new Gt(new yf(2,2),new Jn({name:"BackgroundMaterial",uniforms:ja(Ki.background.uniforms),vertexShader:Ki.background.vertexShader,fragmentShader:Ki.background.fragmentShader,side:Ea,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(a)),a.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),a.material.uniforms.uvTransform.value.copy(m.matrix),(l!==m||d!==m.version||u!==e.toneMapping)&&(a.material.needsUpdate=!0,l=m,d=m.version,u=e.toneMapping),p.unshift(a,a.geometry,a.material,0,0,null))}}}function bV(e,t,n,i){const r=e.getParameter(34921),o=i.isWebGL2?null:t.get("OES_vertex_array_object"),s=i.isWebGL2||null!==o,a={},c=y(null);let l=c;function f(N){return i.isWebGL2?e.bindVertexArray(N):o.bindVertexArrayOES(N)}function h(N){return i.isWebGL2?e.deleteVertexArray(N):o.deleteVertexArrayOES(N)}function y(N){const L=[],A=[],B=[];for(let W=0;W<r;W++)L[W]=0,A[W]=0,B[W]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:L,enabledAttributes:A,attributeDivisors:B,object:N,attributes:{},index:null}}function m(){const N=l.newAttributes;for(let L=0,A=N.length;L<A;L++)N[L]=0}function _(N){w(N,0)}function w(N,L){const B=l.enabledAttributes,W=l.attributeDivisors;l.newAttributes[N]=1,0===B[N]&&(e.enableVertexAttribArray(N),B[N]=1),W[N]!==L&&((i.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](N,L),W[N]=L)}function b(){const N=l.newAttributes,L=l.enabledAttributes;for(let A=0,B=L.length;A<B;A++)L[A]!==N[A]&&(e.disableVertexAttribArray(A),L[A]=0)}function x(N,L,A,B,W,Y){!0!==i.isWebGL2||5124!==A&&5125!==A?e.vertexAttribPointer(N,L,A,B,W,Y):e.vertexAttribIPointer(N,L,A,W,Y)}function P(){F(),l!==c&&(l=c,f(l.object))}function F(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:function d(N,L,A,B,W){let Y=!1;if(s){const oe=function p(N,L,A){const B=!0===A.wireframe;let W=a[N.id];void 0===W&&(W={},a[N.id]=W);let Y=W[L.id];void 0===Y&&(Y={},W[L.id]=Y);let oe=Y[B];return void 0===oe&&(oe=y(function u(){return i.isWebGL2?e.createVertexArray():o.createVertexArrayOES()}()),Y[B]=oe),oe}(B,A,L);l!==oe&&(l=oe,f(l.object)),Y=function v(N,L){const A=l.attributes,B=N.attributes;let W=0;for(const Y in B){const oe=A[Y],he=B[Y];if(void 0===oe||oe.attribute!==he||oe.data!==he.data)return!0;W++}return l.attributesNum!==W||l.index!==L}(B,W),Y&&function g(N,L){const A={},B=N.attributes;let W=0;for(const Y in B){const oe=B[Y],he={};he.attribute=oe,oe.data&&(he.data=oe.data),A[Y]=he,W++}l.attributes=A,l.attributesNum=W,l.index=L}(B,W)}else{const oe=!0===L.wireframe;(l.geometry!==B.id||l.program!==A.id||l.wireframe!==oe)&&(l.geometry=B.id,l.program=A.id,l.wireframe=oe,Y=!0)}!0===N.isInstancedMesh&&(Y=!0),null!==W&&n.update(W,34963),Y&&(function D(N,L,A,B){if(!1===i.isWebGL2&&(N.isInstancedMesh||B.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;m();const W=B.attributes,Y=A.getAttributes(),oe=L.defaultAttributeValues;for(const he in Y){const ue=Y[he];if(ue>=0){const Je=W[he];if(void 0!==Je){const nt=Je.normalized,Qt=Je.itemSize,z=n.get(Je);if(void 0===z)continue;const Vn=z.buffer,Fe=z.type,yt=z.bytesPerElement;if(Je.isInterleavedBufferAttribute){const Qe=Je.data,St=Qe.stride,lt=Je.offset;Qe&&Qe.isInstancedInterleavedBuffer?(w(ue,Qe.meshPerAttribute),void 0===B._maxInstanceCount&&(B._maxInstanceCount=Qe.meshPerAttribute*Qe.count)):_(ue),e.bindBuffer(34962,Vn),x(ue,Qt,Fe,nt,St*yt,lt*yt)}else Je.isInstancedBufferAttribute?(w(ue,Je.meshPerAttribute),void 0===B._maxInstanceCount&&(B._maxInstanceCount=Je.meshPerAttribute*Je.count)):_(ue),e.bindBuffer(34962,Vn),x(ue,Qt,Fe,nt,0,0)}else if("instanceMatrix"===he){const nt=n.get(N.instanceMatrix);if(void 0===nt)continue;const Qt=nt.buffer,z=nt.type;w(ue+0,1),w(ue+1,1),w(ue+2,1),w(ue+3,1),e.bindBuffer(34962,Qt),e.vertexAttribPointer(ue+0,4,z,!1,64,0),e.vertexAttribPointer(ue+1,4,z,!1,64,16),e.vertexAttribPointer(ue+2,4,z,!1,64,32),e.vertexAttribPointer(ue+3,4,z,!1,64,48)}else if("instanceColor"===he){const nt=n.get(N.instanceColor);if(void 0===nt)continue;const Qt=nt.buffer,z=nt.type;w(ue,1),e.bindBuffer(34962,Qt),e.vertexAttribPointer(ue,3,z,!1,12,0)}else if(void 0!==oe){const nt=oe[he];if(void 0!==nt)switch(nt.length){case 2:e.vertexAttrib2fv(ue,nt);break;case 3:e.vertexAttrib3fv(ue,nt);break;case 4:e.vertexAttrib4fv(ue,nt);break;default:e.vertexAttrib1fv(ue,nt)}}}}b()}(N,L,A,B),null!==W&&e.bindBuffer(34963,n.get(W).buffer))},reset:P,resetDefaultState:F,dispose:function I(){P();for(const N in a){const L=a[N];for(const A in L){const B=L[A];for(const W in B)h(B[W].object),delete B[W];delete L[A]}delete a[N]}},releaseStatesOfGeometry:function R(N){if(void 0===a[N.id])return;const L=a[N.id];for(const A in L){const B=L[A];for(const W in B)h(B[W].object),delete B[W];delete L[A]}delete a[N.id]},releaseStatesOfProgram:function U(N){for(const L in a){const A=a[L];if(void 0===A[N.id])continue;const B=A[N.id];for(const W in B)h(B[W].object),delete B[W];delete A[N.id]}},initAttributes:m,enableAttribute:_,disableUnusedAttributes:b}}function MV(e,t,n,i){const r=i.isWebGL2;let o;this.setMode=function s(l){o=l},this.render=function a(l,d){e.drawArrays(o,l,d),n.update(d,o,1)},this.renderInstances=function c(l,d,u){if(0===u)return;let f,h;if(r)f=e,h="drawArraysInstanced";else if(f=t.get("ANGLE_instanced_arrays"),h="drawArraysInstancedANGLE",null===f)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");f[h](o,l,d,u),n.update(d,o,u)}}function EV(e,t,n){let i;function o(x){if("highp"===x){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";x="mediump"}return"mediump"===x&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s=typeof WebGL2RenderingContext<"u"&&e instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&e instanceof WebGL2ComputeRenderingContext;let a=void 0!==n.precision?n.precision:"highp";const c=o(a);c!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",c,"instead."),a=c);const l=!0===n.logarithmicDepthBuffer,d=e.getParameter(34930),u=e.getParameter(35660),f=e.getParameter(3379),h=e.getParameter(34076),p=e.getParameter(34921),y=e.getParameter(36347),v=e.getParameter(36348),g=e.getParameter(36349),m=u>0,_=s||!!t.get("OES_texture_float");return{isWebGL2:s,getMaxAnisotropy:function r(){if(void 0!==i)return i;const x=t.get("EXT_texture_filter_anisotropic");return i=null!==x?e.getParameter(x.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,i},getMaxPrecision:o,precision:a,logarithmicDepthBuffer:l,maxTextures:d,maxVertexTextures:u,maxTextureSize:f,maxCubemapSize:h,maxAttributes:p,maxVertexUniforms:y,maxVaryings:v,maxFragmentUniforms:g,vertexTextures:m,floatFragmentTextures:_,floatVertexTextures:m&&_,maxSamples:s?e.getParameter(36183):0}}function SV(e){const t=this;let n=null,i=0,r=!1,o=!1;const s=new wr,a=new Zn,c={value:null,needsUpdate:!1};function l(){c.value!==n&&(c.value=n,c.needsUpdate=i>0),t.numPlanes=i,t.numIntersection=0}function d(u,f,h,p){const y=null!==u?u.length:0;let v=null;if(0!==y){if(v=c.value,!0!==p||null===v){const g=h+4*y,m=f.matrixWorldInverse;a.getNormalMatrix(m),(null===v||v.length<g)&&(v=new Float32Array(g));for(let _=0,w=h;_!==y;++_,w+=4)s.copy(u[_]).applyMatrix4(m,a),s.normal.toArray(v,w),v[w+3]=s.constant}c.value=v,c.needsUpdate=!0}return t.numPlanes=y,t.numIntersection=0,v}this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(u,f,h){const p=0!==u.length||f||0!==i||r;return r=f,n=d(u,h,0),i=u.length,p},this.beginShadows=function(){o=!0,d(null)},this.endShadows=function(){o=!1,l()},this.setState=function(u,f,h){const p=u.clippingPlanes,y=u.clipIntersection,v=u.clipShadows,g=e.get(u);if(!r||null===p||0===p.length||o&&!v)o?d(null):l();else{const m=o?0:i,_=4*m;let w=g.clippingState||null;c.value=w,w=d(p,f,_,h);for(let b=0;b!==_;++b)w[b]=n[b];g.clippingState=w,this.numIntersection=y?this.numPlanes:0,this.numPlanes+=m}}}function TV(e){let t=new WeakMap;function n(s,a){return a===qd?s.mapping=dl:a===$d&&(s.mapping=fl),s}function r(s){const a=s.target;a.removeEventListener("dispose",r);const c=t.get(a);void 0!==c&&(t.delete(a),c.dispose())}return{get:function i(s){if(s&&s.isTexture){const a=s.mapping;if(a===qd||a===$d){if(t.has(s))return n(t.get(s).texture,s.mapping);{const c=s.image;if(c&&c.height>0){const l=e.getRenderList(),d=e.getRenderTarget(),u=new to(c.height/2);return u.fromEquirectangularTexture(e,s),t.set(s,u),e.setRenderTarget(d),e.setRenderList(l),s.addEventListener("dispose",r),n(u.texture,s.mapping)}return null}}}return s},dispose:function o(){t=new WeakMap}}}function DV(e){const t={};return{has:function(n){if(void 0!==t[n])return null!==t[n];let i;switch(n){case"WEBGL_depth_texture":i=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=e.getExtension(n)}return t[n]=i,null!==i},get:function(n){return this.has(n)||console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),t[n]}}}function CV(e,t,n,i){const r=new WeakMap,o=new WeakMap;function s(u){const f=u.target,h=r.get(f);null!==h.index&&t.remove(h.index);for(const y in h.attributes)t.remove(h.attributes[y]);f.removeEventListener("dispose",s),r.delete(f);const p=o.get(h);p&&(t.remove(p),o.delete(h)),i.releaseStatesOfGeometry(h),!0===f.isInstancedBufferGeometry&&delete f._maxInstanceCount,n.memory.geometries--}function l(u){const f=[],h=u.index,p=u.attributes.position;let y=0;if(null!==h){const m=h.array;y=h.version;for(let _=0,w=m.length;_<w;_+=3){const b=m[_+0],x=m[_+1],D=m[_+2];f.push(b,x,x,D,D,b)}}else{y=p.version;for(let _=0,w=p.array.length/3-1;_<w;_+=3){const b=_+0,x=_+1,D=_+2;f.push(b,x,x,D,D,b)}}const v=new(wT(f)>65535?ps:hs)(f,1);v.version=y;const g=o.get(u);g&&t.remove(g),o.set(u,v)}return{get:function a(u,f){let h=r.get(f);return h||(f.addEventListener("dispose",s),f.isBufferGeometry?h=f:f.isGeometry&&(void 0===f._bufferGeometry&&(f._bufferGeometry=(new Me).setFromObject(u)),h=f._bufferGeometry),r.set(f,h),n.memory.geometries++,h)},update:function c(u){const f=u.attributes;for(const p in f)t.update(f[p],34962);const h=u.morphAttributes;for(const p in h){const y=h[p];for(let v=0,g=y.length;v<g;v++)t.update(y[v],34962)}},getWireframeAttribute:function d(u){const f=o.get(u);if(f){const h=u.index;null!==h&&f.version<h.version&&l(u)}else l(u);return o.get(u)}}}function AV(e,t,n,i){const r=i.isWebGL2;let o,a,c;this.setMode=function s(f){o=f},this.setIndex=function l(f){a=f.type,c=f.bytesPerElement},this.render=function d(f,h){e.drawElements(o,h,a,f*c),n.update(h,o,1)},this.renderInstances=function u(f,h,p){if(0===p)return;let y,v;if(r)y=e,v="drawElementsInstanced";else if(y=t.get("ANGLE_instanced_arrays"),v="drawElementsInstancedANGLE",null===y)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");y[v](o,h,a,f*c,p),n.update(h,o,p)}}function IV(e){const n={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:n,programs:null,autoReset:!0,reset:function r(){n.frame++,n.calls=0,n.triangles=0,n.points=0,n.lines=0},update:function i(o,s,a){switch(n.calls++,s){case 4:n.triangles+=a*(o/3);break;case 1:n.lines+=a*(o/2);break;case 3:n.lines+=a*(o-1);break;case 2:n.lines+=a*o;break;case 0:n.points+=a*o;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",s)}}}}function LV(e,t){return e[0]-t[0]}function RV(e,t){return Math.abs(t[1])-Math.abs(e[1])}function PV(e){const t={},n=new Float32Array(8),i=[];for(let o=0;o<8;o++)i[o]=[o,0];return{update:function r(o,s,a,c){const l=o.morphTargetInfluences,d=void 0===l?0:l.length;let u=t[s.id];if(void 0===u){u=[];for(let v=0;v<d;v++)u[v]=[v,0];t[s.id]=u}for(let v=0;v<d;v++){const g=u[v];g[0]=v,g[1]=l[v]}u.sort(RV);for(let v=0;v<8;v++)v<d&&u[v][1]?(i[v][0]=u[v][0],i[v][1]=u[v][1]):(i[v][0]=Number.MAX_SAFE_INTEGER,i[v][1]=0);i.sort(LV);const f=a.morphTargets&&s.morphAttributes.position,h=a.morphNormals&&s.morphAttributes.normal;let p=0;for(let v=0;v<8;v++){const g=i[v],m=g[0],_=g[1];m!==Number.MAX_SAFE_INTEGER&&_?(f&&s.getAttribute("morphTarget"+v)!==f[m]&&s.setAttribute("morphTarget"+v,f[m]),h&&s.getAttribute("morphNormal"+v)!==h[m]&&s.setAttribute("morphNormal"+v,h[m]),n[v]=_,p+=_):(f&&!0===s.hasAttribute("morphTarget"+v)&&s.deleteAttribute("morphTarget"+v),h&&!0===s.hasAttribute("morphNormal"+v)&&s.deleteAttribute("morphNormal"+v),n[v]=0)}const y=s.morphTargetsRelative?1:1-p;c.getUniforms().setValue(e,"morphTargetBaseInfluence",y),c.getUniforms().setValue(e,"morphTargetInfluences",n)}}}function FV(e,t,n,i){let r=new WeakMap;function a(c){const l=c.target;l.removeEventListener("dispose",a),n.remove(l.instanceMatrix),null!==l.instanceColor&&n.remove(l.instanceColor)}return{update:function o(c){const l=i.render.frame,d=c.geometry,u=t.get(c,d);return r.get(u)!==l&&(d.isGeometry&&u.updateFromObject(c),t.update(u),r.set(u,l)),c.isInstancedMesh&&(!1===c.hasEventListener("dispose",a)&&c.addEventListener("dispose",a),n.update(c.instanceMatrix,34962),null!==c.instanceColor&&n.update(c.instanceColor,34962)),u},dispose:function s(){r=new WeakMap}}}function Xa(e=null,t=1,n=1,i=1){At.call(this,null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=bn,this.minFilter=bn,this.wrapR=Xn,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function Ya(e=null,t=1,n=1,i=1){At.call(this,null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=bn,this.minFilter=bn,this.wrapR=Xn,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}Ki.physical={uniforms:Bn([Ki.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new V(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new ae(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:ct.meshphysical_vert,fragmentShader:ct.meshphysical_frag},(Xa.prototype=Object.create(At.prototype)).constructor=Xa,Xa.prototype.isDataTexture2DArray=!0,(Ya.prototype=Object.create(At.prototype)).constructor=Ya,Ya.prototype.isDataTexture3D=!0;const TT=new At,NV=new Xa,OV=new Ya,DT=new Er,CT=[],AT=[],IT=new Float32Array(16),LT=new Float32Array(9),RT=new Float32Array(4);function Za(e,t,n){const i=e[0];if(i<=0||i>0)return e;const r=t*n;let o=CT[r];if(void 0===o&&(o=new Float32Array(r),CT[r]=o),0!==t){i.toArray(o,0);for(let s=1,a=0;s!==t;++s)a+=n,e[s].toArray(o,a)}return o}function Fi(e,t){if(e.length!==t.length)return!1;for(let n=0,i=e.length;n<i;n++)if(e[n]!==t[n])return!1;return!0}function xi(e,t){for(let n=0,i=t.length;n<i;n++)e[n]=t[n]}function PT(e,t){let n=AT[t];void 0===n&&(n=new Int32Array(t),AT[t]=n);for(let i=0;i!==t;++i)n[i]=e.allocateTextureUnit();return n}function BV(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function kV(e,t){const n=this.cache;if(void 0!==t.x)(n[0]!==t.x||n[1]!==t.y)&&(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(Fi(n,t))return;e.uniform2fv(this.addr,t),xi(n,t)}}function HV(e,t){const n=this.cache;if(void 0!==t.x)(n[0]!==t.x||n[1]!==t.y||n[2]!==t.z)&&(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)(n[0]!==t.r||n[1]!==t.g||n[2]!==t.b)&&(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(Fi(n,t))return;e.uniform3fv(this.addr,t),xi(n,t)}}function VV(e,t){const n=this.cache;if(void 0!==t.x)(n[0]!==t.x||n[1]!==t.y||n[2]!==t.z||n[3]!==t.w)&&(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(Fi(n,t))return;e.uniform4fv(this.addr,t),xi(n,t)}}function UV(e,t){const n=this.cache,i=t.elements;if(void 0===i){if(Fi(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),xi(n,t)}else{if(Fi(n,i))return;RT.set(i),e.uniformMatrix2fv(this.addr,!1,RT),xi(n,i)}}function GV(e,t){const n=this.cache,i=t.elements;if(void 0===i){if(Fi(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),xi(n,t)}else{if(Fi(n,i))return;LT.set(i),e.uniformMatrix3fv(this.addr,!1,LT),xi(n,i)}}function zV(e,t){const n=this.cache,i=t.elements;if(void 0===i){if(Fi(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),xi(n,t)}else{if(Fi(n,i))return;IT.set(i),e.uniformMatrix4fv(this.addr,!1,IT),xi(n,i)}}function jV(e,t,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),n.safeSetTexture2D(t||TT,r)}function WV(e,t,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(t||NV,r)}function qV(e,t,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(t||OV,r)}function $V(e,t,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),n.safeSetTextureCube(t||DT,r)}function XV(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function YV(e,t){const n=this.cache;Fi(n,t)||(e.uniform2iv(this.addr,t),xi(n,t))}function ZV(e,t){const n=this.cache;Fi(n,t)||(e.uniform3iv(this.addr,t),xi(n,t))}function JV(e,t){const n=this.cache;Fi(n,t)||(e.uniform4iv(this.addr,t),xi(n,t))}function QV(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function eU(e,t){e.uniform1fv(this.addr,t)}function tU(e,t){e.uniform1iv(this.addr,t)}function nU(e,t){e.uniform2iv(this.addr,t)}function iU(e,t){e.uniform3iv(this.addr,t)}function rU(e,t){e.uniform4iv(this.addr,t)}function oU(e,t){const n=Za(t,this.size,2);e.uniform2fv(this.addr,n)}function sU(e,t){const n=Za(t,this.size,3);e.uniform3fv(this.addr,n)}function aU(e,t){const n=Za(t,this.size,4);e.uniform4fv(this.addr,n)}function cU(e,t){const n=Za(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function lU(e,t){const n=Za(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function uU(e,t){const n=Za(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function dU(e,t,n){const i=t.length,r=PT(n,i);e.uniform1iv(this.addr,r);for(let o=0;o!==i;++o)n.safeSetTexture2D(t[o]||TT,r[o])}function fU(e,t,n){const i=t.length,r=PT(n,i);e.uniform1iv(this.addr,r);for(let o=0;o!==i;++o)n.safeSetTextureCube(t[o]||DT,r[o])}function pU(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=function KV(e){switch(e){case 5126:return BV;case 35664:return kV;case 35665:return HV;case 35666:return VV;case 35674:return UV;case 35675:return GV;case 35676:return zV;case 5124:case 35670:return XV;case 35667:case 35671:return YV;case 35668:case 35672:return ZV;case 35669:case 35673:return JV;case 5125:return QV;case 35678:case 36198:case 36298:case 36306:case 35682:return jV;case 35679:case 36299:case 36307:return qV;case 35680:case 36300:case 36308:case 36293:return $V;case 36289:case 36303:case 36311:case 36292:return WV}}(t.type)}function FT(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=function hU(e){switch(e){case 5126:return eU;case 35664:return oU;case 35665:return sU;case 35666:return aU;case 35674:return cU;case 35675:return lU;case 35676:return uU;case 5124:case 35670:return tU;case 35667:case 35671:return nU;case 35668:case 35672:return iU;case 35669:case 35673:return rU;case 35678:case 36198:case 36298:case 36306:case 35682:return dU;case 35680:case 36300:case 36308:case 36293:return fU}}(t.type)}function NT(e){this.id=e,this.seq=[],this.map={}}FT.prototype.updateCache=function(e){const t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length)),xi(t,e)},NT.prototype.setValue=function(e,t,n){const i=this.seq;for(let r=0,o=i.length;r!==o;++r){const s=i[r];s.setValue(e,t[s.id],n)}};const Ay=/(\w+)(\])?(\[|\.)?/g;function OT(e,t){e.seq.push(t),e.map[t.id]=t}function mU(e,t,n){const i=e.name,r=i.length;for(Ay.lastIndex=0;;){const o=Ay.exec(i),s=Ay.lastIndex;let a=o[1];const l=o[3];if("]"===o[2]&&(a|=0),void 0===l||"["===l&&s+2===r){OT(n,void 0===l?new pU(a,e,t):new FT(a,e,t));break}{let u=n.map[a];void 0===u&&(u=new NT(a),OT(n,u)),n=u}}}function Ao(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let i=0;i<n;++i){const r=e.getActiveUniform(t,i);mU(r,e.getUniformLocation(t,r.name),this)}}function BT(e,t,n){const i=e.createShader(t);return e.shaderSource(i,n),e.compileShader(i),i}Ao.prototype.setValue=function(e,t,n,i){const r=this.map[t];void 0!==r&&r.setValue(e,n,i)},Ao.prototype.setOptional=function(e,t,n){const i=t[n];void 0!==i&&this.setValue(e,n,i)},Ao.upload=function(e,t,n,i){for(let r=0,o=t.length;r!==o;++r){const s=t[r],a=n[s.id];!1!==a.needsUpdate&&s.setValue(e,a.value,i)}},Ao.seqWithValue=function(e,t){const n=[];for(let i=0,r=e.length;i!==r;++i){const o=e[i];o.id in t&&n.push(o)}return n};let gU=0;function kT(e){switch(e){case Yn:return["Linear","( value )"];case bl:return["sRGB","( value )"];case Kd:return["RGBE","( value )"];case iy:return["RGBM","( value, 7.0 )"];case ry:return["RGBM","( value, 16.0 )"];case oy:return["RGBD","( value, 256.0 )"];case Qd:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case oT:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function HT(e,t,n){const i=e.getShaderParameter(t,35713),r=e.getShaderInfoLog(t).trim();return i&&""===r?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+n+"\n"+r+function yU(e){const t=e.split("\n");for(let n=0;n<t.length;n++)t[n]=n+1+": "+t[n];return t.join("\n")}(e.getShaderSource(t))}function Vl(e,t){const n=kT(t);return"vec4 "+e+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function vU(e,t){const n=kT(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function _U(e,t){let n;switch(t){case rS:n="Linear";break;case oS:n="Reinhard";break;case sS:n="OptimizedCineon";break;case aS:n="ACESFilmic";break;case cS:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function Ul(e){return""!==e}function VT(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function UT(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const MU=/^[ \t]*#include +<([\w\d./]+)>/gm;function Iy(e){return e.replace(MU,EU)}function EU(e,t){const n=ct[t];if(void 0===n)throw new Error("Can not resolve #include <"+t+">");return Iy(n)}const SU=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,TU=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function GT(e){return e.replace(TU,zT).replace(SU,DU)}function DU(e,t,n,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),zT(0,t,n,i)}function zT(e,t,n,i){let r="";for(let o=parseInt(t);o<parseInt(n);o++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+o+" ]").replace(/UNROLLED_LOOP_INDEX/g,o);return r}function jT(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function RU(e,t,n,i){const r=e.getContext(),o=n.defines;let s=n.vertexShader,a=n.fragmentShader;const c=function CU(e){let t="SHADOWMAP_TYPE_BASIC";return e.shadowMapType===Og?t="SHADOWMAP_TYPE_PCF":e.shadowMapType===OE?t="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===Ma&&(t="SHADOWMAP_TYPE_VSM"),t}(n),l=function AU(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case dl:case fl:t="ENVMAP_TYPE_CUBE";break;case Ta:case hl:t="ENVMAP_TYPE_CUBE_UV"}return t}(n),d=function IU(e){let t="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case fl:case hl:t="ENVMAP_MODE_REFRACTION"}return t}(n),u=function LU(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case ul:t="ENVMAP_BLENDING_MULTIPLY";break;case nS:t="ENVMAP_BLENDING_MIX";break;case iS:t="ENVMAP_BLENDING_ADD"}return t}(n),f=e.gammaFactor>0?e.gammaFactor:1,h=n.isWebGL2?"":function xU(e){return[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Ul).join("\n")}(n),p=function wU(e){const t=[];for(const n in e){const i=e[n];!1!==i&&t.push("#define "+n+" "+i)}return t.join("\n")}(o),y=r.createProgram();let v,g,m=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(v=[p].filter(Ul).join("\n"),v.length>0&&(v+="\n"),g=[h,p].filter(Ul).join("\n"),g.length>0&&(g+="\n")):(v=[jT(n),"#define SHADER_NAME "+n.shaderName,p,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+d:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Ul).join("\n"),g=[h,jT(n),"#define SHADER_NAME "+n.shaderName,p,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+f,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+l:"",n.envMap?"#define "+d:"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==rs?"#define TONE_MAPPING":"",n.toneMapping!==rs?ct.tonemapping_pars_fragment:"",n.toneMapping!==rs?_U("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",ct.encodings_pars_fragment,n.map?Vl("mapTexelToLinear",n.mapEncoding):"",n.matcap?Vl("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?Vl("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?Vl("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?Vl("lightMapTexelToLinear",n.lightMapEncoding):"",vU("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(Ul).join("\n")),s=Iy(s),s=VT(s,n),s=UT(s,n),a=Iy(a),a=VT(a,n),a=UT(a,n),s=GT(s),a=GT(a),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(m="#version 300 es\n",v=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+v,g=["#define varying in",n.glslVersion===sy?"":"out highp vec4 pc_fragColor;",n.glslVersion===sy?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+g);const w=m+g+a,b=BT(r,35633,m+v+s),x=BT(r,35632,w);if(r.attachShader(y,b),r.attachShader(y,x),void 0!==n.index0AttributeName?r.bindAttribLocation(y,0,n.index0AttributeName):!0===n.morphTargets&&r.bindAttribLocation(y,0,"position"),r.linkProgram(y),e.debug.checkShaderErrors){const R=r.getProgramInfoLog(y).trim(),U=r.getShaderInfoLog(b).trim(),P=r.getShaderInfoLog(x).trim();let F=!0,N=!0;if(!1===r.getProgramParameter(y,35714)){F=!1;const L=HT(r,b,"vertex"),A=HT(r,x,"fragment");console.error("THREE.WebGLProgram: shader error: ",r.getError(),"35715",r.getProgramParameter(y,35715),"gl.getProgramInfoLog",R,L,A)}else""!==R?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",R):(""===U||""===P)&&(N=!1);N&&(this.diagnostics={runnable:F,programLog:R,vertexShader:{log:U,prefix:v},fragmentShader:{log:P,prefix:g}})}let D,I;return r.deleteShader(b),r.deleteShader(x),this.getUniforms=function(){return void 0===D&&(D=new Ao(r,y)),D},this.getAttributes=function(){return void 0===I&&(I=function bU(e,t){const n={},i=e.getProgramParameter(t,35721);for(let r=0;r<i;r++){const s=e.getActiveAttrib(t,r).name;n[s]=e.getAttribLocation(t,s)}return n}(r,y)),I},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(y),this.program=void 0},this.name=n.shaderName,this.id=gU++,this.cacheKey=t,this.usedTimes=1,this.program=y,this.vertexShader=b,this.fragmentShader=x,this}function PU(e,t,n,i,r,o){const s=[],a=i.isWebGL2,c=i.logarithmicDepthBuffer,l=i.floatVertexTextures,d=i.maxVertexUniforms,u=i.vertexTextures;let f=i.precision;const h={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function v(x){let D;return x&&x.isTexture?D=x.encoding:x&&x.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),D=x.texture.encoding):D=Yn,D}return{getParameters:function g(x,D,I,R,U){const P=R.fog,N=t.get(x.envMap||(x.isMeshStandardMaterial?R.environment:null)),L=h[x.type],A=U.isSkinnedMesh?function y(x){const I=x.skeleton.bones;if(l)return 1024;{const U=Math.floor((d-20)/4),P=Math.min(U,I.length);return P<I.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+I.length+" bones. This GPU supports "+P+"."),0):P}}(U):0;let B,W;if(null!==x.precision&&(f=i.getMaxPrecision(x.precision),f!==x.precision&&console.warn("THREE.WebGLProgram.getParameters:",x.precision,"not supported, using",f,"instead.")),L){const he=Ki[L];B=he.vertexShader,W=he.fragmentShader}else B=x.vertexShader,W=x.fragmentShader;const Y=e.getRenderTarget();return{isWebGL2:a,shaderID:L,shaderName:x.type,vertexShader:B,fragmentShader:W,defines:x.defines,isRawShaderMaterial:!0===x.isRawShaderMaterial,glslVersion:x.glslVersion,precision:f,instancing:!0===U.isInstancedMesh,instancingColor:!0===U.isInstancedMesh&&null!==U.instanceColor,supportsVertexTextures:u,outputEncoding:null!==Y?v(Y.texture):e.outputEncoding,map:!!x.map,mapEncoding:v(x.map),matcap:!!x.matcap,matcapEncoding:v(x.matcap),envMap:!!N,envMapMode:N&&N.mapping,envMapEncoding:v(N),envMapCubeUV:!!N&&(N.mapping===Ta||N.mapping===hl),lightMap:!!x.lightMap,lightMapEncoding:v(x.lightMap),aoMap:!!x.aoMap,emissiveMap:!!x.emissiveMap,emissiveMapEncoding:v(x.emissiveMap),bumpMap:!!x.bumpMap,normalMap:!!x.normalMap,objectSpaceNormalMap:x.normalMapType===cT,tangentSpaceNormalMap:x.normalMapType===cs,clearcoatMap:!!x.clearcoatMap,clearcoatRoughnessMap:!!x.clearcoatRoughnessMap,clearcoatNormalMap:!!x.clearcoatNormalMap,displacementMap:!!x.displacementMap,roughnessMap:!!x.roughnessMap,metalnessMap:!!x.metalnessMap,specularMap:!!x.specularMap,alphaMap:!!x.alphaMap,gradientMap:!!x.gradientMap,sheen:!!x.sheen,transmissionMap:!!x.transmissionMap,combine:x.combine,vertexTangents:x.normalMap&&x.vertexTangents,vertexColors:x.vertexColors,vertexUvs:!!(x.map||x.bumpMap||x.normalMap||x.specularMap||x.alphaMap||x.emissiveMap||x.roughnessMap||x.metalnessMap||x.clearcoatMap||x.clearcoatRoughnessMap||x.clearcoatNormalMap||x.displacementMap||x.transmissionMap),uvsVertexOnly:!(x.map||x.bumpMap||x.normalMap||x.specularMap||x.alphaMap||x.emissiveMap||x.roughnessMap||x.metalnessMap||x.clearcoatNormalMap||x.transmissionMap||!x.displacementMap),fog:!!P,useFog:x.fog,fogExp2:P&&P.isFogExp2,flatShading:x.flatShading,sizeAttenuation:x.sizeAttenuation,logarithmicDepthBuffer:c,skinning:x.skinning&&A>0,maxBones:A,useVertexTexture:l,morphTargets:x.morphTargets,morphNormals:x.morphNormals,maxMorphTargets:e.maxMorphTargets,maxMorphNormals:e.maxMorphNormals,numDirLights:D.directional.length,numPointLights:D.point.length,numSpotLights:D.spot.length,numRectAreaLights:D.rectArea.length,numHemiLights:D.hemi.length,numDirLightShadows:D.directionalShadowMap.length,numPointLightShadows:D.pointShadowMap.length,numSpotLightShadows:D.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:x.dithering,shadowMapEnabled:e.shadowMap.enabled&&I.length>0,shadowMapType:e.shadowMap.type,toneMapping:x.toneMapped?e.toneMapping:rs,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:x.premultipliedAlpha,alphaTest:x.alphaTest,doubleSided:x.side===ll,flipSided:x.side===wn,depthPacking:void 0!==x.depthPacking&&x.depthPacking,index0AttributeName:x.index0AttributeName,extensionDerivatives:x.extensions&&x.extensions.derivatives,extensionFragDepth:x.extensions&&x.extensions.fragDepth,extensionDrawBuffers:x.extensions&&x.extensions.drawBuffers,extensionShaderTextureLOD:x.extensions&&x.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||n.has("EXT_shader_texture_lod"),customProgramCacheKey:x.customProgramCacheKey()}},getProgramCacheKey:function m(x){const D=[];if(x.shaderID?D.push(x.shaderID):(D.push(x.fragmentShader),D.push(x.vertexShader)),void 0!==x.defines)for(const I in x.defines)D.push(I),D.push(x.defines[I]);if(!1===x.isRawShaderMaterial){for(let I=0;I<p.length;I++)D.push(x[p[I]]);D.push(e.outputEncoding),D.push(e.gammaFactor)}return D.push(x.customProgramCacheKey),D.join()},getUniforms:function _(x){const D=h[x.type];let I;return I=D?ET.clone(Ki[D].uniforms):x.uniforms,I},acquireProgram:function w(x,D){let I;for(let R=0,U=s.length;R<U;R++){const P=s[R];if(P.cacheKey===D){I=P,++I.usedTimes;break}}return void 0===I&&(I=new RU(e,D,x,r),s.push(I)),I},releaseProgram:function b(x){if(0==--x.usedTimes){const D=s.indexOf(x);s[D]=s[s.length-1],s.pop(),x.destroy()}},programs:s}}function FU(){let e=new WeakMap;return{get:function t(o){let s=e.get(o);return void 0===s&&(s={},e.set(o,s)),s},remove:function n(o){e.delete(o)},update:function i(o,s,a){e.get(o)[s]=a},dispose:function r(){e=new WeakMap}}}function NU(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.program!==t.program?e.program.id-t.program.id:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function OU(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function WT(e){const t=[];let n=0;const i=[],r=[],o={id:-1};function a(f,h,p,y,v,g){let m=t[n];const _=e.get(p);return void 0===m?(m={id:f.id,object:f,geometry:h,material:p,program:_.program||o,groupOrder:y,renderOrder:f.renderOrder,z:v,group:g},t[n]=m):(m.id=f.id,m.object=f,m.geometry=h,m.material=p,m.program=_.program||o,m.groupOrder=y,m.renderOrder=f.renderOrder,m.z=v,m.group=g),n++,m}return{opaque:i,transparent:r,init:function s(){n=0,i.length=0,r.length=0},push:function c(f,h,p,y,v,g){const m=a(f,h,p,y,v,g);(!0===p.transparent?r:i).push(m)},unshift:function l(f,h,p,y,v,g){const m=a(f,h,p,y,v,g);(!0===p.transparent?r:i).unshift(m)},finish:function u(){for(let f=n,h=t.length;f<h;f++){const p=t[f];if(null===p.id)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}},sort:function d(f,h){i.length>1&&i.sort(f||NU),r.length>1&&r.sort(h||OU)}}}function BU(e){let t=new WeakMap;return{get:function n(r,o){const s=t.get(r);let a;return void 0===s?(a=new WT(e),t.set(r,new WeakMap),t.get(r).set(o,a)):(a=s.get(o),void 0===a&&(a=new WT(e),s.set(o,a))),a},dispose:function i(){t=new WeakMap}}}function kU(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new M,color:new ae};break;case"SpotLight":n={position:new M,direction:new M,color:new ae,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new M,color:new ae,distance:0,decay:0};break;case"HemisphereLight":n={direction:new M,skyColor:new ae,groundColor:new ae};break;case"RectAreaLight":n={color:new ae,position:new M,halfWidth:new M,halfHeight:new M}}return e[t.id]=n,n}}}let VU=0;function UU(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function GU(e,t){const n=new kU,i=function HU(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new V};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new V,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=n,n}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let d=0;d<9;d++)r.probe.push(new M);const o=new M,s=new Ze,a=new Ze;return{setup:function c(d){let u=0,f=0,h=0;for(let D=0;D<9;D++)r.probe[D].set(0,0,0);let p=0,y=0,v=0,g=0,m=0,_=0,w=0,b=0;d.sort(UU);for(let D=0,I=d.length;D<I;D++){const R=d[D],U=R.color,P=R.intensity,F=R.distance,N=R.shadow&&R.shadow.map?R.shadow.map.texture:null;if(R.isAmbientLight)u+=U.r*P,f+=U.g*P,h+=U.b*P;else if(R.isLightProbe)for(let L=0;L<9;L++)r.probe[L].addScaledVector(R.sh.coefficients[L],P);else if(R.isDirectionalLight){const L=n.get(R);if(L.color.copy(R.color).multiplyScalar(R.intensity),R.castShadow){const A=R.shadow,B=i.get(R);B.shadowBias=A.bias,B.shadowNormalBias=A.normalBias,B.shadowRadius=A.radius,B.shadowMapSize=A.mapSize,r.directionalShadow[p]=B,r.directionalShadowMap[p]=N,r.directionalShadowMatrix[p]=R.shadow.matrix,_++}r.directional[p]=L,p++}else if(R.isSpotLight){const L=n.get(R);if(L.position.setFromMatrixPosition(R.matrixWorld),L.color.copy(U).multiplyScalar(P),L.distance=F,L.coneCos=Math.cos(R.angle),L.penumbraCos=Math.cos(R.angle*(1-R.penumbra)),L.decay=R.decay,R.castShadow){const A=R.shadow,B=i.get(R);B.shadowBias=A.bias,B.shadowNormalBias=A.normalBias,B.shadowRadius=A.radius,B.shadowMapSize=A.mapSize,r.spotShadow[v]=B,r.spotShadowMap[v]=N,r.spotShadowMatrix[v]=R.shadow.matrix,b++}r.spot[v]=L,v++}else if(R.isRectAreaLight){const L=n.get(R);L.color.copy(U).multiplyScalar(P),L.halfWidth.set(.5*R.width,0,0),L.halfHeight.set(0,.5*R.height,0),r.rectArea[g]=L,g++}else if(R.isPointLight){const L=n.get(R);if(L.color.copy(R.color).multiplyScalar(R.intensity),L.distance=R.distance,L.decay=R.decay,R.castShadow){const A=R.shadow,B=i.get(R);B.shadowBias=A.bias,B.shadowNormalBias=A.normalBias,B.shadowRadius=A.radius,B.shadowMapSize=A.mapSize,B.shadowCameraNear=A.camera.near,B.shadowCameraFar=A.camera.far,r.pointShadow[y]=B,r.pointShadowMap[y]=N,r.pointShadowMatrix[y]=R.shadow.matrix,w++}r.point[y]=L,y++}else if(R.isHemisphereLight){const L=n.get(R);L.skyColor.copy(R.color).multiplyScalar(P),L.groundColor.copy(R.groundColor).multiplyScalar(P),r.hemi[m]=L,m++}}g>0&&(t.isWebGL2||!0===e.has("OES_texture_float_linear")?(r.rectAreaLTC1=J.LTC_FLOAT_1,r.rectAreaLTC2=J.LTC_FLOAT_2):!0===e.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=J.LTC_HALF_1,r.rectAreaLTC2=J.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=u,r.ambient[1]=f,r.ambient[2]=h;const x=r.hash;(x.directionalLength!==p||x.pointLength!==y||x.spotLength!==v||x.rectAreaLength!==g||x.hemiLength!==m||x.numDirectionalShadows!==_||x.numPointShadows!==w||x.numSpotShadows!==b)&&(r.directional.length=p,r.spot.length=v,r.rectArea.length=g,r.point.length=y,r.hemi.length=m,r.directionalShadow.length=_,r.directionalShadowMap.length=_,r.pointShadow.length=w,r.pointShadowMap.length=w,r.spotShadow.length=b,r.spotShadowMap.length=b,r.directionalShadowMatrix.length=_,r.pointShadowMatrix.length=w,r.spotShadowMatrix.length=b,x.directionalLength=p,x.pointLength=y,x.spotLength=v,x.rectAreaLength=g,x.hemiLength=m,x.numDirectionalShadows=_,x.numPointShadows=w,x.numSpotShadows=b,r.version=VU++)},setupView:function l(d,u){let f=0,h=0,p=0,y=0,v=0;const g=u.matrixWorldInverse;for(let m=0,_=d.length;m<_;m++){const w=d[m];if(w.isDirectionalLight){const b=r.directional[f];b.direction.setFromMatrixPosition(w.matrixWorld),o.setFromMatrixPosition(w.target.matrixWorld),b.direction.sub(o),b.direction.transformDirection(g),f++}else if(w.isSpotLight){const b=r.spot[p];b.position.setFromMatrixPosition(w.matrixWorld),b.position.applyMatrix4(g),b.direction.setFromMatrixPosition(w.matrixWorld),o.setFromMatrixPosition(w.target.matrixWorld),b.direction.sub(o),b.direction.transformDirection(g),p++}else if(w.isRectAreaLight){const b=r.rectArea[y];b.position.setFromMatrixPosition(w.matrixWorld),b.position.applyMatrix4(g),a.identity(),s.copy(w.matrixWorld),s.premultiply(g),a.extractRotation(s),b.halfWidth.set(.5*w.width,0,0),b.halfHeight.set(0,.5*w.height,0),b.halfWidth.applyMatrix4(a),b.halfHeight.applyMatrix4(a),y++}else if(w.isPointLight){const b=r.point[h];b.position.setFromMatrixPosition(w.matrixWorld),b.position.applyMatrix4(g),h++}else if(w.isHemisphereLight){const b=r.hemi[v];b.direction.setFromMatrixPosition(w.matrixWorld),b.direction.transformDirection(g),b.direction.normalize(),v++}}},state:r}}function qT(e,t){const n=new GU(e,t),i=[],r=[];return{init:function o(){i.length=0,r.length=0},state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:function c(){n.setup(i)},setupLightsView:function l(u){n.setupView(i,u)},pushLight:function s(u){i.push(u)},pushShadow:function a(u){r.push(u)}}}function zU(e,t){let n=new WeakMap;return{get:function i(o,s=0){let a;return!1===n.has(o)?(a=new qT(e,t),n.set(o,[]),n.get(o).push(a)):s>=n.get(o).length?(a=new qT(e,t),n.get(o).push(a)):a=n.get(o)[s],a},dispose:function r(){n=new WeakMap}}}function Io(e){Pe.call(this),this.type="MeshDepthMaterial",this.depthPacking=sT,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}function Lo(e){Pe.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new M,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}function $T(e,t,n){let i=new Hl;const r=new V,o=new V,s=new It,a=[],c=[],l={},d={0:wn,1:Ea,2:ll},u=new Jn({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new V},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),f=u.clone();f.defines.HORIZONTAL_PASS=1;const h=new Me;h.setAttribute("position",new Ee(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new Gt(h,u),y=this;function v(b,x){const D=t.update(p);u.uniforms.shadow_pass.value=b.map.texture,u.uniforms.resolution.value=b.mapSize,u.uniforms.radius.value=b.radius,e.setRenderTarget(b.mapPass),e.clear(),e.renderBufferDirect(x,null,D,u,p,null),f.uniforms.shadow_pass.value=b.mapPass.texture,f.uniforms.resolution.value=b.mapSize,f.uniforms.radius.value=b.radius,e.setRenderTarget(b.map),e.clear(),e.renderBufferDirect(x,null,D,f,p,null)}function g(b,x,D){const I=b<<0|x<<1|D<<2;let R=a[I];return void 0===R&&(R=new Io({depthPacking:aT,morphTargets:b,skinning:x}),a[I]=R),R}function m(b,x,D){const I=b<<0|x<<1|D<<2;let R=c[I];return void 0===R&&(R=new Lo({morphTargets:b,skinning:x}),c[I]=R),R}function _(b,x,D,I,R,U,P){let F=null,N=g,L=b.customDepthMaterial;if(!0===I.isPointLight&&(N=m,L=b.customDistanceMaterial),void 0===L){let A=!1;!0===D.morphTargets&&(A=x.morphAttributes&&x.morphAttributes.position&&x.morphAttributes.position.length>0);let B=!1;!0===b.isSkinnedMesh&&(!0===D.skinning?B=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",b)),F=N(A,B,!0===b.isInstancedMesh)}else F=L;if(e.localClippingEnabled&&!0===D.clipShadows&&0!==D.clippingPlanes.length){const A=F.uuid,B=D.uuid;let W=l[A];void 0===W&&(W={},l[A]=W);let Y=W[B];void 0===Y&&(Y=F.clone(),W[B]=Y),F=Y}return F.visible=D.visible,F.wireframe=D.wireframe,F.side=P===Ma?null!==D.shadowSide?D.shadowSide:D.side:null!==D.shadowSide?D.shadowSide:d[D.side],F.clipShadows=D.clipShadows,F.clippingPlanes=D.clippingPlanes,F.clipIntersection=D.clipIntersection,F.wireframeLinewidth=D.wireframeLinewidth,F.linewidth=D.linewidth,!0===I.isPointLight&&!0===F.isMeshDistanceMaterial&&(F.referencePosition.setFromMatrixPosition(I.matrixWorld),F.nearDistance=R,F.farDistance=U),F}function w(b,x,D,I,R){if(!1===b.visible)return;if(b.layers.test(x.layers)&&(b.isMesh||b.isLine||b.isPoints)&&(b.castShadow||b.receiveShadow&&R===Ma)&&(!b.frustumCulled||i.intersectsObject(b))){b.modelViewMatrix.multiplyMatrices(D.matrixWorldInverse,b.matrixWorld);const F=t.update(b),N=b.material;if(Array.isArray(N)){const L=F.groups;for(let A=0,B=L.length;A<B;A++){const W=L[A],Y=N[W.materialIndex];if(Y&&Y.visible){const oe=_(b,F,Y,I,D.near,D.far,R);e.renderBufferDirect(D,null,F,oe,b,W)}}}else if(N.visible){const L=_(b,F,N,I,D.near,D.far,R);e.renderBufferDirect(D,null,F,L,b,null)}}const P=b.children;for(let F=0,N=P.length;F<N;F++)w(P[F],x,D,I,R)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Og,this.render=function(b,x,D){if(!1===y.enabled||!1===y.autoUpdate&&!1===y.needsUpdate||0===b.length)return;const I=e.getRenderTarget(),R=e.getActiveCubeFace(),U=e.getActiveMipmapLevel(),P=e.state;P.setBlending($r),P.buffers.color.setClear(1,1,1,1),P.buffers.depth.setTest(!0),P.setScissorTest(!1);for(let F=0,N=b.length;F<N;F++){const L=b[F],A=L.shadow;if(void 0===A){console.warn("THREE.WebGLShadowMap:",L,"has no shadow.");continue}if(!1===A.autoUpdate&&!1===A.needsUpdate)continue;r.copy(A.mapSize);const B=A.getFrameExtents();if(r.multiply(B),o.copy(A.mapSize),(r.x>n||r.y>n)&&(r.x>n&&(o.x=Math.floor(n/B.x),r.x=o.x*B.x,A.mapSize.x=o.x),r.y>n&&(o.y=Math.floor(n/B.y),r.y=o.y*B.y,A.mapSize.y=o.y)),null===A.map&&!A.isPointLightShadow&&this.type===Ma){const Y={minFilter:En,magFilter:En,format:gi};A.map=new yi(r.x,r.y,Y),A.map.texture.name=L.name+".shadowMap",A.mapPass=new yi(r.x,r.y,Y),A.camera.updateProjectionMatrix()}null===A.map&&(A.map=new yi(r.x,r.y,{minFilter:bn,magFilter:bn,format:gi}),A.map.texture.name=L.name+".shadowMap",A.camera.updateProjectionMatrix()),e.setRenderTarget(A.map),e.clear();const W=A.getViewportCount();for(let Y=0;Y<W;Y++){const oe=A.getViewport(Y);s.set(o.x*oe.x,o.y*oe.y,o.x*oe.z,o.y*oe.w),P.viewport(s),A.updateMatrices(L,Y),i=A.getFrustum(),w(x,D,A.camera,L,this.type)}!A.isPointLightShadow&&this.type===Ma&&v(A,D),A.needsUpdate=!1}y.needsUpdate=!1,e.setRenderTarget(I,R,U)}}function qU(e,t,n){const i=n.isWebGL2,a=new function r(){let C=!1;const X=new It;let se=null;const _e=new It(0,0,0,0);return{setMask:function(Q){se!==Q&&!C&&(e.colorMask(Q,Q,Q,Q),se=Q)},setLocked:function(Q){C=Q},setClear:function(Q,ve,Te,Ke,ye){!0===ye&&(Q*=Ke,ve*=Ke,Te*=Ke),X.set(Q,ve,Te,Ke),!1===_e.equals(X)&&(e.clearColor(Q,ve,Te,Ke),_e.copy(X))},reset:function(){C=!1,se=null,_e.set(-1,0,0,0)}}},c=new function o(){let C=!1,X=null,se=null,_e=null;return{setTest:function(Q){Q?he(2929):ue(2929)},setMask:function(Q){X!==Q&&!C&&(e.depthMask(Q),X=Q)},setFunc:function(Q){if(se!==Q){if(Q)switch(Q){case YE:e.depthFunc(512);break;case ZE:e.depthFunc(519);break;case JE:e.depthFunc(513);break;case jd:e.depthFunc(515);break;case QE:e.depthFunc(514);break;case KE:e.depthFunc(518);break;case eS:e.depthFunc(516);break;case tS:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);se=Q}},setLocked:function(Q){C=Q},setClear:function(Q){_e!==Q&&(e.clearDepth(Q),_e=Q)},reset:function(){C=!1,X=null,se=null,_e=null}}},l=new function s(){let C=!1,X=null,se=null,_e=null,Q=null,ve=null,Te=null,Ke=null,ye=null;return{setTest:function(He){C||(He?he(2960):ue(2960))},setMask:function(He){X!==He&&!C&&(e.stencilMask(He),X=He)},setFunc:function(He,Kt,oi){(se!==He||_e!==Kt||Q!==oi)&&(e.stencilFunc(He,Kt,oi),se=He,_e=Kt,Q=oi)},setOp:function(He,Kt,oi){(ve!==He||Te!==Kt||Ke!==oi)&&(e.stencilOp(He,Kt,oi),ve=He,Te=Kt,Ke=oi)},setLocked:function(He){C=He},setClear:function(He){ye!==He&&(e.clearStencil(He),ye=He)},reset:function(){C=!1,X=null,se=null,_e=null,Q=null,ve=null,Te=null,Ke=null,ye=null}}};let d={},u=null,f=null,h=null,p=null,y=null,v=null,g=null,m=null,_=null,w=!1,b=null,x=null,D=null,I=null,R=null;const U=e.getParameter(35661);let P=!1,F=0;const N=e.getParameter(7938);-1!==N.indexOf("WebGL")?(F=parseFloat(/^WebGL (\d)/.exec(N)[1]),P=F>=1):-1!==N.indexOf("OpenGL ES")&&(F=parseFloat(/^OpenGL ES (\d)/.exec(N)[1]),P=F>=2);let L=null,A={};const B=new It,W=new It;function Y(C,X,se){const _e=new Uint8Array(4),Q=e.createTexture();e.bindTexture(C,Q),e.texParameteri(C,10241,9728),e.texParameteri(C,10240,9728);for(let ve=0;ve<se;ve++)e.texImage2D(X+ve,0,6408,1,1,0,6408,5121,_e);return Q}const oe={};function he(C){!0!==d[C]&&(e.enable(C),d[C]=!0)}function ue(C){!1!==d[C]&&(e.disable(C),d[C]=!1)}oe[3553]=Y(3553,3553,1),oe[34067]=Y(34067,34069,6),a.setClear(0,0,0,1),c.setClear(1),l.setClear(0),he(2929),c.setFunc(jd),Fe(!1),yt(Ng),he(2884),z($r);const nt={[is]:32774,[kE]:32778,[HE]:32779};if(i)nt[Ug]=32775,nt[Gg]=32776;else{const C=t.get("EXT_blend_minmax");null!==C&&(nt[Ug]=C.MIN_EXT,nt[Gg]=C.MAX_EXT)}const Qt={[VE]:0,[UE]:1,[GE]:768,[zg]:770,[XE]:776,[qE]:774,[jE]:772,[zE]:769,[jg]:771,[$E]:775,[WE]:773};function z(C,X,se,_e,Q,ve,Te,Ke){if(C!==$r){if(f||(he(3042),f=!0),C===BE)Q=Q||X,ve=ve||se,Te=Te||_e,(X!==p||Q!==g)&&(e.blendEquationSeparate(nt[X],nt[Q]),p=X,g=Q),(se!==y||_e!==v||ve!==m||Te!==_)&&(e.blendFuncSeparate(Qt[se],Qt[_e],Qt[ve],Qt[Te]),y=se,v=_e,m=ve,_=Te),h=C,w=null;else if(C!==h||Ke!==w){if((p!==is||g!==is)&&(e.blendEquation(32774),p=is,g=is),Ke)switch(C){case Sa:e.blendFuncSeparate(1,771,1,771);break;case kg:e.blendFunc(1,1);break;case Hg:e.blendFuncSeparate(0,0,769,771);break;case Vg:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",C)}else switch(C){case Sa:e.blendFuncSeparate(770,771,1,771);break;case kg:e.blendFunc(770,1);break;case Hg:e.blendFunc(0,769);break;case Vg:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",C)}y=null,v=null,m=null,_=null,h=C,w=Ke}}else f&&(ue(3042),f=!1)}function Fe(C){b!==C&&(e.frontFace(C?2304:2305),b=C)}function yt(C){C!==FE?(he(2884),C!==x&&e.cullFace(C===Ng?1029:C===NE?1028:1032)):ue(2884),x=C}function St(C,X,se){C?(he(32823),(I!==X||R!==se)&&(e.polygonOffset(X,se),I=X,R=se)):ue(32823)}function q(C){void 0===C&&(C=33984+U-1),L!==C&&(e.activeTexture(C),L=C)}return{buffers:{color:a,depth:c,stencil:l},enable:he,disable:ue,useProgram:function Je(C){return u!==C&&(e.useProgram(C),u=C,!0)},setBlending:z,setMaterial:function Vn(C,X){C.side===ll?ue(2884):he(2884);let se=C.side===wn;X&&(se=!se),Fe(se),C.blending===Sa&&!1===C.transparent?z($r):z(C.blending,C.blendEquation,C.blendSrc,C.blendDst,C.blendEquationAlpha,C.blendSrcAlpha,C.blendDstAlpha,C.premultipliedAlpha),c.setFunc(C.depthFunc),c.setTest(C.depthTest),c.setMask(C.depthWrite),a.setMask(C.colorWrite);const _e=C.stencilWrite;l.setTest(_e),_e&&(l.setMask(C.stencilWriteMask),l.setFunc(C.stencilFunc,C.stencilRef,C.stencilFuncMask),l.setOp(C.stencilFail,C.stencilZFail,C.stencilZPass)),St(C.polygonOffset,C.polygonOffsetFactor,C.polygonOffsetUnits)},setFlipSided:Fe,setCullFace:yt,setLineWidth:function Qe(C){C!==D&&(P&&e.lineWidth(C),D=C)},setPolygonOffset:St,setScissorTest:function lt(C){C?he(3089):ue(3089)},activeTexture:q,bindTexture:function Z(C,X){null===L&&q();let se=A[L];void 0===se&&(se={type:void 0,texture:void 0},A[L]=se),(se.type!==C||se.texture!==X)&&(e.bindTexture(C,X||oe[C]),se.type=C,se.texture=X)},unbindTexture:function K(){const C=A[L];void 0!==C&&void 0!==C.type&&(e.bindTexture(C.type,null),C.type=void 0,C.texture=void 0)},compressedTexImage2D:function Se(){try{e.compressedTexImage2D.apply(e,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},texImage2D:function ce(){try{e.texImage2D.apply(e,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},texImage3D:function T(){try{e.texImage3D.apply(e,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},scissor:function S(C){!1===B.equals(C)&&(e.scissor(C.x,C.y,C.z,C.w),B.copy(C))},viewport:function $(C){!1===W.equals(C)&&(e.viewport(C.x,C.y,C.z,C.w),W.copy(C))},reset:function j(){d={},L=null,A={},u=null,f=null,h=null,p=null,y=null,v=null,g=null,m=null,_=null,w=!1,b=null,x=null,D=null,I=null,R=null,a.reset(),c.reset(),l.reset()}}}function $U(e,t,n,i,r,o,s){const a=r.isWebGL2,c=r.maxTextures,l=r.maxCubemapSize,d=r.maxTextureSize,u=r.maxSamples,f=new WeakMap;let h,p=!1;try{p=typeof OffscreenCanvas<"u"&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch{}function y(T,S){return p?new OffscreenCanvas(T,S):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function v(T,S,$,j){let C=1;if((T.width>j||T.height>j)&&(C=j/Math.max(T.width,T.height)),C<1||!0===S){if(typeof HTMLImageElement<"u"&&T instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&T instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&T instanceof ImageBitmap){const X=S?ke.floorPowerOfTwo:Math.floor,se=X(C*T.width),_e=X(C*T.height);void 0===h&&(h=y(se,_e));const Q=$?y(se,_e):h;return Q.width=se,Q.height=_e,Q.getContext("2d").drawImage(T,0,0,se,_e),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+T.width+"x"+T.height+") to ("+se+"x"+_e+")."),Q}return"data"in T&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+T.width+"x"+T.height+")."),T}return T}function g(T){return ke.isPowerOfTwo(T.width)&&ke.isPowerOfTwo(T.height)}function _(T,S){return T.generateMipmaps&&S&&T.minFilter!==bn&&T.minFilter!==En}function w(T,S,$,j){e.generateMipmap(T),i.get(S).__maxMipLevel=Math.log(Math.max($,j))*Math.LOG2E}function b(T,S,$){if(!1===a)return S;if(null!==T){if(void 0!==e[T])return e[T];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+T+"'")}let j=S;return 6403===S&&(5126===$&&(j=33326),5131===$&&(j=33325),5121===$&&(j=33321)),6407===S&&(5126===$&&(j=34837),5131===$&&(j=34843),5121===$&&(j=32849)),6408===S&&(5126===$&&(j=34836),5131===$&&(j=34842),5121===$&&(j=32856)),(33325===j||33326===j||34842===j||34836===j)&&t.get("EXT_color_buffer_float"),j}function x(T){return T===bn||T===Xd||T===Yd?9728:9729}function D(T){const S=T.target;S.removeEventListener("dispose",D),function R(T){const S=i.get(T);void 0!==S.__webglInit&&(e.deleteTexture(S.__webglTexture),i.remove(T))}(S),S.isVideoTexture&&f.delete(S),s.memory.textures--}function I(T){const S=T.target;S.removeEventListener("dispose",I),function U(T){const S=i.get(T),$=i.get(T.texture);if(T){if(void 0!==$.__webglTexture&&e.deleteTexture($.__webglTexture),T.depthTexture&&T.depthTexture.dispose(),T.isWebGLCubeRenderTarget)for(let j=0;j<6;j++)e.deleteFramebuffer(S.__webglFramebuffer[j]),S.__webglDepthbuffer&&e.deleteRenderbuffer(S.__webglDepthbuffer[j]);else e.deleteFramebuffer(S.__webglFramebuffer),S.__webglDepthbuffer&&e.deleteRenderbuffer(S.__webglDepthbuffer),S.__webglMultisampledFramebuffer&&e.deleteFramebuffer(S.__webglMultisampledFramebuffer),S.__webglColorRenderbuffer&&e.deleteRenderbuffer(S.__webglColorRenderbuffer),S.__webglDepthRenderbuffer&&e.deleteRenderbuffer(S.__webglDepthRenderbuffer);i.remove(T.texture),i.remove(T)}}(S),s.memory.textures--}let P=0;function L(T,S){const $=i.get(T);if(T.isVideoTexture&&function q(T){const S=s.render.frame;f.get(T)!==S&&(f.set(T,S),T.update())}(T),T.version>0&&$.__version!==T.version){const j=T.image;if(void 0===j)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==j.complete)return void Je($,T,S);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+S),n.bindTexture(3553,$.__webglTexture)}function W(T,S){const $=i.get(T);T.version>0&&$.__version!==T.version?function nt(T,S,$){if(6!==S.image.length)return;ue(T,S),n.activeTexture(33984+$),n.bindTexture(34067,T.__webglTexture),e.pixelStorei(37440,S.flipY);const j=S&&(S.isCompressedTexture||S.image[0].isCompressedTexture),C=S.image[0]&&S.image[0].isDataTexture,X=[];for(let ye=0;ye<6;ye++)X[ye]=j||C?C?S.image[ye].image:S.image[ye]:v(S.image[ye],!1,!0,l);const se=X[0],_e=g(se)||a,Q=o.convert(S.format),ve=o.convert(S.type),Te=b(S.internalFormat,Q,ve);let Ke;if(he(34067,S,_e),j){for(let ye=0;ye<6;ye++){Ke=X[ye].mipmaps;for(let He=0;He<Ke.length;He++){const Kt=Ke[He];S.format!==gi&&S.format!==wo?null!==Q?n.compressedTexImage2D(34069+ye,He,Te,Kt.width,Kt.height,0,Kt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+ye,He,Te,Kt.width,Kt.height,0,Q,ve,Kt.data)}}T.__maxMipLevel=Ke.length-1}else{Ke=S.mipmaps;for(let ye=0;ye<6;ye++)if(C){n.texImage2D(34069+ye,0,Te,X[ye].width,X[ye].height,0,Q,ve,X[ye].data);for(let He=0;He<Ke.length;He++){const oi=Ke[He].image[ye].image;n.texImage2D(34069+ye,He+1,Te,oi.width,oi.height,0,Q,ve,oi.data)}}else{n.texImage2D(34069+ye,0,Te,Q,ve,X[ye]);for(let He=0;He<Ke.length;He++)n.texImage2D(34069+ye,He+1,Te,Q,ve,Ke[He].image[ye])}T.__maxMipLevel=Ke.length}_(S,_e)&&w(34067,S,se.width,se.height),T.__version=S.version,S.onUpdate&&S.onUpdate(S)}($,T,S):(n.activeTexture(33984+S),n.bindTexture(34067,$.__webglTexture))}const Y={[pl]:10497,[Xn]:33071,[ml]:33648},oe={[bn]:9728,[Xd]:9984,[Yd]:9986,[En]:9729,[Wg]:9985,[Da]:9987};function he(T,S,$){$?(e.texParameteri(T,10242,Y[S.wrapS]),e.texParameteri(T,10243,Y[S.wrapT]),(32879===T||35866===T)&&e.texParameteri(T,32882,Y[S.wrapR]),e.texParameteri(T,10240,oe[S.magFilter]),e.texParameteri(T,10241,oe[S.minFilter])):(e.texParameteri(T,10242,33071),e.texParameteri(T,10243,33071),(32879===T||35866===T)&&e.texParameteri(T,32882,33071),(S.wrapS!==Xn||S.wrapT!==Xn)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(T,10240,x(S.magFilter)),e.texParameteri(T,10241,x(S.minFilter)),S.minFilter!==bn&&S.minFilter!==En&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const j=t.get("EXT_texture_filter_anisotropic");if(j){if(S.type===Xr&&null===t.get("OES_texture_float_linear")||S.type===vl&&null===(a||t.get("OES_texture_half_float_linear")))return;(S.anisotropy>1||i.get(S).__currentAnisotropy)&&(e.texParameterf(T,j.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(S.anisotropy,r.getMaxAnisotropy())),i.get(S).__currentAnisotropy=S.anisotropy)}}function ue(T,S){void 0===T.__webglInit&&(T.__webglInit=!0,S.addEventListener("dispose",D),T.__webglTexture=e.createTexture(),s.memory.textures++)}function Je(T,S,$){let j=3553;S.isDataTexture2DArray&&(j=35866),S.isDataTexture3D&&(j=32879),ue(T,S),n.activeTexture(33984+$),n.bindTexture(j,T.__webglTexture),e.pixelStorei(37440,S.flipY),e.pixelStorei(37441,S.premultiplyAlpha),e.pixelStorei(3317,S.unpackAlignment);const C=function m(T){return!a&&(T.wrapS!==Xn||T.wrapT!==Xn||T.minFilter!==bn&&T.minFilter!==En)}(S)&&!1===g(S.image),X=v(S.image,C,!1,d),se=g(X)||a,_e=o.convert(S.format);let Te,Q=o.convert(S.type),ve=b(S.internalFormat,_e,Q);he(j,S,se);const Ke=S.mipmaps;if(S.isDepthTexture)ve=6402,a?ve=S.type===Xr?36012:S.type===yl?33190:S.type===Aa?35056:33189:S.type===Xr&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),S.format===os&&6402===ve&&S.type!==gl&&S.type!==yl&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),S.type=gl,Q=o.convert(S.type)),S.format===Ia&&6402===ve&&(ve=34041,S.type!==Aa&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),S.type=Aa,Q=o.convert(S.type))),n.texImage2D(3553,0,ve,X.width,X.height,0,_e,Q,null);else if(S.isDataTexture)if(Ke.length>0&&se){for(let ye=0,He=Ke.length;ye<He;ye++)Te=Ke[ye],n.texImage2D(3553,ye,ve,Te.width,Te.height,0,_e,Q,Te.data);S.generateMipmaps=!1,T.__maxMipLevel=Ke.length-1}else n.texImage2D(3553,0,ve,X.width,X.height,0,_e,Q,X.data),T.__maxMipLevel=0;else if(S.isCompressedTexture){for(let ye=0,He=Ke.length;ye<He;ye++)Te=Ke[ye],S.format!==gi&&S.format!==wo?null!==_e?n.compressedTexImage2D(3553,ye,ve,Te.width,Te.height,0,Te.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,ye,ve,Te.width,Te.height,0,_e,Q,Te.data);T.__maxMipLevel=Ke.length-1}else if(S.isDataTexture2DArray)n.texImage3D(35866,0,ve,X.width,X.height,X.depth,0,_e,Q,X.data),T.__maxMipLevel=0;else if(S.isDataTexture3D)n.texImage3D(32879,0,ve,X.width,X.height,X.depth,0,_e,Q,X.data),T.__maxMipLevel=0;else if(Ke.length>0&&se){for(let ye=0,He=Ke.length;ye<He;ye++)Te=Ke[ye],n.texImage2D(3553,ye,ve,_e,Q,Te);S.generateMipmaps=!1,T.__maxMipLevel=Ke.length-1}else n.texImage2D(3553,0,ve,_e,Q,X),T.__maxMipLevel=0;_(S,se)&&w(j,S,X.width,X.height),T.__version=S.version,S.onUpdate&&S.onUpdate(S)}function Qt(T,S,$,j){const C=o.convert(S.texture.format),X=o.convert(S.texture.type),se=b(S.texture.internalFormat,C,X);n.texImage2D(j,0,se,S.width,S.height,0,C,X,null),e.bindFramebuffer(36160,T),e.framebufferTexture2D(36160,$,j,i.get(S.texture).__webglTexture,0),e.bindFramebuffer(36160,null)}function z(T,S,$){if(e.bindRenderbuffer(36161,T),S.depthBuffer&&!S.stencilBuffer){let j=33189;if($){const C=S.depthTexture;C&&C.isDepthTexture&&(C.type===Xr?j=36012:C.type===yl&&(j=33190));const X=lt(S);e.renderbufferStorageMultisample(36161,X,j,S.width,S.height)}else e.renderbufferStorage(36161,j,S.width,S.height);e.framebufferRenderbuffer(36160,36096,36161,T)}else if(S.depthBuffer&&S.stencilBuffer){if($){const j=lt(S);e.renderbufferStorageMultisample(36161,j,35056,S.width,S.height)}else e.renderbufferStorage(36161,34041,S.width,S.height);e.framebufferRenderbuffer(36160,33306,36161,T)}else{const j=o.convert(S.texture.format),C=o.convert(S.texture.type),X=b(S.texture.internalFormat,j,C);if($){const se=lt(S);e.renderbufferStorageMultisample(36161,se,X,S.width,S.height)}else e.renderbufferStorage(36161,X,S.width,S.height)}e.bindRenderbuffer(36161,null)}function lt(T){return a&&T.isWebGLMultisampleRenderTarget?Math.min(u,T.samples):0}let Z=!1,K=!1;this.allocateTextureUnit=function N(){const T=P;return T>=c&&console.warn("THREE.WebGLTextures: Trying to use "+T+" texture units while this GPU supports only "+c),P+=1,T},this.resetTextureUnits=function F(){P=0},this.setTexture2D=L,this.setTexture2DArray=function A(T,S){const $=i.get(T);T.version>0&&$.__version!==T.version?Je($,T,S):(n.activeTexture(33984+S),n.bindTexture(35866,$.__webglTexture))},this.setTexture3D=function B(T,S){const $=i.get(T);T.version>0&&$.__version!==T.version?Je($,T,S):(n.activeTexture(33984+S),n.bindTexture(32879,$.__webglTexture))},this.setTextureCube=W,this.setupRenderTarget=function yt(T){const S=i.get(T),$=i.get(T.texture);T.addEventListener("dispose",I),$.__webglTexture=e.createTexture(),s.memory.textures++;const j=!0===T.isWebGLCubeRenderTarget,C=!0===T.isWebGLMultisampleRenderTarget,X=g(T)||a;if(a&&T.texture.format===wo&&(T.texture.type===Xr||T.texture.type===vl)&&(T.texture.format=gi,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),j){S.__webglFramebuffer=[];for(let se=0;se<6;se++)S.__webglFramebuffer[se]=e.createFramebuffer()}else if(S.__webglFramebuffer=e.createFramebuffer(),C)if(a){S.__webglMultisampledFramebuffer=e.createFramebuffer(),S.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(36161,S.__webglColorRenderbuffer);const se=o.convert(T.texture.format),_e=o.convert(T.texture.type),Q=b(T.texture.internalFormat,se,_e),ve=lt(T);e.renderbufferStorageMultisample(36161,ve,Q,T.width,T.height),e.bindFramebuffer(36160,S.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064,36161,S.__webglColorRenderbuffer),e.bindRenderbuffer(36161,null),T.depthBuffer&&(S.__webglDepthRenderbuffer=e.createRenderbuffer(),z(S.__webglDepthRenderbuffer,T,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(j){n.bindTexture(34067,$.__webglTexture),he(34067,T.texture,X);for(let se=0;se<6;se++)Qt(S.__webglFramebuffer[se],T,36064,34069+se);_(T.texture,X)&&w(34067,T.texture,T.width,T.height),n.bindTexture(34067,null)}else n.bindTexture(3553,$.__webglTexture),he(3553,T.texture,X),Qt(S.__webglFramebuffer,T,36064,3553),_(T.texture,X)&&w(3553,T.texture,T.width,T.height),n.bindTexture(3553,null);T.depthBuffer&&function Fe(T){const S=i.get(T),$=!0===T.isWebGLCubeRenderTarget;if(T.depthTexture){if($)throw new Error("target.depthTexture not supported in Cube render targets");!function Vn(T,S){if(S&&S.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,T),!S.depthTexture||!S.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(S.depthTexture).__webglTexture||S.depthTexture.image.width!==S.width||S.depthTexture.image.height!==S.height)&&(S.depthTexture.image.width=S.width,S.depthTexture.image.height=S.height,S.depthTexture.needsUpdate=!0),L(S.depthTexture,0);const j=i.get(S.depthTexture).__webglTexture;if(S.depthTexture.format===os)e.framebufferTexture2D(36160,36096,3553,j,0);else{if(S.depthTexture.format!==Ia)throw new Error("Unknown depthTexture format");e.framebufferTexture2D(36160,33306,3553,j,0)}}(S.__webglFramebuffer,T)}else if($){S.__webglDepthbuffer=[];for(let j=0;j<6;j++)e.bindFramebuffer(36160,S.__webglFramebuffer[j]),S.__webglDepthbuffer[j]=e.createRenderbuffer(),z(S.__webglDepthbuffer[j],T,!1)}else e.bindFramebuffer(36160,S.__webglFramebuffer),S.__webglDepthbuffer=e.createRenderbuffer(),z(S.__webglDepthbuffer,T,!1);e.bindFramebuffer(36160,null)}(T)},this.updateRenderTargetMipmap=function Qe(T){const S=T.texture;if(_(S,g(T)||a)){const j=T.isWebGLCubeRenderTarget?34067:3553,C=i.get(S).__webglTexture;n.bindTexture(j,C),w(j,S,T.width,T.height),n.bindTexture(j,null)}},this.updateMultisampleRenderTarget=function St(T){if(T.isWebGLMultisampleRenderTarget)if(a){const S=i.get(T);e.bindFramebuffer(36008,S.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,S.__webglFramebuffer);const $=T.width,j=T.height;let C=16384;T.depthBuffer&&(C|=256),T.stencilBuffer&&(C|=1024),e.blitFramebuffer(0,0,$,j,0,0,$,j,C,9728),e.bindFramebuffer(36160,S.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function Se(T,S){T&&T.isWebGLRenderTarget&&(!1===Z&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Z=!0),T=T.texture),L(T,S)},this.safeSetTextureCube=function ce(T,S){T&&T.isWebGLCubeRenderTarget&&(!1===K&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),K=!0),T=T.texture),W(T,S)}}function XT(e,t,n){const i=n.isWebGL2;return{convert:function r(o){let s;if(o===Ca)return 5121;if(o===fS)return 32819;if(o===hS)return 32820;if(o===pS)return 33635;if(o===lS)return 5120;if(o===uS)return 5122;if(o===gl)return 5123;if(o===dS)return 5124;if(o===yl)return 5125;if(o===Xr)return 5126;if(o===vl)return i?5131:(s=t.get("OES_texture_half_float"),null!==s?s.HALF_FLOAT_OES:null);if(o===mS)return 6406;if(o===wo)return 6407;if(o===gi)return 6408;if(o===gS)return 6409;if(o===yS)return 6410;if(o===os)return 6402;if(o===Ia)return 34041;if(o===_S)return 6403;if(o===xS)return 36244;if(o===wS)return 33319;if(o===bS)return 33320;if(o===MS)return 36248;if(o===ES)return 36249;if(o===qg||o===$g||o===Xg||o===Yg){if(s=t.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(o===qg)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(o===$g)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(o===Xg)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(o===Yg)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(o===Zg||o===Jg||o===Qg||o===Kg){if(s=t.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(o===Zg)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(o===Jg)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(o===Qg)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(o===Kg)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(o===SS)return s=t.get("WEBGL_compressed_texture_etc1"),null!==s?s.COMPRESSED_RGB_ETC1_WEBGL:null;if((o===ey||o===ty)&&(s=t.get("WEBGL_compressed_texture_etc"),null!==s)){if(o===ey)return s.COMPRESSED_RGB8_ETC2;if(o===ty)return s.COMPRESSED_RGBA8_ETC2_EAC}return o===TS||o===DS||o===CS||o===AS||o===IS||o===LS||o===RS||o===PS||o===FS||o===NS||o===OS||o===BS||o===kS||o===HS||o===US||o===GS||o===zS||o===jS||o===WS||o===qS||o===$S||o===XS||o===YS||o===ZS||o===JS||o===QS||o===KS||o===eT?(s=t.get("WEBGL_compressed_texture_astc"),null!==s?o:null):o===VS?(s=t.get("EXT_texture_compression_bptc"),null!==s?o:null):o===Aa?i?34042:(s=t.get("WEBGL_depth_texture"),null!==s?s.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}function vf(e=[]){pn.call(this),this.cameras=e}function Ro(){ge.call(this),this.type="Group"}function Gl(){this._targetRay=null,this._grip=null,this._hand=null}function YT(e,t){const n=this;let i=null,r=1,o=null,s="local-floor",a=null;const c=[],l=new Map,d=new pn;d.layers.enable(1),d.viewport=new It;const u=new pn;u.layers.enable(2),u.viewport=new It;const f=[d,u],h=new vf;h.layers.enable(1),h.layers.enable(2);let p=null,y=null;function v(P){const F=l.get(P.inputSource);F&&F.dispatchEvent({type:P.type,data:P.inputSource})}function g(){l.forEach(function(P,F){P.disconnect(F)}),l.clear(),e.setFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),U.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function m(P){o=P,U.setContext(i),U.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}function _(P){const F=i.inputSources;for(let N=0;N<c.length;N++)l.set(F[N],c[N]);for(let N=0;N<P.removed.length;N++){const L=P.removed[N],A=l.get(L);A&&(A.dispatchEvent({type:"disconnected",data:L}),l.delete(L))}for(let N=0;N<P.added.length;N++){const L=P.added[N],A=l.get(L);A&&A.dispatchEvent({type:"connected",data:L})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(P){let F=c[P];return void 0===F&&(F=new Gl,c[P]=F),F.getTargetRaySpace()},this.getControllerGrip=function(P){let F=c[P];return void 0===F&&(F=new Gl,c[P]=F),F.getGripSpace()},this.getHand=function(P){let F=c[P];return void 0===F&&(F=new Gl,c[P]=F),F.getHandSpace()},this.setFramebufferScaleFactor=function(P){r=P,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(P){s=P,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getSession=function(){return i},this.setSession=function(P){if(i=P,null!==i){i.addEventListener("select",v),i.addEventListener("selectstart",v),i.addEventListener("selectend",v),i.addEventListener("squeeze",v),i.addEventListener("squeezestart",v),i.addEventListener("squeezeend",v),i.addEventListener("end",g);const F=t.getContextAttributes();!0!==F.xrCompatible&&t.makeXRCompatible();const L=new XRWebGLLayer(i,t,{antialias:F.antialias,alpha:F.alpha,depth:F.depth,stencil:F.stencil,framebufferScaleFactor:r});i.updateRenderState({baseLayer:L}),i.requestReferenceSpace(s).then(m),i.addEventListener("inputsourceschange",_)}};const w=new M,b=new M;function D(P,F){null===F?P.matrixWorld.copy(P.matrix):P.matrixWorld.multiplyMatrices(F.matrixWorld,P.matrix),P.matrixWorldInverse.copy(P.matrixWorld).invert()}this.getCamera=function(P){h.near=u.near=d.near=P.near,h.far=u.far=d.far=P.far,(p!==h.near||y!==h.far)&&(i.updateRenderState({depthNear:h.near,depthFar:h.far}),p=h.near,y=h.far);const F=P.parent,N=h.cameras;D(h,F);for(let A=0;A<N.length;A++)D(N[A],F);P.matrixWorld.copy(h.matrixWorld);const L=P.children;for(let A=0,B=L.length;A<B;A++)L[A].updateMatrixWorld(!0);return 2===N.length?function x(P,F,N){w.setFromMatrixPosition(F.matrixWorld),b.setFromMatrixPosition(N.matrixWorld);const L=w.distanceTo(b),A=F.projectionMatrix.elements,B=N.projectionMatrix.elements,W=A[14]/(A[10]-1),Y=A[14]/(A[10]+1),oe=(A[9]+1)/A[5],he=(A[9]-1)/A[5],ue=(A[8]-1)/A[0],Je=(B[8]+1)/B[0],nt=W*ue,Qt=W*Je,z=L/(-ue+Je),Vn=z*-ue;F.matrixWorld.decompose(P.position,P.quaternion,P.scale),P.translateX(Vn),P.translateZ(z),P.matrixWorld.compose(P.position,P.quaternion,P.scale),P.matrixWorldInverse.copy(P.matrixWorld).invert();const Fe=W+z,yt=Y+z;P.projectionMatrix.makePerspective(nt-Vn,Qt+(L-Vn),oe*Y/yt*Fe,he*Y/yt*Fe,Fe,yt)}(h,d,u):h.projectionMatrix.copy(d.projectionMatrix),h};let I=null;const U=new ST;U.setAnimationLoop(function R(P,F){if(a=F.getViewerPose(o),null!==a){const L=a.views,A=i.renderState.baseLayer;e.setFramebuffer(A.framebuffer);let B=!1;L.length!==h.cameras.length&&(h.cameras.length=0,B=!0);for(let W=0;W<L.length;W++){const Y=L[W],oe=A.getViewport(Y),he=f[W];he.matrix.fromArray(Y.transform.matrix),he.projectionMatrix.fromArray(Y.projectionMatrix),he.viewport.set(oe.x,oe.y,oe.width,oe.height),0===W&&h.matrix.copy(he.matrix),!0===B&&h.cameras.push(he)}}const N=i.inputSources;for(let L=0;L<c.length;L++)c[L].update(N[L],F,o);I&&I(P,F)}),this.setAnimationLoop=function(P){I=P},this.dispose=function(){}}function XU(e){function i(g,m){g.opacity.value=m.opacity,m.color&&g.diffuse.value.copy(m.color),m.emissive&&g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.specularMap&&(g.specularMap.value=m.specularMap);const _=e.get(m).envMap;if(_){g.envMap.value=_,g.flipEnvMap.value=_.isCubeTexture&&_._needsFlipEnvMap?-1:1,g.reflectivity.value=m.reflectivity,g.refractionRatio.value=m.refractionRatio;const x=e.get(_).__maxMipLevel;void 0!==x&&(g.maxMipLevel.value=x)}let w,b;m.lightMap&&(g.lightMap.value=m.lightMap,g.lightMapIntensity.value=m.lightMapIntensity),m.aoMap&&(g.aoMap.value=m.aoMap,g.aoMapIntensity.value=m.aoMapIntensity),m.map?w=m.map:m.specularMap?w=m.specularMap:m.displacementMap?w=m.displacementMap:m.normalMap?w=m.normalMap:m.bumpMap?w=m.bumpMap:m.roughnessMap?w=m.roughnessMap:m.metalnessMap?w=m.metalnessMap:m.alphaMap?w=m.alphaMap:m.emissiveMap?w=m.emissiveMap:m.clearcoatMap?w=m.clearcoatMap:m.clearcoatNormalMap?w=m.clearcoatNormalMap:m.clearcoatRoughnessMap&&(w=m.clearcoatRoughnessMap),void 0!==w&&(w.isWebGLRenderTarget&&(w=w.texture),!0===w.matrixAutoUpdate&&w.updateMatrix(),g.uvTransform.value.copy(w.matrix)),m.aoMap?b=m.aoMap:m.lightMap&&(b=m.lightMap),void 0!==b&&(b.isWebGLRenderTarget&&(b=b.texture),!0===b.matrixAutoUpdate&&b.updateMatrix(),g.uv2Transform.value.copy(b.matrix))}function u(g,m){g.roughness.value=m.roughness,g.metalness.value=m.metalness,m.roughnessMap&&(g.roughnessMap.value=m.roughnessMap),m.metalnessMap&&(g.metalnessMap.value=m.metalnessMap),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===wn&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===wn&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),e.get(m).envMap&&(g.envMapIntensity.value=m.envMapIntensity)}return{refreshFogUniforms:function t(g,m){g.fogColor.value.copy(m.color),m.isFog?(g.fogNear.value=m.near,g.fogFar.value=m.far):m.isFogExp2&&(g.fogDensity.value=m.density)},refreshMaterialUniforms:function n(g,m,_,w){m.isMeshBasicMaterial?i(g,m):m.isMeshLambertMaterial?(i(g,m),function c(g,m){m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap)}(g,m)):m.isMeshToonMaterial?(i(g,m),function d(g,m){m.gradientMap&&(g.gradientMap.value=m.gradientMap),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===wn&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===wn&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}(g,m)):m.isMeshPhongMaterial?(i(g,m),function l(g,m){g.specular.value.copy(m.specular),g.shininess.value=Math.max(m.shininess,1e-4),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===wn&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===wn&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}(g,m)):m.isMeshStandardMaterial?(i(g,m),m.isMeshPhysicalMaterial?function f(g,m){u(g,m),g.reflectivity.value=m.reflectivity,g.clearcoat.value=m.clearcoat,g.clearcoatRoughness.value=m.clearcoatRoughness,m.sheen&&g.sheen.value.copy(m.sheen),m.clearcoatMap&&(g.clearcoatMap.value=m.clearcoatMap),m.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=m.clearcoatRoughnessMap),m.clearcoatNormalMap&&(g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),g.clearcoatNormalMap.value=m.clearcoatNormalMap,m.side===wn&&g.clearcoatNormalScale.value.negate()),g.transmission.value=m.transmission,m.transmissionMap&&(g.transmissionMap.value=m.transmissionMap)}(g,m):u(g,m)):m.isMeshMatcapMaterial?(i(g,m),function h(g,m){m.matcap&&(g.matcap.value=m.matcap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===wn&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===wn&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}(g,m)):m.isMeshDepthMaterial?(i(g,m),function p(g,m){m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}(g,m)):m.isMeshDistanceMaterial?(i(g,m),function y(g,m){m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),g.referencePosition.value.copy(m.referencePosition),g.nearDistance.value=m.nearDistance,g.farDistance.value=m.farDistance}(g,m)):m.isMeshNormalMaterial?(i(g,m),function v(g,m){m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===wn&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===wn&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}(g,m)):m.isLineBasicMaterial?(function r(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity}(g,m),m.isLineDashedMaterial&&function o(g,m){g.dashSize.value=m.dashSize,g.totalSize.value=m.dashSize+m.gapSize,g.scale.value=m.scale}(g,m)):m.isPointsMaterial?function s(g,m,_,w){let b;g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.size.value=m.size*_,g.scale.value=.5*w,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.map?b=m.map:m.alphaMap&&(b=m.alphaMap),void 0!==b&&(!0===b.matrixAutoUpdate&&b.updateMatrix(),g.uvTransform.value.copy(b.matrix))}(g,m,_,w):m.isSpriteMaterial?function a(g,m){let _;g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.rotation.value=m.rotation,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.map?_=m.map:m.alphaMap&&(_=m.alphaMap),void 0!==_&&(!0===_.matrixAutoUpdate&&_.updateMatrix(),g.uvTransform.value.copy(_.matrix))}(g,m):m.isShadowMaterial?(g.color.value.copy(m.color),g.opacity.value=m.opacity):m.isShaderMaterial&&(m.uniformsNeedUpdate=!1)}}}function zl(e){const t=void 0!==(e=e||{}).canvas?e.canvas:function YU(){const e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return e.style.display="block",e}(),n=void 0!==e.context?e.context:null,i=void 0!==e.alpha&&e.alpha,r=void 0===e.depth||e.depth,o=void 0===e.stencil||e.stencil,s=void 0!==e.antialias&&e.antialias,a=void 0===e.premultipliedAlpha||e.premultipliedAlpha,c=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,l=void 0!==e.powerPreference?e.powerPreference:"default",d=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;let u=null,f=null;const h=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Yn,this.physicallyCorrectLights=!1,this.toneMapping=rs,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const p=this;let y=!1,v=null,g=0,m=0,_=null,w=null,b=-1,x=null;const D=new It,I=new It;let R=null,U=t.width,P=t.height,F=1,N=null,L=null;const A=new It(0,0,U,P),B=new It(0,0,U,P);let W=!1;const Y=new Hl;let oe=!1,he=!1;const ue=new Ze,Je=new M,nt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Qt(){return null===_?F:1}let Fe,yt,Qe,St,lt,q,Z,K,Se,ce,T,S,$,j,C,X,se,_e,Q,ve,Te,z=n;function Vn(E,k){for(let O=0;O<E.length;O++){const re=t.getContext(E[O],k);if(null!==re)return re}return null}try{const E={alpha:i,depth:r,stencil:o,antialias:s,premultipliedAlpha:a,preserveDrawingBuffer:c,powerPreference:l,failIfMajorPerformanceCaveat:d};if(t.addEventListener("webglcontextlost",Kt,!1),t.addEventListener("webglcontextrestored",oi,!1),null===z){const k=["webgl2","webgl","experimental-webgl"];if(!0===p.isWebGL1Renderer&&k.shift(),z=Vn(k,E),null===z)throw Vn(k)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===z.getShaderPrecisionFormat&&(z.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(E){throw console.error("THREE.WebGLRenderer: "+E.message),E}function Ke(){Fe=new DV(z),yt=new EV(z,Fe,e),!1===yt.isWebGL2&&(Fe.get("WEBGL_depth_texture"),Fe.get("OES_texture_float"),Fe.get("OES_texture_half_float"),Fe.get("OES_texture_half_float_linear"),Fe.get("OES_standard_derivatives"),Fe.get("OES_element_index_uint"),Fe.get("OES_vertex_array_object"),Fe.get("ANGLE_instanced_arrays")),Fe.get("OES_texture_float_linear"),ve=new XT(z,Fe,yt),Qe=new qU(z,Fe,yt),Qe.scissor(I.copy(B).multiplyScalar(F).floor()),Qe.viewport(D.copy(A).multiplyScalar(F).floor()),St=new IV(z),lt=new FU,q=new $U(z,Fe,Qe,lt,yt,ve,St),Z=new TV(p),K=new KB(z,yt),Te=new bV(z,Fe,K,yt),Se=new CV(z,K,St,Te),ce=new FV(z,Se,K,St),se=new PV(z),C=new SV(lt),T=new PU(p,Z,Fe,yt,Te,C),S=new XU(lt),$=new BU(lt),j=new zU(Fe,yt),X=new wV(p,Z,Qe,ce,a),_e=new MV(z,Fe,St,yt),Q=new AV(z,Fe,St,yt),St.programs=T.programs,p.capabilities=yt,p.extensions=Fe,p.properties=lt,p.renderLists=$,p.state=Qe,p.info=St}Ke();const ye=new YT(p,z);this.xr=ye;const He=new $T(p,ce,yt.maxTextureSize);function Kt(E){E.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),y=!0}function oi(){console.log("THREE.WebGLRenderer: Context Restored."),y=!1,Ke()}function b1(E){const k=E.target;k.removeEventListener("dispose",b1),function Qz(E){M1(E),lt.remove(E)}(k)}function M1(E){const k=lt.get(E).program;void 0!==k&&T.releaseProgram(k)}this.shadowMap=He,this.getContext=function(){return z},this.getContextAttributes=function(){return z.getContextAttributes()},this.forceContextLoss=function(){const E=Fe.get("WEBGL_lose_context");E&&E.loseContext()},this.forceContextRestore=function(){const E=Fe.get("WEBGL_lose_context");E&&E.restoreContext()},this.getPixelRatio=function(){return F},this.setPixelRatio=function(E){void 0!==E&&(F=E,this.setSize(U,P,!1))},this.getSize=function(E){return void 0===E&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),E=new V),E.set(U,P)},this.setSize=function(E,k,O){ye.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(U=E,P=k,t.width=Math.floor(E*F),t.height=Math.floor(k*F),!1!==O&&(t.style.width=E+"px",t.style.height=k+"px"),this.setViewport(0,0,E,k))},this.getDrawingBufferSize=function(E){return void 0===E&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),E=new V),E.set(U*F,P*F).floor()},this.setDrawingBufferSize=function(E,k,O){U=E,P=k,F=O,t.width=Math.floor(E*O),t.height=Math.floor(k*O),this.setViewport(0,0,E,k)},this.getCurrentViewport=function(E){return void 0===E&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),E=new It),E.copy(D)},this.getViewport=function(E){return E.copy(A)},this.setViewport=function(E,k,O,H){E.isVector4?A.set(E.x,E.y,E.z,E.w):A.set(E,k,O,H),Qe.viewport(D.copy(A).multiplyScalar(F).floor())},this.getScissor=function(E){return E.copy(B)},this.setScissor=function(E,k,O,H){E.isVector4?B.set(E.x,E.y,E.z,E.w):B.set(E,k,O,H),Qe.scissor(I.copy(B).multiplyScalar(F).floor())},this.getScissorTest=function(){return W},this.setScissorTest=function(E){Qe.setScissorTest(W=E)},this.setOpaqueSort=function(E){N=E},this.setTransparentSort=function(E){L=E},this.getClearColor=function(E){return void 0===E&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),E=new ae),E.copy(X.getClearColor())},this.setClearColor=function(){X.setClearColor.apply(X,arguments)},this.getClearAlpha=function(){return X.getClearAlpha()},this.setClearAlpha=function(){X.setClearAlpha.apply(X,arguments)},this.clear=function(E,k,O){let H=0;(void 0===E||E)&&(H|=16384),(void 0===k||k)&&(H|=256),(void 0===O||O)&&(H|=1024),z.clear(H)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Kt,!1),t.removeEventListener("webglcontextrestored",oi,!1),$.dispose(),j.dispose(),lt.dispose(),Z.dispose(),ce.dispose(),Te.dispose(),ye.dispose(),pu.stop()},this.renderBufferImmediate=function(E,k){Te.initAttributes();const O=lt.get(E);E.hasPositions&&!O.position&&(O.position=z.createBuffer()),E.hasNormals&&!O.normal&&(O.normal=z.createBuffer()),E.hasUvs&&!O.uv&&(O.uv=z.createBuffer()),E.hasColors&&!O.color&&(O.color=z.createBuffer());const H=k.getAttributes();E.hasPositions&&(z.bindBuffer(34962,O.position),z.bufferData(34962,E.positionArray,35048),Te.enableAttribute(H.position),z.vertexAttribPointer(H.position,3,5126,!1,0,0)),E.hasNormals&&(z.bindBuffer(34962,O.normal),z.bufferData(34962,E.normalArray,35048),Te.enableAttribute(H.normal),z.vertexAttribPointer(H.normal,3,5126,!1,0,0)),E.hasUvs&&(z.bindBuffer(34962,O.uv),z.bufferData(34962,E.uvArray,35048),Te.enableAttribute(H.uv),z.vertexAttribPointer(H.uv,2,5126,!1,0,0)),E.hasColors&&(z.bindBuffer(34962,O.color),z.bufferData(34962,E.colorArray,35048),Te.enableAttribute(H.color),z.vertexAttribPointer(H.color,3,5126,!1,0,0)),Te.disableUnusedAttributes(),z.drawArrays(4,0,E.count),E.count=0},this.renderBufferDirect=function(E,k,O,H,re,ft){null===k&&(k=nt);const st=re.isMesh&&re.matrixWorld.determinant()<0,mt=D1(E,k,H,re);Qe.setMaterial(H,st);let at=O.index;const mn=O.attributes.position;if(null===at){if(void 0===mn||0===mn.count)return}else if(0===at.count)return;let ln=1;!0===H.wireframe&&(at=Se.getWireframeAttribute(O),ln=2),(H.morphTargets||H.morphNormals)&&se.update(re,O,H,mt),Te.setup(re,H,mt,O,at);let et,Ht=_e;null!==at&&(et=K.get(at),Ht=Q,Ht.setIndex(et));const co=null!==at?at.count:mn.count,Vt=O.drawRange.start*ln,Ls=O.drawRange.count*ln,Tn=null!==ft?ft.start*ln:0,Vv=null!==ft?ft.count*ln:1/0,si=Math.max(Vt,Tn),mu=Math.min(co,Vt+Ls,Tn+Vv)-1,hc=Math.max(0,mu-si+1);if(0!==hc){if(re.isMesh)!0===H.wireframe?(Qe.setLineWidth(H.wireframeLinewidth*Qt()),Ht.setMode(1)):Ht.setMode(4);else if(re.isLine){let gu=H.linewidth;void 0===gu&&(gu=1),Qe.setLineWidth(gu*Qt()),Ht.setMode(re.isLineSegments?1:re.isLineLoop?2:3)}else re.isPoints?Ht.setMode(0):re.isSprite&&Ht.setMode(4);if(re.isInstancedMesh)Ht.renderInstances(si,hc,re.count);else if(O.isInstancedBufferGeometry){const gu=Math.min(O.instanceCount,O._maxInstanceCount);Ht.renderInstances(si,hc,gu)}else Ht.render(si,hc)}},this.compile=function(E,k){f=j.get(E),f.init(),E.traverseVisible(function(H){H.isLight&&H.layers.test(k.layers)&&(f.pushLight(H),H.castShadow&&f.pushShadow(H))}),f.setupLights();const O=new WeakMap;E.traverse(function(H){const re=H.material;if(re)if(Array.isArray(re))for(let ft=0;ft<re.length;ft++){const st=re[ft];!1===O.has(st)&&(ao(st,E,H),O.set(st))}else!1===O.has(re)&&(ao(re,E,H),O.set(re))})};let Hv=null;const pu=new ST;function E1(E,k,O,H){if(!1===E.visible)return;if(E.layers.test(k.layers))if(E.isGroup)O=E.renderOrder;else if(E.isLOD)!0===E.autoUpdate&&E.update(k);else if(E.isLight)f.pushLight(E),E.castShadow&&f.pushShadow(E);else if(E.isSprite){if(!E.frustumCulled||Y.intersectsSprite(E)){H&&Je.setFromMatrixPosition(E.matrixWorld).applyMatrix4(ue);const st=ce.update(E),mt=E.material;mt.visible&&u.push(E,st,mt,O,Je.z,null)}}else if(E.isImmediateRenderObject)H&&Je.setFromMatrixPosition(E.matrixWorld).applyMatrix4(ue),u.push(E,null,E.material,O,Je.z,null);else if((E.isMesh||E.isLine||E.isPoints)&&(E.isSkinnedMesh&&E.skeleton.frame!==St.render.frame&&(E.skeleton.update(),E.skeleton.frame=St.render.frame),!E.frustumCulled||Y.intersectsObject(E))){H&&Je.setFromMatrixPosition(E.matrixWorld).applyMatrix4(ue);const st=ce.update(E),mt=E.material;if(Array.isArray(mt)){const at=st.groups;for(let mn=0,ln=at.length;mn<ln;mn++){const et=at[mn],Ht=mt[et.materialIndex];Ht&&Ht.visible&&u.push(E,st,Ht,O,Je.z,et)}}else mt.visible&&u.push(E,st,mt,O,Je.z,null)}const ft=E.children;for(let st=0,mt=ft.length;st<mt;st++)E1(ft[st],k,O,H)}function S1(E,k,O){const H=!0===k.isScene?k.overrideMaterial:null;for(let re=0,ft=E.length;re<ft;re++){const st=E[re],mt=st.object,at=st.geometry,mn=null===H?st.material:H,ln=st.group;if(O.isArrayCamera){const et=O.cameras;for(let Ht=0,co=et.length;Ht<co;Ht++){const Vt=et[Ht];mt.layers.test(Vt.layers)&&(Qe.viewport(D.copy(Vt.viewport)),f.setupLightsView(Vt),T1(mt,k,Vt,at,mn,ln))}}else T1(mt,k,O,at,mn,ln)}}function T1(E,k,O,H,re,ft){if(E.onBeforeRender(p,k,O,H,re,ft),E.modelViewMatrix.multiplyMatrices(O.matrixWorldInverse,E.matrixWorld),E.normalMatrix.getNormalMatrix(E.modelViewMatrix),E.isImmediateRenderObject){const st=D1(O,k,re,E);Qe.setMaterial(re),Te.reset(),function Kz(E,k){E.render(function(O){p.renderBufferImmediate(O,k)})}(E,st)}else p.renderBufferDirect(O,k,H,re,E,ft);E.onAfterRender(p,k,O,H,re,ft)}function ao(E,k,O){!0!==k.isScene&&(k=nt);const H=lt.get(E),re=f.state.lights,st=re.state.version,mt=T.getParameters(E,re.state,f.state.shadowsArray,k,O),at=T.getProgramCacheKey(mt);let mn=H.program,ln=!0;if(void 0===mn)E.addEventListener("dispose",b1);else if(mn.cacheKey!==at)M1(E);else if(H.lightsStateVersion!==st)ln=!1;else{if(void 0!==mt.shaderID){const Vt=E.isMeshStandardMaterial?k.environment:null;return void(H.envMap=Z.get(E.envMap||Vt))}ln=!1}ln&&(mt.uniforms=T.getUniforms(E),E.onBeforeCompile(mt,p),mn=T.acquireProgram(mt,at),H.program=mn,H.uniforms=mt.uniforms,H.outputEncoding=mt.outputEncoding);const et=H.uniforms;(!E.isShaderMaterial&&!E.isRawShaderMaterial||!0===E.clipping)&&(H.numClippingPlanes=C.numPlanes,H.numIntersection=C.numIntersection,et.clippingPlanes=C.uniform),H.environment=E.isMeshStandardMaterial?k.environment:null,H.fog=k.fog,H.envMap=Z.get(E.envMap||H.environment),H.needsLights=function n4(E){return E.isMeshLambertMaterial||E.isMeshToonMaterial||E.isMeshPhongMaterial||E.isMeshStandardMaterial||E.isShadowMaterial||E.isShaderMaterial&&!0===E.lights}(E),H.lightsStateVersion=st,H.needsLights&&(et.ambientLightColor.value=re.state.ambient,et.lightProbe.value=re.state.probe,et.directionalLights.value=re.state.directional,et.directionalLightShadows.value=re.state.directionalShadow,et.spotLights.value=re.state.spot,et.spotLightShadows.value=re.state.spotShadow,et.rectAreaLights.value=re.state.rectArea,et.ltc_1.value=re.state.rectAreaLTC1,et.ltc_2.value=re.state.rectAreaLTC2,et.pointLights.value=re.state.point,et.pointLightShadows.value=re.state.pointShadow,et.hemisphereLights.value=re.state.hemi,et.directionalShadowMap.value=re.state.directionalShadowMap,et.directionalShadowMatrix.value=re.state.directionalShadowMatrix,et.spotShadowMap.value=re.state.spotShadowMap,et.spotShadowMatrix.value=re.state.spotShadowMatrix,et.pointShadowMap.value=re.state.pointShadowMap,et.pointShadowMatrix.value=re.state.pointShadowMatrix);const Ht=H.program.getUniforms(),co=Ao.seqWithValue(Ht.seq,et);H.uniformsList=co}function D1(E,k,O,H){!0!==k.isScene&&(k=nt),q.resetTextureUnits();const re=k.fog,ft=O.isMeshStandardMaterial?k.environment:null,st=null===_?p.outputEncoding:_.texture.encoding,mt=Z.get(O.envMap||ft),at=lt.get(O),mn=f.state.lights;!0!==oe||!0!==he&&E===x||C.setState(O,E,E===x&&O.id===b),O.version===at.__version?(O.fog&&at.fog!==re||at.environment!==ft||at.needsLights&&at.lightsStateVersion!==mn.state.version||void 0!==at.numClippingPlanes&&(at.numClippingPlanes!==C.numPlanes||at.numIntersection!==C.numIntersection)||at.outputEncoding!==st||at.envMap!==mt)&&ao(O,k,H):(ao(O,k,H),at.__version=O.version);let ln=!1,et=!1,Ht=!1;const co=at.program,Vt=co.getUniforms(),Ls=at.uniforms;if(Qe.useProgram(co.program)&&(ln=!0,et=!0,Ht=!0),O.id!==b&&(b=O.id,et=!0),ln||x!==E){if(Vt.setValue(z,"projectionMatrix",E.projectionMatrix),yt.logarithmicDepthBuffer&&Vt.setValue(z,"logDepthBufFC",2/(Math.log(E.far+1)/Math.LN2)),x!==E&&(x=E,et=!0,Ht=!0),O.isShaderMaterial||O.isMeshPhongMaterial||O.isMeshToonMaterial||O.isMeshStandardMaterial||O.envMap){const Tn=Vt.map.cameraPosition;void 0!==Tn&&Tn.setValue(z,Je.setFromMatrixPosition(E.matrixWorld))}(O.isMeshPhongMaterial||O.isMeshToonMaterial||O.isMeshLambertMaterial||O.isMeshBasicMaterial||O.isMeshStandardMaterial||O.isShaderMaterial)&&Vt.setValue(z,"isOrthographic",!0===E.isOrthographicCamera),(O.isMeshPhongMaterial||O.isMeshToonMaterial||O.isMeshLambertMaterial||O.isMeshBasicMaterial||O.isMeshStandardMaterial||O.isShaderMaterial||O.isShadowMaterial||O.skinning)&&Vt.setValue(z,"viewMatrix",E.matrixWorldInverse)}if(O.skinning){Vt.setOptional(z,H,"bindMatrix"),Vt.setOptional(z,H,"bindMatrixInverse");const Tn=H.skeleton;if(Tn){const Vv=Tn.bones;if(yt.floatVertexTextures){if(null===Tn.boneTexture){let si=Math.sqrt(4*Vv.length);si=ke.ceilPowerOfTwo(si),si=Math.max(si,4);const mu=new Float32Array(si*si*4);mu.set(Tn.boneMatrices);const hc=new no(mu,si,si,gi,Xr);Tn.boneMatrices=mu,Tn.boneTexture=hc,Tn.boneTextureSize=si}Vt.setValue(z,"boneTexture",Tn.boneTexture,q),Vt.setValue(z,"boneTextureSize",Tn.boneTextureSize)}else Vt.setOptional(z,Tn,"boneMatrices")}}return(et||at.receiveShadow!==H.receiveShadow)&&(at.receiveShadow=H.receiveShadow,Vt.setValue(z,"receiveShadow",H.receiveShadow)),et&&(Vt.setValue(z,"toneMappingExposure",p.toneMappingExposure),at.needsLights&&function t4(E,k){E.ambientLightColor.needsUpdate=k,E.lightProbe.needsUpdate=k,E.directionalLights.needsUpdate=k,E.directionalLightShadows.needsUpdate=k,E.pointLights.needsUpdate=k,E.pointLightShadows.needsUpdate=k,E.spotLights.needsUpdate=k,E.spotLightShadows.needsUpdate=k,E.rectAreaLights.needsUpdate=k,E.hemisphereLights.needsUpdate=k}(Ls,Ht),re&&O.fog&&S.refreshFogUniforms(Ls,re),S.refreshMaterialUniforms(Ls,O,F,P),Ao.upload(z,at.uniformsList,Ls,q)),O.isShaderMaterial&&!0===O.uniformsNeedUpdate&&(Ao.upload(z,at.uniformsList,Ls,q),O.uniformsNeedUpdate=!1),O.isSpriteMaterial&&Vt.setValue(z,"center",H.center),Vt.setValue(z,"modelViewMatrix",H.modelViewMatrix),Vt.setValue(z,"normalMatrix",H.normalMatrix),Vt.setValue(z,"modelMatrix",H.matrixWorld),co}pu.setAnimationLoop(function e4(E){ye.isPresenting||Hv&&Hv(E)}),typeof window<"u"&&pu.setContext(window),this.setAnimationLoop=function(E){Hv=E,ye.setAnimationLoop(E),null===E?pu.stop():pu.start()},this.render=function(E,k){let O,H;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),O=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),H=arguments[3]),void 0!==k&&!0!==k.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===y)return;Te.resetDefaultState(),b=-1,x=null,!0===E.autoUpdate&&E.updateMatrixWorld(),null===k.parent&&k.updateMatrixWorld(),!0===ye.enabled&&!0===ye.isPresenting&&(k=ye.getCamera(k)),!0===E.isScene&&E.onBeforeRender(p,E,k,O||_),f=j.get(E,h.length),f.init(),h.push(f),ue.multiplyMatrices(k.projectionMatrix,k.matrixWorldInverse),Y.setFromProjectionMatrix(ue),he=this.localClippingEnabled,oe=C.init(this.clippingPlanes,he,k),u=$.get(E,k),u.init(),E1(E,k,0,p.sortObjects),u.finish(),!0===p.sortObjects&&u.sort(N,L),!0===oe&&C.beginShadows();const re=f.state.shadowsArray;He.render(re,E,k),f.setupLights(),f.setupLightsView(k),!0===oe&&C.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==O&&this.setRenderTarget(O),X.render(u,E,k,H);const ft=u.opaque,st=u.transparent;ft.length>0&&S1(ft,E,k),st.length>0&&S1(st,E,k),!0===E.isScene&&E.onAfterRender(p,E,k),null!==_&&(q.updateRenderTargetMipmap(_),q.updateMultisampleRenderTarget(_)),Qe.buffers.depth.setTest(!0),Qe.buffers.depth.setMask(!0),Qe.buffers.color.setMask(!0),Qe.setPolygonOffset(!1),h.pop(),f=h.length>0?h[h.length-1]:null,u=null},this.setFramebuffer=function(E){v!==E&&null===_&&z.bindFramebuffer(36160,E),v=E},this.getActiveCubeFace=function(){return g},this.getActiveMipmapLevel=function(){return m},this.getRenderList=function(){return u},this.setRenderList=function(E){u=E},this.getRenderTarget=function(){return _},this.setRenderTarget=function(E,k=0,O=0){_=E,g=k,m=O,E&&void 0===lt.get(E).__webglFramebuffer&&q.setupRenderTarget(E);let H=v,re=!1;if(E){const ft=lt.get(E).__webglFramebuffer;E.isWebGLCubeRenderTarget?(H=ft[k],re=!0):H=E.isWebGLMultisampleRenderTarget?lt.get(E).__webglMultisampledFramebuffer:ft,D.copy(E.viewport),I.copy(E.scissor),R=E.scissorTest}else D.copy(A).multiplyScalar(F).floor(),I.copy(B).multiplyScalar(F).floor(),R=W;if(w!==H&&(z.bindFramebuffer(36160,H),w=H),Qe.viewport(D),Qe.scissor(I),Qe.setScissorTest(R),re){const ft=lt.get(E.texture);z.framebufferTexture2D(36160,36064,34069+k,ft.__webglTexture,O)}},this.readRenderTargetPixels=function(E,k,O,H,re,ft,st){if(!E||!E.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let mt=lt.get(E).__webglFramebuffer;if(E.isWebGLCubeRenderTarget&&void 0!==st&&(mt=mt[st]),mt){let at=!1;mt!==w&&(z.bindFramebuffer(36160,mt),at=!0);try{const mn=E.texture,ln=mn.format,et=mn.type;if(ln!==gi&&ve.convert(ln)!==z.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!(et===Ca||ve.convert(et)===z.getParameter(35738)||et===Xr&&(yt.isWebGL2||Fe.get("OES_texture_float")||Fe.get("WEBGL_color_buffer_float"))||et===vl&&Fe.get(yt.isWebGL2?"EXT_color_buffer_float":"EXT_color_buffer_half_float")))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===z.checkFramebufferStatus(36160)?k>=0&&k<=E.width-H&&O>=0&&O<=E.height-re&&z.readPixels(k,O,H,re,ve.convert(ln),ve.convert(et),ft):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{at&&z.bindFramebuffer(36160,w)}}},this.copyFramebufferToTexture=function(E,k,O=0){const H=Math.pow(2,-O),re=Math.floor(k.image.width*H),ft=Math.floor(k.image.height*H),st=ve.convert(k.format);q.setTexture2D(k,0),z.copyTexImage2D(3553,O,st,E.x,E.y,re,ft,0),Qe.unbindTexture()},this.copyTextureToTexture=function(E,k,O,H=0){const re=k.image.width,ft=k.image.height,st=ve.convert(O.format),mt=ve.convert(O.type);q.setTexture2D(O,0),z.pixelStorei(37440,O.flipY),z.pixelStorei(37441,O.premultiplyAlpha),z.pixelStorei(3317,O.unpackAlignment),k.isDataTexture?z.texSubImage2D(3553,H,E.x,E.y,re,ft,st,mt,k.image.data):k.isCompressedTexture?z.compressedTexSubImage2D(3553,H,E.x,E.y,k.mipmaps[0].width,k.mipmaps[0].height,st,k.mipmaps[0].data):z.texSubImage2D(3553,H,E.x,E.y,st,mt,k.image),0===H&&O.generateMipmaps&&z.generateMipmap(3553),Qe.unbindTexture()},this.initTexture=function(E){q.setTexture2D(E,0),Qe.unbindTexture()},this.resetState=function(){Qe.reset(),Te.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function Ly(e){zl.call(this,e)}(Io.prototype=Object.create(Pe.prototype)).constructor=Io,Io.prototype.isMeshDepthMaterial=!0,Io.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this},(Lo.prototype=Object.create(Pe.prototype)).constructor=Lo,Lo.prototype.isMeshDistanceMaterial=!0,Lo.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this},vf.prototype=Object.assign(Object.create(pn.prototype),{constructor:vf,isArrayCamera:!0}),Ro.prototype=Object.assign(Object.create(ge.prototype),{constructor:Ro,isGroup:!0}),Object.assign(Gl.prototype,{constructor:Gl,getHandSpace:function(){if(null===this._hand&&(this._hand=new Ro,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints=[],this._hand.inputState={pinching:!1},window.XRHand))for(let e=0;e<=window.XRHand.LITTLE_PHALANX_TIP;e++){const t=new Ro;t.matrixAutoUpdate=!1,t.visible=!1,this._hand.joints.push(t),this._hand.add(t)}return this._hand},getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new Ro,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return null===this._grip&&(this._grip=new Ro,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this},disconnect:function(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this},update:function(e,t,n){let i=null,r=null,o=null;const s=this._targetRay,a=this._grip,c=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState)if(c&&e.hand){o=!0;for(let l=0;l<=window.XRHand.LITTLE_PHALANX_TIP;l++)if(e.hand[l]){const d=t.getJointPose(e.hand[l],n),u=c.joints[l];null!==d&&(u.matrix.fromArray(d.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),u.jointRadius=d.radius),u.visible=null!==d;const f=c.joints[window.XRHand.INDEX_PHALANX_TIP],h=c.joints[window.XRHand.THUMB_PHALANX_TIP],p=f.position.distanceTo(h.position),y=.02,v=.005;c.inputState.pinching&&p>y+v?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&p<=y-v&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}}else null!==s&&(i=t.getPose(e.targetRaySpace,n),null!==i&&(s.matrix.fromArray(i.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale))),null!==a&&e.gripSpace&&(r=t.getPose(e.gripSpace,n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return null!==s&&(s.visible=null!==i),null!==a&&(a.visible=null!==r),null!==c&&(c.visible=null!==o),this}}),Object.assign(YT.prototype,_r.prototype),Ly.prototype=Object.assign(Object.create(zl.prototype),{constructor:Ly,isWebGL1Renderer:!0});class _f{constructor(t,n){Object.defineProperty(this,"isFogExp2",{value:!0}),this.name="",this.color=new ae(t),this.density=void 0!==n?n:25e-5}clone(){return new _f(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class xf{constructor(t,n,i){Object.defineProperty(this,"isFog",{value:!0}),this.name="",this.color=new ae(t),this.near=void 0!==n?n:1,this.far=void 0!==i?i:1e3}clone(){return new xf(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class Ry extends ge{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,n){return super.copy(t,n),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const n=super.toJSON(t);return null!==this.background&&(n.object.background=this.background.toJSON(t)),null!==this.environment&&(n.object.environment=this.environment.toJSON(t)),null!==this.fog&&(n.object.fog=this.fog.toJSON()),n}}function wi(e,t){this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=Ml,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=ke.generateUUID()}Object.defineProperty(wi.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(wi.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[n+i];return this},set:function(e,t=0){return this.array.set(e,t),this},clone:function(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=ke.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const n=new wi(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),this.stride);return n.setUsage(this.usage),n},onUpload:function(e){return this.onUploadCallback=e,this},toJSON:function(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=ke.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const ys=new M;function Po(e,t,n,i){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=!0===i}function Fo(e){Pe.call(this),this.type="SpriteMaterial",this.color=new ae(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}let Ja;Object.defineProperties(Po.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(e){this.data.needsUpdate=e}}}),Object.assign(Po.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(e){for(let t=0,n=this.data.count;t<n;t++)ys.x=this.getX(t),ys.y=this.getY(t),ys.z=this.getZ(t),ys.applyMatrix4(e),this.setXYZ(t,ys.x,ys.y,ys.z);return this},setX:function(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this},setY:function(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this},setZ:function(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this},setW:function(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this},getX:function(e){return this.data.array[e*this.data.stride+this.offset]},getY:function(e){return this.data.array[e*this.data.stride+this.offset+1]},getZ:function(e){return this.data.array[e*this.data.stride+this.offset+2]},getW:function(e){return this.data.array[e*this.data.stride+this.offset+3]},setXY:function(e,t,n){return this.data.array[(e=e*this.data.stride+this.offset)+0]=t,this.data.array[e+1]=n,this},setXYZ:function(e,t,n,i){return this.data.array[(e=e*this.data.stride+this.offset)+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this},setXYZW:function(e,t,n,i,r){return this.data.array[(e=e*this.data.stride+this.offset)+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=r,this},clone:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new Ee(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Po(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}),(Fo.prototype=Object.create(Pe.prototype)).constructor=Fo,Fo.prototype.isSpriteMaterial=!0,Fo.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this};const jl=new M,Qa=new M,Ka=new M,ec=new V,Wl=new V,ZT=new Ze,wf=new M,ql=new M,bf=new M,JT=new V,Py=new V,QT=new V;function $l(e){if(ge.call(this),this.type="Sprite",void 0===Ja){Ja=new Me;const n=new wi(new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),5);Ja.setIndex([0,1,2,0,2,3]),Ja.setAttribute("position",new Po(n,3,0,!1)),Ja.setAttribute("uv",new Po(n,2,3,!1))}this.geometry=Ja,this.material=void 0!==e?e:new Fo,this.center=new V(.5,.5)}function Mf(e,t,n,i,r,o){ec.subVectors(e,n).addScalar(.5).multiply(i),void 0!==r?(Wl.x=o*ec.x-r*ec.y,Wl.y=r*ec.x+o*ec.y):Wl.copy(ec),e.copy(t),e.x+=Wl.x,e.y+=Wl.y,e.applyMatrix4(ZT)}$l.prototype=Object.assign(Object.create(ge.prototype),{constructor:$l,isSprite:!0,raycast:function(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Qa.setFromMatrixScale(this.matrixWorld),ZT.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Ka.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Qa.multiplyScalar(-Ka.z);const n=this.material.rotation;let i,r;0!==n&&(r=Math.cos(n),i=Math.sin(n));const o=this.center;Mf(wf.set(-.5,-.5,0),Ka,o,Qa,i,r),Mf(ql.set(.5,-.5,0),Ka,o,Qa,i,r),Mf(bf.set(.5,.5,0),Ka,o,Qa,i,r),JT.set(0,0),Py.set(1,0),QT.set(1,1);let s=e.ray.intersectTriangle(wf,ql,bf,!1,jl);if(null===s&&(Mf(ql.set(-.5,.5,0),Ka,o,Qa,i,r),Py.set(0,1),s=e.ray.intersectTriangle(wf,bf,ql,!1,jl),null===s))return;const a=e.ray.origin.distanceTo(jl);a<e.near||a>e.far||t.push({distance:a,point:jl.clone(),uv:An.getUV(jl,wf,ql,bf,JT,Py,QT,new V),face:null,object:this})},copy:function(e){return ge.prototype.copy.call(this,e),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}});const Ef=new M,KT=new M;function Xl(){ge.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}Xl.prototype=Object.assign(Object.create(ge.prototype),{constructor:Xl,isLOD:!0,copy:function(e){ge.prototype.copy.call(this,e,!1);const t=e.levels;for(let n=0,i=t.length;n<i;n++){const r=t[n];this.addLevel(r.object.clone(),r.distance)}return this.autoUpdate=e.autoUpdate,this},addLevel:function(e,t=0){t=Math.abs(t);const n=this.levels;let i;for(i=0;i<n.length&&!(t<n[i].distance);i++);return n.splice(i,0,{distance:t,object:e}),this.add(e),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(e){const t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i&&!(e<t[n].distance);n++);return t[n-1].object}return null},raycast:function(e,t){if(this.levels.length>0){Ef.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(Ef);this.getObjectForDistance(i).raycast(e,t)}},update:function(e){const t=this.levels;if(t.length>1){Ef.setFromMatrixPosition(e.matrixWorld),KT.setFromMatrixPosition(this.matrixWorld);const n=Ef.distanceTo(KT)/e.zoom;let i,r;for(t[0].object.visible=!0,i=1,r=t.length;i<r&&n>=t[i].distance;i++)t[i-1].object.visible=!1,t[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)t[i].object.visible=!1}},toJSON:function(e){const t=ge.prototype.toJSON.call(this,e);!1===this.autoUpdate&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let i=0,r=n.length;i<r;i++){const o=n[i];t.object.levels.push({object:o.object.uuid,distance:o.distance})}return t}});const eD=new M,tD=new It,nD=new It,ZU=new M,iD=new Ze;function Yl(e,t){e&&e.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),Gt.call(this,e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Ze,this.bindMatrixInverse=new Ze}function Zl(){ge.call(this),this.type="Bone"}Yl.prototype=Object.assign(Object.create(Gt.prototype),{constructor:Yl,isSkinnedMesh:!0,copy:function(e){return Gt.prototype.copy.call(this,e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this},bind:function(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const e=new It,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}},updateMatrixWorld:function(e){Gt.prototype.updateMatrixWorld.call(this,e),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(e,t){const n=this.skeleton,i=this.geometry;tD.fromBufferAttribute(i.attributes.skinIndex,e),nD.fromBufferAttribute(i.attributes.skinWeight,e),eD.fromBufferAttribute(i.attributes.position,e).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const o=nD.getComponent(r);if(0!==o){const s=tD.getComponent(r);iD.multiplyMatrices(n.bones[s].matrixWorld,n.boneInverses[s]),t.addScaledVector(ZU.copy(eD).applyMatrix4(iD),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}),Zl.prototype=Object.assign(Object.create(ge.prototype),{constructor:Zl,isBone:!0});const rD=new Ze,JU=new Ze;function Jl(e=[],t=[]){this.uuid=ke.generateUUID(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(Jl.prototype,{init:function(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),0===t.length)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new Ze)}},calculateInverses:function(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new Ze;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}},pose:function(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}},update:function(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,o=e.length;r<o;r++)rD.multiplyMatrices(e[r]?e[r].matrixWorld:JU,t[r]),rD.toArray(n,16*r);null!==i&&(i.needsUpdate=!0)},clone:function(){return new Jl(this.bones,this.boneInverses)},getBoneByName:function(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}},dispose:function(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const r=e.bones[n];let o=t[r];void 0===o&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),o=new Zl),this.bones.push(o),this.boneInverses.push((new Ze).fromArray(e.boneInverses[n]))}return this.init(),this},toJSON:function(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,r=t.length;i<r;i++)e.bones.push(t[i].uuid),e.boneInverses.push(n[i].toArray());return e}});const oD=new Ze,sD=new Ze,Sf=[],Ql=new Gt;function Tf(e,t,n){Gt.call(this,e,t),this.instanceMatrix=new Ee(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}function $t(e){Pe.call(this),this.type="LineBasicMaterial",this.color=new ae(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}Tf.prototype=Object.assign(Object.create(Gt.prototype),{constructor:Tf,isInstancedMesh:!0,copy:function(e){return Gt.prototype.copy.call(this,e),this.instanceMatrix.copy(e.instanceMatrix),this.count=e.count,this},getColorAt:function(e,t){t.fromArray(this.instanceColor.array,3*e)},getMatrixAt:function(e,t){t.fromArray(this.instanceMatrix.array,16*e)},raycast:function(e,t){const n=this.matrixWorld,i=this.count;if(Ql.geometry=this.geometry,Ql.material=this.material,void 0!==Ql.material)for(let r=0;r<i;r++){this.getMatrixAt(r,oD),sD.multiplyMatrices(n,oD),Ql.matrixWorld=sD,Ql.raycast(e,Sf);for(let o=0,s=Sf.length;o<s;o++){const a=Sf[o];a.instanceId=r,a.object=this,t.push(a)}Sf.length=0}},setColorAt:function(e,t){null===this.instanceColor&&(this.instanceColor=new Ee(new Float32Array(3*this.count),3)),t.toArray(this.instanceColor.array,3*e)},setMatrixAt:function(e,t){t.toArray(this.instanceMatrix.array,16*e)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}}),($t.prototype=Object.create(Pe.prototype)).constructor=$t,$t.prototype.isLineBasicMaterial=!0,$t.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this};const aD=new M,cD=new M,lD=new Ze,Df=new Na,Cf=new Zr;function Ni(e=new Me,t=new $t){ge.call(this),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}Ni.prototype=Object.assign(Object.create(ge.prototype),{constructor:Ni,isLine:!0,copy:function(e){return ge.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[0];for(let i=1,r=t.count;i<r;i++)aD.fromBufferAttribute(t,i-1),cD.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=aD.distanceTo(cD);e.setAttribute("lineDistance",new te(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const t=e.vertices,n=e.lineDistances;n[0]=0;for(let i=1,r=t.length;i<r;i++)n[i]=n[i-1],n[i]+=t[i-1].distanceTo(t[i])}return this},raycast:function(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),Cf.copy(n.boundingSphere),Cf.applyMatrix4(i),Cf.radius+=r,!1===e.ray.intersectsSphere(Cf))return;lD.copy(i).invert(),Df.copy(e.ray).applyMatrix4(lD);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),s=o*o,a=new M,c=new M,l=new M,d=new M,u=this.isLineSegments?2:1;if(n.isBufferGeometry){const f=n.index,p=n.attributes.position;if(null!==f){const y=f.array;for(let v=0,g=y.length-1;v<g;v+=u){const _=y[v+1];if(a.fromBufferAttribute(p,y[v]),c.fromBufferAttribute(p,_),Df.distanceSqToSegment(a,c,d,l)>s)continue;d.applyMatrix4(this.matrixWorld);const b=e.ray.origin.distanceTo(d);b<e.near||b>e.far||t.push({distance:b,point:l.clone().applyMatrix4(this.matrixWorld),index:v,face:null,faceIndex:null,object:this})}}else for(let y=0,v=p.count-1;y<v;y+=u){if(a.fromBufferAttribute(p,y),c.fromBufferAttribute(p,y+1),Df.distanceSqToSegment(a,c,d,l)>s)continue;d.applyMatrix4(this.matrixWorld);const m=e.ray.origin.distanceTo(d);m<e.near||m>e.far||t.push({distance:m,point:l.clone().applyMatrix4(this.matrixWorld),index:y,face:null,faceIndex:null,object:this})}}else if(n.isGeometry){const f=n.vertices,h=f.length;for(let p=0;p<h-1;p+=u){if(Df.distanceSqToSegment(f[p],f[p+1],d,l)>s)continue;d.applyMatrix4(this.matrixWorld);const v=e.ray.origin.distanceTo(d);v<e.near||v>e.far||t.push({distance:v,point:l.clone().applyMatrix4(this.matrixWorld),index:p,face:null,faceIndex:null,object:this})}}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const s=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[s]=r}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const Af=new M,If=new M;function Qn(e,t){Ni.call(this,e,t),this.type="LineSegments"}function Lf(e,t){Ni.call(this,e,t),this.type="LineLoop"}function er(e){Pe.call(this),this.type="PointsMaterial",this.color=new ae(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}Qn.prototype=Object.assign(Object.create(Ni.prototype),{constructor:Qn,isLineSegments:!0,computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[];for(let i=0,r=t.count;i<r;i+=2)Af.fromBufferAttribute(t,i),If.fromBufferAttribute(t,i+1),n[i]=0===i?0:n[i-1],n[i+1]=n[i]+Af.distanceTo(If);e.setAttribute("lineDistance",new te(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const t=e.vertices,n=e.lineDistances;for(let i=0,r=t.length;i<r;i+=2)Af.copy(t[i]),If.copy(t[i+1]),n[i]=0===i?0:n[i-1],n[i+1]=n[i]+Af.distanceTo(If)}return this}}),Lf.prototype=Object.assign(Object.create(Ni.prototype),{constructor:Lf,isLineLoop:!0}),(er.prototype=Object.create(Pe.prototype)).constructor=er,er.prototype.isPointsMaterial=!0,er.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this};const uD=new Ze,Fy=new Na,Rf=new Zr,Pf=new M;function tc(e=new Me,t=new er){ge.call(this),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}function Ny(e,t,n,i,r,o,s){const a=Fy.distanceSqToPoint(e);if(a<n){const c=new M;Fy.closestPointToPoint(e,c),c.applyMatrix4(i);const l=r.ray.origin.distanceTo(c);if(l<r.near||l>r.far)return;o.push({distance:l,distanceToRay:Math.sqrt(a),point:c,index:t,face:null,object:s})}}function Oy(e,t,n,i,r,o,s,a,c){At.call(this,e,t,n,i,r,o,s,a,c),this.format=void 0!==s?s:wo,this.minFilter=void 0!==o?o:En,this.magFilter=void 0!==r?r:En,this.generateMipmaps=!1;const l=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(function d(){l.needsUpdate=!0,e.requestVideoFrameCallback(d)})}function nc(e,t,n,i,r,o,s,a,c,l,d,u){At.call(this,null,o,s,a,c,l,i,r,d,u),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}function Kl(e,t,n,i,r,o,s,a,c){At.call(this,e,t,n,i,r,o,s,a,c),this.needsUpdate=!0}function eu(e,t,n,i,r,o,s,a,c,l){if((l=void 0!==l?l:os)!==os&&l!==Ia)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&l===os&&(n=gl),void 0===n&&l===Ia&&(n=Aa),At.call(this,null,i,r,o,s,a,l,n,c),this.image={width:e,height:t},this.magFilter=void 0!==s?s:bn,this.minFilter=void 0!==a?a:bn,this.flipY=!1,this.generateMipmaps=!1}tc.prototype=Object.assign(Object.create(ge.prototype),{constructor:tc,isPoints:!0,copy:function(e){return ge.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},raycast:function(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),Rf.copy(n.boundingSphere),Rf.applyMatrix4(i),Rf.radius+=r,!1===e.ray.intersectsSphere(Rf))return;uD.copy(i).invert(),Fy.copy(e.ray).applyMatrix4(uD);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),s=o*o;if(n.isBufferGeometry){const a=n.index,l=n.attributes.position;if(null!==a){const d=a.array;for(let u=0,f=d.length;u<f;u++){const h=d[u];Pf.fromBufferAttribute(l,h),Ny(Pf,h,s,i,e,t,this)}}else for(let d=0,u=l.count;d<u;d++)Pf.fromBufferAttribute(l,d),Ny(Pf,d,s,i,e,t,this)}else{const a=n.vertices;for(let c=0,l=a.length;c<l;c++)Ny(a[c],c,s,i,e,t,this)}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const s=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[s]=r}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),Oy.prototype=Object.assign(Object.create(At.prototype),{constructor:Oy,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const e=this.image;"requestVideoFrameCallback"in e==0&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),(nc.prototype=Object.create(At.prototype)).constructor=nc,nc.prototype.isCompressedTexture=!0,(Kl.prototype=Object.create(At.prototype)).constructor=Kl,Kl.prototype.isCanvasTexture=!0,(eu.prototype=Object.create(At.prototype)).constructor=eu,eu.prototype.isDepthTexture=!0;let QU=0;const Sr=new Ze,By=new ge,Ff=new M;function Lt(){Object.defineProperty(this,"id",{value:QU+=2}),this.uuid=ke.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}Lt.prototype=Object.assign(Object.create(_r.prototype),{constructor:Lt,isGeometry:!0,applyMatrix4:function(e){const t=(new Zn).getNormalMatrix(e);for(let n=0,i=this.vertices.length;n<i;n++)this.vertices[n].applyMatrix4(e);for(let n=0,i=this.faces.length;n<i;n++){const r=this.faces[n];r.normal.applyMatrix3(t).normalize();for(let o=0,s=r.vertexNormals.length;o<s;o++)r.vertexNormals[o].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return Sr.makeRotationX(e),this.applyMatrix4(Sr),this},rotateY:function(e){return Sr.makeRotationY(e),this.applyMatrix4(Sr),this},rotateZ:function(e){return Sr.makeRotationZ(e),this.applyMatrix4(Sr),this},translate:function(e,t,n){return Sr.makeTranslation(e,t,n),this.applyMatrix4(Sr),this},scale:function(e,t,n){return Sr.makeScale(e,t,n),this.applyMatrix4(Sr),this},lookAt:function(e){return By.lookAt(e),By.updateMatrix(),this.applyMatrix4(By.matrix),this},fromBufferGeometry:function(e){const t=this,n=null!==e.index?e.index:void 0,i=e.attributes;if(void 0===i.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const r=i.position,o=i.normal,s=i.color,a=i.uv,c=i.uv2;void 0!==c&&(this.faceVertexUvs[1]=[]);for(let u=0;u<r.count;u++)t.vertices.push((new M).fromBufferAttribute(r,u)),void 0!==s&&t.colors.push((new ae).fromBufferAttribute(s,u));function l(u,f,h,p){const y=void 0===s?[]:[t.colors[u].clone(),t.colors[f].clone(),t.colors[h].clone()],v=void 0===o?[]:[(new M).fromBufferAttribute(o,u),(new M).fromBufferAttribute(o,f),(new M).fromBufferAttribute(o,h)],g=new Dl(u,f,h,v,y,p);t.faces.push(g),void 0!==a&&t.faceVertexUvs[0].push([(new V).fromBufferAttribute(a,u),(new V).fromBufferAttribute(a,f),(new V).fromBufferAttribute(a,h)]),void 0!==c&&t.faceVertexUvs[1].push([(new V).fromBufferAttribute(c,u),(new V).fromBufferAttribute(c,f),(new V).fromBufferAttribute(c,h)])}const d=e.groups;if(d.length>0)for(let u=0;u<d.length;u++){const f=d[u],h=f.start;for(let y=h,v=h+f.count;y<v;y+=3)void 0!==n?l(n.getX(y),n.getX(y+1),n.getX(y+2),f.materialIndex):l(y,y+1,y+2,f.materialIndex)}else if(void 0!==n)for(let u=0;u<n.count;u+=3)l(n.getX(u),n.getX(u+1),n.getX(u+2));else for(let u=0;u<r.count;u+=3)l(u,u+1,u+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ff).negate(),this.translate(Ff.x,Ff.y,Ff.z),this},normalize:function(){this.computeBoundingSphere();const e=this.boundingSphere.center,t=this.boundingSphere.radius,n=0===t?1:1/t,i=new Ze;return i.set(n,0,0,-n*e.x,0,n,0,-n*e.y,0,0,n,-n*e.z,0,0,0,1),this.applyMatrix4(i),this},computeFaceNormals:function(){const e=new M,t=new M;for(let n=0,i=this.faces.length;n<i;n++){const r=this.faces[n],o=this.vertices[r.a],s=this.vertices[r.b];e.subVectors(this.vertices[r.c],s),t.subVectors(o,s),e.cross(t),e.normalize(),r.normal.copy(e)}},computeVertexNormals:function(e=!0){const t=new Array(this.vertices.length);for(let n=0,i=this.vertices.length;n<i;n++)t[n]=new M;if(e){const n=new M,i=new M;for(let r=0,o=this.faces.length;r<o;r++){const s=this.faces[r],a=this.vertices[s.a],c=this.vertices[s.b];n.subVectors(this.vertices[s.c],c),i.subVectors(a,c),n.cross(i),t[s.a].add(n),t[s.b].add(n),t[s.c].add(n)}}else{this.computeFaceNormals();for(let n=0,i=this.faces.length;n<i;n++){const r=this.faces[n];t[r.a].add(r.normal),t[r.b].add(r.normal),t[r.c].add(r.normal)}}for(let n=0,i=this.vertices.length;n<i;n++)t[n].normalize();for(let n=0,i=this.faces.length;n<i;n++){const r=this.faces[n],o=r.vertexNormals;3===o.length?(o[0].copy(t[r.a]),o[1].copy(t[r.b]),o[2].copy(t[r.c])):(o[0]=t[r.a].clone(),o[1]=t[r.b].clone(),o[2]=t[r.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const n=this.faces[e],i=n.vertexNormals;3===i.length?(i[0].copy(n.normal),i[1].copy(n.normal),i[2].copy(n.normal)):(i[0]=n.normal.clone(),i[1]=n.normal.clone(),i[2]=n.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let t=0,n=this.faces.length;t<n;t++){const i=this.faces[t];i.__originalFaceNormal?i.__originalFaceNormal.copy(i.normal):i.__originalFaceNormal=i.normal.clone(),i.__originalVertexNormals||(i.__originalVertexNormals=[]);for(let r=0,o=i.vertexNormals.length;r<o;r++)i.__originalVertexNormals[r]?i.__originalVertexNormals[r].copy(i.vertexNormals[r]):i.__originalVertexNormals[r]=i.vertexNormals[r].clone()}const e=new Lt;e.faces=this.faces;for(let t=0,n=this.morphTargets.length;t<n;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const r=this.morphNormals[t].faceNormals,o=this.morphNormals[t].vertexNormals;for(let s=0,a=this.faces.length;s<a;s++){const c=new M,l={a:new M,b:new M,c:new M};r.push(c),o.push(l)}}const i=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let r=0,o=this.faces.length;r<o;r++){const s=this.faces[r],c=i.vertexNormals[r];i.faceNormals[r].copy(s.normal),c.a.copy(s.vertexNormals[0]),c.b.copy(s.vertexNormals[1]),c.c.copy(s.vertexNormals[2])}}for(let t=0,n=this.faces.length;t<n;t++){const i=this.faces[t];i.normal=i.__originalFaceNormal,i.vertexNormals=i.__originalVertexNormals}},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new xr),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Zr),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,t,n=0){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let i;const r=this.vertices.length,o=this.vertices,s=e.vertices,a=this.faces,c=e.faces,l=this.colors,d=e.colors;void 0!==t&&(i=(new Zn).getNormalMatrix(t));for(let u=0,f=s.length;u<f;u++){const p=s[u].clone();void 0!==t&&p.applyMatrix4(t),o.push(p)}for(let u=0,f=d.length;u<f;u++)l.push(d[u].clone());for(let u=0,f=c.length;u<f;u++){const h=c[u];let p,y;const v=h.vertexNormals,g=h.vertexColors,m=new Dl(h.a+r,h.b+r,h.c+r);m.normal.copy(h.normal),void 0!==i&&m.normal.applyMatrix3(i).normalize();for(let _=0,w=v.length;_<w;_++)p=v[_].clone(),void 0!==i&&p.applyMatrix3(i).normalize(),m.vertexNormals.push(p);m.color.copy(h.color);for(let _=0,w=g.length;_<w;_++)y=g[_],m.vertexColors.push(y.clone());m.materialIndex=h.materialIndex+n,a.push(m)}for(let u=0,f=e.faceVertexUvs.length;u<f;u++){const h=e.faceVertexUvs[u];void 0===this.faceVertexUvs[u]&&(this.faceVertexUvs[u]=[]);for(let p=0,y=h.length;p<y;p++){const v=h[p],g=[];for(let m=0,_=v.length;m<_;m++)g.push(v[m].clone());this.faceVertexUvs[u].push(g)}}},mergeMesh:function(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)},mergeVertices:function(e=4){const t={},n=[],i=[],r=Math.pow(10,e);for(let a=0,c=this.vertices.length;a<c;a++){const l=this.vertices[a],d=Math.round(l.x*r)+"_"+Math.round(l.y*r)+"_"+Math.round(l.z*r);void 0===t[d]?(t[d]=a,n.push(this.vertices[a]),i[a]=n.length-1):i[a]=i[t[d]]}const o=[];for(let a=0,c=this.faces.length;a<c;a++){const l=this.faces[a];l.a=i[l.a],l.b=i[l.b],l.c=i[l.c];const d=[l.a,l.b,l.c];for(let u=0;u<3;u++)if(d[u]===d[(u+1)%3]){o.push(a);break}}for(let a=o.length-1;a>=0;a--){const c=o[a];this.faces.splice(c,1);for(let l=0,d=this.faceVertexUvs.length;l<d;l++)this.faceVertexUvs[l].splice(c,1)}const s=this.vertices.length-n.length;return this.vertices=n,s},setFromPoints:function(e){this.vertices=[];for(let t=0,n=e.length;t<n;t++){const i=e[t];this.vertices.push(new M(i.x,i.y,i.z||0))}return this},sortFacesByMaterialIndex:function(){const e=this.faces,t=e.length;for(let a=0;a<t;a++)e[a]._id=a;e.sort(function n(a,c){return a.materialIndex-c.materialIndex});const i=this.faceVertexUvs[0],r=this.faceVertexUvs[1];let o,s;i&&i.length===t&&(o=[]),r&&r.length===t&&(s=[]);for(let a=0;a<t;a++){const c=e[a]._id;o&&o.push(i[c]),s&&s.push(r[c])}o&&(this.faceVertexUvs[0]=o),s&&(this.faceVertexUvs[1]=s)},toJSON:function(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const h=this.parameters;for(const p in h)void 0!==h[p]&&(e[p]=h[p]);return e}const t=[];for(let h=0;h<this.vertices.length;h++){const p=this.vertices[h];t.push(p.x,p.y,p.z)}const n=[],i=[],r={},o=[],s={},a=[],c={};for(let h=0;h<this.faces.length;h++){const p=this.faces[h],y=!0,v=!1,g=void 0!==this.faceVertexUvs[0][h],m=p.normal.length()>0,_=p.vertexNormals.length>0,w=1!==p.color.r||1!==p.color.g||1!==p.color.b,b=p.vertexColors.length>0;let x=0;if(x=l(x,0,0),x=l(x,1,y),x=l(x,2,v),x=l(x,3,g),x=l(x,4,m),x=l(x,5,_),x=l(x,6,w),x=l(x,7,b),n.push(x),n.push(p.a,p.b,p.c),n.push(p.materialIndex),g){const D=this.faceVertexUvs[0][h];n.push(f(D[0]),f(D[1]),f(D[2]))}if(m&&n.push(d(p.normal)),_){const D=p.vertexNormals;n.push(d(D[0]),d(D[1]),d(D[2]))}if(w&&n.push(u(p.color)),b){const D=p.vertexColors;n.push(u(D[0]),u(D[1]),u(D[2]))}}function l(h,p,y){return y?h|1<<p:h&~(1<<p)}function d(h){const p=h.x.toString()+h.y.toString()+h.z.toString();return void 0!==r[p]||(r[p]=i.length/3,i.push(h.x,h.y,h.z)),r[p]}function u(h){const p=h.r.toString()+h.g.toString()+h.b.toString();return void 0!==s[p]||(s[p]=o.length,o.push(h.getHex())),s[p]}function f(h){const p=h.x.toString()+h.y.toString();return void 0!==c[p]||(c[p]=a.length/2,a.push(h.x,h.y)),c[p]}return e.data={},e.data.vertices=t,e.data.normals=i,o.length>0&&(e.data.colors=o),a.length>0&&(e.data.uvs=[a]),e.data.faces=n,e},clone:function(){return(new Lt).copy(this)},copy:function(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let u=0,f=t.length;u<f;u++)this.vertices.push(t[u].clone());const n=e.colors;for(let u=0,f=n.length;u<f;u++)this.colors.push(n[u].clone());const i=e.faces;for(let u=0,f=i.length;u<f;u++)this.faces.push(i[u].clone());for(let u=0,f=e.faceVertexUvs.length;u<f;u++){const h=e.faceVertexUvs[u];void 0===this.faceVertexUvs[u]&&(this.faceVertexUvs[u]=[]);for(let p=0,y=h.length;p<y;p++){const v=h[p],g=[];for(let m=0,_=v.length;m<_;m++)g.push(v[m].clone());this.faceVertexUvs[u].push(g)}}const r=e.morphTargets;for(let u=0,f=r.length;u<f;u++){const h={};if(h.name=r[u].name,void 0!==r[u].vertices){h.vertices=[];for(let p=0,y=r[u].vertices.length;p<y;p++)h.vertices.push(r[u].vertices[p].clone())}if(void 0!==r[u].normals){h.normals=[];for(let p=0,y=r[u].normals.length;p<y;p++)h.normals.push(r[u].normals[p].clone())}this.morphTargets.push(h)}const o=e.morphNormals;for(let u=0,f=o.length;u<f;u++){const h={};if(void 0!==o[u].vertexNormals){h.vertexNormals=[];for(let p=0,y=o[u].vertexNormals.length;p<y;p++){const v=o[u].vertexNormals[p],g={};g.a=v.a.clone(),g.b=v.b.clone(),g.c=v.c.clone(),h.vertexNormals.push(g)}}if(void 0!==o[u].faceNormals){h.faceNormals=[];for(let p=0,y=o[u].faceNormals.length;p<y;p++)h.faceNormals.push(o[u].faceNormals[p].clone())}this.morphNormals.push(h)}const s=e.skinWeights;for(let u=0,f=s.length;u<f;u++)this.skinWeights.push(s[u].clone());const a=e.skinIndices;for(let u=0,f=a.length;u<f;u++)this.skinIndices.push(a[u].clone());const c=e.lineDistances;for(let u=0,f=c.length;u<f;u++)this.lineDistances.push(c[u]);const l=e.boundingBox;null!==l&&(this.boundingBox=l.clone());const d=e.boundingSphere;return null!==d&&(this.boundingSphere=d.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});class ky extends Lt{constructor(t,n,i,r,o,s){super(),this.type="BoxGeometry",this.parameters={width:t,height:n,depth:i,widthSegments:r,heightSegments:o,depthSegments:s},this.fromBufferGeometry(new kl(t,n,i,r,o,s)),this.mergeVertices()}}class Hy extends Me{constructor(t=1,n=8,i=0,r=2*Math.PI){super(),this.type="CircleBufferGeometry",this.parameters={radius:t,segments:n,thetaStart:i,thetaLength:r},n=Math.max(3,n);const o=[],s=[],a=[],c=[],l=new M,d=new V;s.push(0,0,0),a.push(0,0,1),c.push(.5,.5);for(let u=0,f=3;u<=n;u++,f+=3){const h=i+u/n*r;l.x=t*Math.cos(h),l.y=t*Math.sin(h),s.push(l.x,l.y,l.z),a.push(0,0,1),d.x=(s[f]/t+1)/2,d.y=(s[f+1]/t+1)/2,c.push(d.x,d.y)}for(let u=1;u<=n;u++)o.push(u,u+1,0);this.setIndex(o),this.setAttribute("position",new te(s,3)),this.setAttribute("normal",new te(a,3)),this.setAttribute("uv",new te(c,2))}}class dD extends Lt{constructor(t,n,i,r){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:n,thetaStart:i,thetaLength:r},this.fromBufferGeometry(new Hy(t,n,i,r)),this.mergeVertices()}}class tu extends Me{constructor(t=1,n=1,i=1,r=8,o=1,s=!1,a=0,c=2*Math.PI){super(),this.type="CylinderBufferGeometry",this.parameters={radiusTop:t,radiusBottom:n,height:i,radialSegments:r,heightSegments:o,openEnded:s,thetaStart:a,thetaLength:c};const l=this;r=Math.floor(r),o=Math.floor(o);const d=[],u=[],f=[],h=[];let p=0;const y=[],v=i/2;let g=0;function _(w){const b=p,x=new V,D=new M;let I=0;const R=!0===w?t:n,U=!0===w?1:-1;for(let F=1;F<=r;F++)u.push(0,v*U,0),f.push(0,U,0),h.push(.5,.5),p++;const P=p;for(let F=0;F<=r;F++){const L=F/r*c+a,A=Math.cos(L),B=Math.sin(L);D.x=R*B,D.y=v*U,D.z=R*A,u.push(D.x,D.y,D.z),f.push(0,U,0),x.x=.5*A+.5,x.y=.5*B*U+.5,h.push(x.x,x.y),p++}for(let F=0;F<r;F++){const N=b+F,L=P+F;!0===w?d.push(L,L+1,N):d.push(L+1,L,N),I+=3}l.addGroup(g,I,!0===w?1:2),g+=I}(function m(){const w=new M,b=new M;let x=0;const D=(n-t)/i;for(let I=0;I<=o;I++){const R=[],U=I/o,P=U*(n-t)+t;for(let F=0;F<=r;F++){const N=F/r,L=N*c+a,A=Math.sin(L),B=Math.cos(L);b.x=P*A,b.y=-U*i+v,b.z=P*B,u.push(b.x,b.y,b.z),w.set(A,D,B).normalize(),f.push(w.x,w.y,w.z),h.push(N,1-U),R.push(p++)}y.push(R)}for(let I=0;I<r;I++)for(let R=0;R<o;R++){const P=y[R+1][I],F=y[R+1][I+1],N=y[R][I+1];d.push(y[R][I],P,N),d.push(P,F,N),x+=6}l.addGroup(g,x,0),g+=x})(),!1===s&&(t>0&&_(!0),n>0&&_(!1)),this.setIndex(d),this.setAttribute("position",new te(u,3)),this.setAttribute("normal",new te(f,3)),this.setAttribute("uv",new te(h,2))}}class Vy extends Lt{constructor(t,n,i,r,o,s,a,c){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:n,height:i,radialSegments:r,heightSegments:o,openEnded:s,thetaStart:a,thetaLength:c},this.fromBufferGeometry(new tu(t,n,i,r,o,s,a,c)),this.mergeVertices()}}class fD extends Vy{constructor(t,n,i,r,o,s,a){super(0,t,n,i,r,o,s,a),this.type="ConeGeometry",this.parameters={radius:t,height:n,radialSegments:i,heightSegments:r,openEnded:o,thetaStart:s,thetaLength:a}}}class hD extends tu{constructor(t=1,n=1,i=8,r=1,o=!1,s=0,a=2*Math.PI){super(0,t,n,i,r,o,s,a),this.type="ConeBufferGeometry",this.parameters={radius:t,height:n,radialSegments:i,heightSegments:r,openEnded:o,thetaStart:s,thetaLength:a}}}class vs extends Me{constructor(t,n,i=1,r=0){super(),this.type="PolyhedronBufferGeometry",this.parameters={vertices:t,indices:n,radius:i,detail:r};const o=[],s=[];function c(m,_,w,b){const x=b+1,D=[];for(let I=0;I<=x;I++){D[I]=[];const R=m.clone().lerp(w,I/x),U=_.clone().lerp(w,I/x),P=x-I;for(let F=0;F<=P;F++)D[I][F]=0===F&&I===x?R:R.clone().lerp(U,F/P)}for(let I=0;I<x;I++)for(let R=0;R<2*(x-I)-1;R++){const U=Math.floor(R/2);R%2==0?(f(D[I][U+1]),f(D[I+1][U]),f(D[I][U])):(f(D[I][U+1]),f(D[I+1][U+1]),f(D[I+1][U]))}}function f(m){o.push(m.x,m.y,m.z)}function h(m,_){const w=3*m;_.x=t[w+0],_.y=t[w+1],_.z=t[w+2]}function y(m,_,w,b){b<0&&1===m.x&&(s[_]=m.x-1),0===w.x&&0===w.z&&(s[_]=b/2/Math.PI+.5)}function v(m){return Math.atan2(m.z,-m.x)}function g(m){return Math.atan2(-m.y,Math.sqrt(m.x*m.x+m.z*m.z))}(function a(m){const _=new M,w=new M,b=new M;for(let x=0;x<n.length;x+=3)h(n[x+0],_),h(n[x+1],w),h(n[x+2],b),c(_,w,b,m)})(r),function l(m){const _=new M;for(let w=0;w<o.length;w+=3)_.x=o[w+0],_.y=o[w+1],_.z=o[w+2],_.normalize().multiplyScalar(m),o[w+0]=_.x,o[w+1]=_.y,o[w+2]=_.z}(i),function d(){const m=new M;for(let _=0;_<o.length;_+=3){m.x=o[_+0],m.y=o[_+1],m.z=o[_+2];const w=v(m)/2/Math.PI+.5,b=g(m)/Math.PI+.5;s.push(w,1-b)}(function p(){const m=new M,_=new M,w=new M,b=new M,x=new V,D=new V,I=new V;for(let R=0,U=0;R<o.length;R+=9,U+=6){m.set(o[R+0],o[R+1],o[R+2]),_.set(o[R+3],o[R+4],o[R+5]),w.set(o[R+6],o[R+7],o[R+8]),x.set(s[U+0],s[U+1]),D.set(s[U+2],s[U+3]),I.set(s[U+4],s[U+5]),b.copy(m).add(_).add(w).divideScalar(3);const P=v(b);y(x,U+0,m,P),y(D,U+2,_,P),y(I,U+4,w,P)}})(),function u(){for(let m=0;m<s.length;m+=6){const _=s[m+0],w=s[m+2],b=s[m+4],x=Math.max(_,w,b),D=Math.min(_,w,b);x>.9&&D<.1&&(_<.2&&(s[m+0]+=1),w<.2&&(s[m+2]+=1),b<.2&&(s[m+4]+=1))}}()}(),this.setAttribute("position",new te(o,3)),this.setAttribute("normal",new te(o.slice(),3)),this.setAttribute("uv",new te(s,2)),0===r?this.computeVertexNormals():this.normalizeNormals()}}class Uy extends vs{constructor(t=1,n=0){const i=(1+Math.sqrt(5))/2,r=1/i;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-i,0,-r,i,0,r,-i,0,r,i,-r,-i,0,-r,i,0,r,-i,0,r,i,0,-i,0,-r,i,0,-r,-i,0,r,i,0,r],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,n),this.type="DodecahedronBufferGeometry",this.parameters={radius:t,detail:n}}}class pD extends Lt{constructor(t,n){super(),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:n},this.fromBufferGeometry(new Uy(t,n)),this.mergeVertices()}}const Nf=new M,Of=new M,Gy=new M,Bf=new An;class zy extends Me{constructor(t,n){super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:n},n=void 0!==n?n:1,t.isGeometry&&(t=(new Me).fromGeometry(t));const r=Math.pow(10,4),o=Math.cos(ke.DEG2RAD*n),s=t.getIndex(),a=t.getAttribute("position"),c=s?s.count:a.count,l=[0,0,0],d=["a","b","c"],u=new Array(3),f={},h=[];for(let p=0;p<c;p+=3){s?(l[0]=s.getX(p),l[1]=s.getX(p+1),l[2]=s.getX(p+2)):(l[0]=p,l[1]=p+1,l[2]=p+2);const{a:y,b:v,c:g}=Bf;if(y.fromBufferAttribute(a,l[0]),v.fromBufferAttribute(a,l[1]),g.fromBufferAttribute(a,l[2]),Bf.getNormal(Gy),u[0]=`${Math.round(y.x*r)},${Math.round(y.y*r)},${Math.round(y.z*r)}`,u[1]=`${Math.round(v.x*r)},${Math.round(v.y*r)},${Math.round(v.z*r)}`,u[2]=`${Math.round(g.x*r)},${Math.round(g.y*r)},${Math.round(g.z*r)}`,u[0]!==u[1]&&u[1]!==u[2]&&u[2]!==u[0])for(let m=0;m<3;m++){const _=(m+1)%3,w=u[m],b=u[_],x=Bf[d[m]],D=Bf[d[_]],I=`${w}_${b}`,R=`${b}_${w}`;R in f&&f[R]?(Gy.dot(f[R].normal)<=o&&(h.push(x.x,x.y,x.z),h.push(D.x,D.y,D.z)),f[R]=null):I in f||(f[I]={index0:l[m],index1:l[_],normal:Gy.clone()})}}for(const p in f)if(f[p]){const{index0:y,index1:v}=f[p];Nf.fromBufferAttribute(a,y),Of.fromBufferAttribute(a,v),h.push(Nf.x,Nf.y,Nf.z),h.push(Of.x,Of.y,Of.z)}this.setAttribute("position",new te(h,3))}}function mD(e,t,n,i,r){let o,s;if(r===function mG(e,t,n,i){let r=0;for(let o=t,s=n-i;o<n;o+=i)r+=(e[s]-e[o])*(e[o+1]+e[s+1]),s=o;return r}(e,t,n,i)>0)for(o=t;o<n;o+=i)s=vD(o,e[o],e[o+1],s);else for(o=n-i;o>=t;o-=i)s=vD(o,e[o],e[o+1],s);return s&&kf(s,s.next)&&(ru(s),s=s.next),s}function No(e,t){if(!e)return e;t||(t=e);let i,n=e;do{if(i=!1,n.steiner||!kf(n,n.next)&&0!==Jt(n.prev,n,n.next))n=n.next;else{if(ru(n),n=t=n.prev,n===n.next)break;i=!0}}while(i||n!==t);return t}function nu(e,t,n,i,r,o,s){if(!e)return;!s&&o&&function lG(e,t,n,i){let r=e;do{null===r.z&&(r.z=jy(r.x,r.y,t,n,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==e);r.prevZ.nextZ=null,r.prevZ=null,function uG(e){let t,n,i,r,o,s,a,c,l=1;do{for(n=e,e=null,o=null,s=0;n;){for(s++,i=n,a=0,t=0;t<l&&(a++,i=i.nextZ,i);t++);for(c=l;a>0||c>0&&i;)0!==a&&(0===c||!i||n.z<=i.z)?(r=n,n=n.nextZ,a--):(r=i,i=i.nextZ,c--),o?o.nextZ=r:e=r,r.prevZ=o,o=r;n=i}o.nextZ=null,l*=2}while(s>1)}(r)}(e,i,r,o);let c,l,a=e;for(;e.prev!==e.next;)if(c=e.prev,l=e.next,o?tG(e,i,r,o):eG(e))t.push(c.i/n),t.push(e.i/n),t.push(l.i/n),ru(e),e=l.next,a=l.next;else if((e=l)===a){s?1===s?nu(e=nG(No(e),t,n),t,n,i,r,o,2):2===s&&iG(e,t,n,i,r,o):nu(No(e),t,n,i,r,o,1);break}}function eG(e){const t=e.prev,n=e,i=e.next;if(Jt(t,n,i)>=0)return!1;let r=e.next.next;for(;r!==e.prev;){if(ic(t.x,t.y,n.x,n.y,i.x,i.y,r.x,r.y)&&Jt(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function tG(e,t,n,i){const r=e.prev,o=e,s=e.next;if(Jt(r,o,s)>=0)return!1;const l=r.x>o.x?r.x>s.x?r.x:s.x:o.x>s.x?o.x:s.x,d=r.y>o.y?r.y>s.y?r.y:s.y:o.y>s.y?o.y:s.y,u=jy(r.x<o.x?r.x<s.x?r.x:s.x:o.x<s.x?o.x:s.x,r.y<o.y?r.y<s.y?r.y:s.y:o.y<s.y?o.y:s.y,t,n,i),f=jy(l,d,t,n,i);let h=e.prevZ,p=e.nextZ;for(;h&&h.z>=u&&p&&p.z<=f;){if(h!==e.prev&&h!==e.next&&ic(r.x,r.y,o.x,o.y,s.x,s.y,h.x,h.y)&&Jt(h.prev,h,h.next)>=0||(h=h.prevZ,p!==e.prev&&p!==e.next&&ic(r.x,r.y,o.x,o.y,s.x,s.y,p.x,p.y)&&Jt(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;h&&h.z>=u;){if(h!==e.prev&&h!==e.next&&ic(r.x,r.y,o.x,o.y,s.x,s.y,h.x,h.y)&&Jt(h.prev,h,h.next)>=0)return!1;h=h.prevZ}for(;p&&p.z<=f;){if(p!==e.prev&&p!==e.next&&ic(r.x,r.y,o.x,o.y,s.x,s.y,p.x,p.y)&&Jt(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function nG(e,t,n){let i=e;do{const r=i.prev,o=i.next.next;!kf(r,o)&&gD(r,i,i.next,o)&&iu(r,o)&&iu(o,r)&&(t.push(r.i/n),t.push(i.i/n),t.push(o.i/n),ru(i),ru(i.next),i=e=o),i=i.next}while(i!==e);return No(i)}function iG(e,t,n,i,r,o){let s=e;do{let a=s.next.next;for(;a!==s.prev;){if(s.i!==a.i&&fG(s,a)){let c=yD(s,a);return s=No(s,s.next),c=No(c,c.next),nu(s,t,n,i,r,o),void nu(c,t,n,i,r,o)}a=a.next}s=s.next}while(s!==e)}function oG(e,t){return e.x-t.x}function sG(e,t){if(t=function aG(e,t){let n=t;const i=e.x,r=e.y;let s,o=-1/0;do{if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){const f=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(f<=i&&f>o){if(o=f,f===i){if(r===n.y)return n;if(r===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!s)return null;if(i===o)return s;const a=s,c=s.x,l=s.y;let u,d=1/0;n=s;do{i>=n.x&&n.x>=c&&i!==n.x&&ic(r<l?i:o,r,c,l,r<l?o:i,r,n.x,n.y)&&(u=Math.abs(r-n.y)/(i-n.x),iu(n,e)&&(u<d||u===d&&(n.x>s.x||n.x===s.x&&cG(s,n)))&&(s=n,d=u)),n=n.next}while(n!==a);return s}(e,t),t){const n=yD(t,e);No(t,t.next),No(n,n.next)}}function cG(e,t){return Jt(e.prev,e,t.prev)<0&&Jt(t.next,e,e.next)<0}function jy(e,t,n,i,r){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*r)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*r)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function dG(e){let t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function ic(e,t,n,i,r,o,s,a){return(r-s)*(t-a)-(e-s)*(o-a)>=0&&(e-s)*(i-a)-(n-s)*(t-a)>=0&&(n-s)*(o-a)-(r-s)*(i-a)>=0}function fG(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function hG(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&gD(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(iu(e,t)&&iu(t,e)&&function pG(e,t){let n=e,i=!1;const r=(e.x+t.x)/2,o=(e.y+t.y)/2;do{n.y>o!=n.next.y>o&&n.next.y!==n.y&&r<(n.next.x-n.x)*(o-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==e);return i}(e,t)&&(Jt(e.prev,e,t.prev)||Jt(e,t.prev,t))||kf(e,t)&&Jt(e.prev,e,e.next)>0&&Jt(t.prev,t,t.next)>0)}function Jt(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function kf(e,t){return e.x===t.x&&e.y===t.y}function gD(e,t,n,i){const r=Vf(Jt(e,t,n)),o=Vf(Jt(e,t,i)),s=Vf(Jt(n,i,e)),a=Vf(Jt(n,i,t));return!!(r!==o&&s!==a||0===r&&Hf(e,n,t)||0===o&&Hf(e,i,t)||0===s&&Hf(n,e,i)||0===a&&Hf(n,t,i))}function Hf(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function Vf(e){return e>0?1:e<0?-1:0}function iu(e,t){return Jt(e.prev,e,e.next)<0?Jt(e,t,e.next)>=0&&Jt(e,e.prev,t)>=0:Jt(e,t,e.prev)<0||Jt(e,e.next,t)<0}function yD(e,t){const n=new Wy(e.i,e.x,e.y),i=new Wy(t.i,t.x,t.y),r=e.next,o=t.prev;return e.next=t,t.prev=e,n.next=r,r.prev=n,i.next=n,n.prev=i,o.next=i,i.prev=o,i}function vD(e,t,n,i){const r=new Wy(e,t,n);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function ru(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Wy(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}const io={area:function(e){const t=e.length;let n=0;for(let i=t-1,r=0;r<t;i=r++)n+=e[i].x*e[r].y-e[r].x*e[i].y;return.5*n},isClockWise:function(e){return io.area(e)<0},triangulateShape:function(e,t){const n=[],i=[],r=[];_D(e),xD(n,e);let o=e.length;t.forEach(_D);for(let a=0;a<t.length;a++)i.push(o),o+=t[a].length,xD(n,t[a]);const s=function(e,t,n){n=n||2;const i=t&&t.length,r=i?t[0]*n:e.length;let o=mD(e,0,r,n,!0);const s=[];if(!o||o.next===o.prev)return s;let a,c,l,d,u,f,h;if(i&&(o=function rG(e,t,n,i){const r=[];let o,s,a,c,l;for(o=0,s=t.length;o<s;o++)a=t[o]*i,c=o<s-1?t[o+1]*i:e.length,l=mD(e,a,c,i,!1),l===l.next&&(l.steiner=!0),r.push(dG(l));for(r.sort(oG),o=0;o<r.length;o++)sG(r[o],n),n=No(n,n.next);return n}(e,t,o,n)),e.length>80*n){a=l=e[0],c=d=e[1];for(let p=n;p<r;p+=n)u=e[p],f=e[p+1],u<a&&(a=u),f<c&&(c=f),u>l&&(l=u),f>d&&(d=f);h=Math.max(l-a,d-c),h=0!==h?1/h:0}return nu(o,s,n,a,c,h),s}(n,i);for(let a=0;a<s.length;a+=3)r.push(s.slice(a,a+3));return r}};function _D(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function xD(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}class ou extends Me{constructor(t,n){super(),this.type="ExtrudeBufferGeometry",this.parameters={shapes:t,options:n},t=Array.isArray(t)?t:[t];const i=this,r=[],o=[];for(let a=0,c=t.length;a<c;a++)s(t[a]);function s(a){const c=[],l=void 0!==n.curveSegments?n.curveSegments:12,d=void 0!==n.steps?n.steps:1;let u=void 0!==n.depth?n.depth:100,f=void 0===n.bevelEnabled||n.bevelEnabled,h=void 0!==n.bevelThickness?n.bevelThickness:6,p=void 0!==n.bevelSize?n.bevelSize:h-2,y=void 0!==n.bevelOffset?n.bevelOffset:0,v=void 0!==n.bevelSegments?n.bevelSegments:3;const g=n.extrudePath,m=void 0!==n.UVGenerator?n.UVGenerator:gG;void 0!==n.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),u=n.amount);let _,b,x,D,I,w=!1;g&&(_=g.getSpacedPoints(d),w=!0,f=!1,b=g.computeFrenetFrames(d,!1),x=new M,D=new M,I=new M),f||(v=0,h=0,p=0,y=0);const R=a.extractPoints(l);let U=R.shape;const P=R.holes;if(!io.isClockWise(U)){U=U.reverse();for(let q=0,Z=P.length;q<Z;q++){const K=P[q];io.isClockWise(K)&&(P[q]=K.reverse())}}const N=io.triangulateShape(U,P),L=U;for(let q=0,Z=P.length;q<Z;q++)U=U.concat(P[q]);function A(q,Z,K){return Z||console.error("THREE.ExtrudeGeometry: vec does not exist"),Z.clone().multiplyScalar(K).add(q)}const B=U.length,W=N.length;function Y(q,Z,K){let Se,ce,T;const S=q.x-Z.x,$=q.y-Z.y,j=K.x-q.x,C=K.y-q.y,X=S*S+$*$;if(Math.abs(S*C-$*j)>Number.EPSILON){const _e=Math.sqrt(X),Q=Math.sqrt(j*j+C*C),ve=Z.x-$/_e,Te=Z.y+S/_e,He=((K.x-C/Q-ve)*C-(K.y+j/Q-Te)*j)/(S*C-$*j);Se=ve+S*He-q.x,ce=Te+$*He-q.y;const Kt=Se*Se+ce*ce;if(Kt<=2)return new V(Se,ce);T=Math.sqrt(Kt/2)}else{let _e=!1;S>Number.EPSILON?j>Number.EPSILON&&(_e=!0):S<-Number.EPSILON?j<-Number.EPSILON&&(_e=!0):Math.sign($)===Math.sign(C)&&(_e=!0),_e?(Se=-$,ce=S,T=Math.sqrt(X)):(Se=S,ce=$,T=Math.sqrt(X/2))}return new V(Se/T,ce/T)}const oe=[];for(let q=0,Z=L.length,K=Z-1,Se=q+1;q<Z;q++,K++,Se++)K===Z&&(K=0),Se===Z&&(Se=0),oe[q]=Y(L[q],L[K],L[Se]);const he=[];let ue,Je=oe.concat();for(let q=0,Z=P.length;q<Z;q++){const K=P[q];ue=[];for(let Se=0,ce=K.length,T=ce-1,S=Se+1;Se<ce;Se++,T++,S++)T===ce&&(T=0),S===ce&&(S=0),ue[Se]=Y(K[Se],K[T],K[S]);he.push(ue),Je=Je.concat(ue)}for(let q=0;q<v;q++){const Z=q/v,K=h*Math.cos(Z*Math.PI/2),Se=p*Math.sin(Z*Math.PI/2)+y;for(let ce=0,T=L.length;ce<T;ce++){const S=A(L[ce],oe[ce],Se);Fe(S.x,S.y,-K)}for(let ce=0,T=P.length;ce<T;ce++){const S=P[ce];ue=he[ce];for(let $=0,j=S.length;$<j;$++){const C=A(S[$],ue[$],Se);Fe(C.x,C.y,-K)}}}const nt=p+y;for(let q=0;q<B;q++){const Z=f?A(U[q],Je[q],nt):U[q];w?(D.copy(b.normals[0]).multiplyScalar(Z.x),x.copy(b.binormals[0]).multiplyScalar(Z.y),I.copy(_[0]).add(D).add(x),Fe(I.x,I.y,I.z)):Fe(Z.x,Z.y,0)}for(let q=1;q<=d;q++)for(let Z=0;Z<B;Z++){const K=f?A(U[Z],Je[Z],nt):U[Z];w?(D.copy(b.normals[q]).multiplyScalar(K.x),x.copy(b.binormals[q]).multiplyScalar(K.y),I.copy(_[q]).add(D).add(x),Fe(I.x,I.y,I.z)):Fe(K.x,K.y,u/d*q)}for(let q=v-1;q>=0;q--){const Z=q/v,K=h*Math.cos(Z*Math.PI/2),Se=p*Math.sin(Z*Math.PI/2)+y;for(let ce=0,T=L.length;ce<T;ce++){const S=A(L[ce],oe[ce],Se);Fe(S.x,S.y,u+K)}for(let ce=0,T=P.length;ce<T;ce++){const S=P[ce];ue=he[ce];for(let $=0,j=S.length;$<j;$++){const C=A(S[$],ue[$],Se);w?Fe(C.x,C.y+_[d-1].y,_[d-1].x+K):Fe(C.x,C.y,u+K)}}}function Vn(q,Z){let K=q.length;for(;--K>=0;){const Se=K;let ce=K-1;ce<0&&(ce=q.length-1);for(let T=0,S=d+2*v;T<S;T++){const $=B*T,j=B*(T+1);Qe(Z+Se+$,Z+ce+$,Z+ce+j,Z+Se+j)}}}function Fe(q,Z,K){c.push(q),c.push(Z),c.push(K)}function yt(q,Z,K){St(q),St(Z),St(K);const Se=r.length/3,ce=m.generateTopUV(i,r,Se-3,Se-2,Se-1);lt(ce[0]),lt(ce[1]),lt(ce[2])}function Qe(q,Z,K,Se){St(q),St(Z),St(Se),St(Z),St(K),St(Se);const ce=r.length/3,T=m.generateSideWallUV(i,r,ce-6,ce-3,ce-2,ce-1);lt(T[0]),lt(T[1]),lt(T[3]),lt(T[1]),lt(T[2]),lt(T[3])}function St(q){r.push(c[3*q+0]),r.push(c[3*q+1]),r.push(c[3*q+2])}function lt(q){o.push(q.x),o.push(q.y)}(function Qt(){const q=r.length/3;if(f){let Z=0,K=B*Z;for(let Se=0;Se<W;Se++){const ce=N[Se];yt(ce[2]+K,ce[1]+K,ce[0]+K)}Z=d+2*v,K=B*Z;for(let Se=0;Se<W;Se++){const ce=N[Se];yt(ce[0]+K,ce[1]+K,ce[2]+K)}}else{for(let Z=0;Z<W;Z++){const K=N[Z];yt(K[2],K[1],K[0])}for(let Z=0;Z<W;Z++){const K=N[Z];yt(K[0]+B*d,K[1]+B*d,K[2]+B*d)}}i.addGroup(q,r.length/3-q,0)})(),function z(){const q=r.length/3;let Z=0;Vn(L,Z),Z+=L.length;for(let K=0,Se=P.length;K<Se;K++){const ce=P[K];Vn(ce,Z),Z+=ce.length}i.addGroup(q,r.length/3-q,1)}()}this.setAttribute("position",new te(r,3)),this.setAttribute("uv",new te(o,2)),this.computeVertexNormals()}toJSON(){const t=Me.prototype.toJSON.call(this);return function yG(e,t,n){if(n.shapes=[],Array.isArray(e))for(let i=0,r=e.length;i<r;i++)n.shapes.push(e[i].uuid);else n.shapes.push(e.uuid);return void 0!==t.extrudePath&&(n.options.extrudePath=t.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,t)}}const gG={generateTopUV:function(e,t,n,i,r){const a=t[3*i],c=t[3*i+1],l=t[3*r],d=t[3*r+1];return[new V(t[3*n],t[3*n+1]),new V(a,c),new V(l,d)]},generateSideWallUV:function(e,t,n,i,r,o){const s=t[3*n],a=t[3*n+1],c=t[3*n+2],l=t[3*i],d=t[3*i+1],u=t[3*i+2],f=t[3*r],h=t[3*r+1],p=t[3*r+2],y=t[3*o],v=t[3*o+1],g=t[3*o+2];return Math.abs(a-d)<.01?[new V(s,1-c),new V(l,1-u),new V(f,1-p),new V(y,1-g)]:[new V(a,1-c),new V(d,1-u),new V(h,1-p),new V(v,1-g)]}};class qy extends Lt{constructor(t,n){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:n},this.fromBufferGeometry(new ou(t,n)),this.mergeVertices()}toJSON(){const t=super.toJSON();return function vG(e,t,n){if(n.shapes=[],Array.isArray(e))for(let i=0,r=e.length;i<r;i++)n.shapes.push(e[i].uuid);else n.shapes.push(e.uuid);return void 0!==t.extrudePath&&(n.options.extrudePath=t.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,t)}}class $y extends vs{constructor(t=1,n=0){const i=(1+Math.sqrt(5))/2;super([-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,n),this.type="IcosahedronBufferGeometry",this.parameters={radius:t,detail:n}}}class wD extends Lt{constructor(t,n){super(),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:n},this.fromBufferGeometry(new $y(t,n)),this.mergeVertices()}}class Xy extends Me{constructor(t,n=12,i=0,r=2*Math.PI){super(),this.type="LatheBufferGeometry",this.parameters={points:t,segments:n,phiStart:i,phiLength:r},n=Math.floor(n),r=ke.clamp(r,0,2*Math.PI);const o=[],s=[],a=[],c=1/n,l=new M,d=new V;for(let u=0;u<=n;u++){const f=i+u*c*r,h=Math.sin(f),p=Math.cos(f);for(let y=0;y<=t.length-1;y++)l.x=t[y].x*h,l.y=t[y].y,l.z=t[y].x*p,s.push(l.x,l.y,l.z),d.x=u/n,d.y=y/(t.length-1),a.push(d.x,d.y)}for(let u=0;u<n;u++)for(let f=0;f<t.length-1;f++){const h=f+u*t.length,y=h+t.length,v=h+t.length+1,g=h+1;o.push(h,y,g),o.push(y,v,g)}if(this.setIndex(o),this.setAttribute("position",new te(s,3)),this.setAttribute("uv",new te(a,2)),this.computeVertexNormals(),r===2*Math.PI){const u=this.attributes.normal.array,f=new M,h=new M,p=new M,y=n*t.length*3;for(let v=0,g=0;v<t.length;v++,g+=3)f.x=u[g+0],f.y=u[g+1],f.z=u[g+2],h.x=u[y+g+0],h.y=u[y+g+1],h.z=u[y+g+2],p.addVectors(f,h).normalize(),u[g+0]=u[y+g+0]=p.x,u[g+1]=u[y+g+1]=p.y,u[g+2]=u[y+g+2]=p.z}}}class bD extends Lt{constructor(t,n,i,r){super(),this.type="LatheGeometry",this.parameters={points:t,segments:n,phiStart:i,phiLength:r},this.fromBufferGeometry(new Xy(t,n,i,r)),this.mergeVertices()}}class Uf extends vs{constructor(t=1,n=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,n),this.type="OctahedronBufferGeometry",this.parameters={radius:t,detail:n}}}class MD extends Lt{constructor(t,n){super(),this.type="OctahedronGeometry",this.parameters={radius:t,detail:n},this.fromBufferGeometry(new Uf(t,n)),this.mergeVertices()}}function rc(e,t,n){Me.call(this),this.type="ParametricBufferGeometry",this.parameters={func:e,slices:t,stacks:n};const i=[],r=[],o=[],s=[],a=1e-5,c=new M,l=new M,d=new M,u=new M,f=new M;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const h=t+1;for(let p=0;p<=n;p++){const y=p/n;for(let v=0;v<=t;v++){const g=v/t;e(g,y,l),r.push(l.x,l.y,l.z),g-a>=0?(e(g-a,y,d),u.subVectors(l,d)):(e(g+a,y,d),u.subVectors(d,l)),y-a>=0?(e(g,y-a,d),f.subVectors(l,d)):(e(g,y+a,d),f.subVectors(d,l)),c.crossVectors(u,f).normalize(),o.push(c.x,c.y,c.z),s.push(g,y)}}for(let p=0;p<n;p++)for(let y=0;y<t;y++){const g=p*h+y+1,m=(p+1)*h+y+1,_=(p+1)*h+y;i.push(p*h+y,g,_),i.push(g,m,_)}this.setIndex(i),this.setAttribute("position",new te(r,3)),this.setAttribute("normal",new te(o,3)),this.setAttribute("uv",new te(s,2))}function su(e,t,n){Lt.call(this),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:n},this.fromBufferGeometry(new rc(e,t,n)),this.mergeVertices()}(rc.prototype=Object.create(Me.prototype)).constructor=rc,(su.prototype=Object.create(Lt.prototype)).constructor=su;class ED extends Lt{constructor(t,n,i,r){super(),this.type="PlaneGeometry",this.parameters={width:t,height:n,widthSegments:i,heightSegments:r},this.fromBufferGeometry(new yf(t,n,i,r)),this.mergeVertices()}}class SD extends Lt{constructor(t,n,i,r){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:n,radius:i,detail:r},this.fromBufferGeometry(new vs(t,n,i,r)),this.mergeVertices()}}class Yy extends Me{constructor(t=.5,n=1,i=8,r=1,o=0,s=2*Math.PI){super(),this.type="RingBufferGeometry",this.parameters={innerRadius:t,outerRadius:n,thetaSegments:i,phiSegments:r,thetaStart:o,thetaLength:s},i=Math.max(3,i);const a=[],c=[],l=[],d=[];let u=t;const f=(n-t)/(r=Math.max(1,r)),h=new M,p=new V;for(let y=0;y<=r;y++){for(let v=0;v<=i;v++){const g=o+v/i*s;h.x=u*Math.cos(g),h.y=u*Math.sin(g),c.push(h.x,h.y,h.z),l.push(0,0,1),p.x=(h.x/n+1)/2,p.y=(h.y/n+1)/2,d.push(p.x,p.y)}u+=f}for(let y=0;y<r;y++){const v=y*(i+1);for(let g=0;g<i;g++){const m=g+v,w=m+i+1,b=m+i+2,x=m+1;a.push(m,w,x),a.push(w,b,x)}}this.setIndex(a),this.setAttribute("position",new te(c,3)),this.setAttribute("normal",new te(l,3)),this.setAttribute("uv",new te(d,2))}}class TD extends Lt{constructor(t,n,i,r,o,s){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:n,thetaSegments:i,phiSegments:r,thetaStart:o,thetaLength:s},this.fromBufferGeometry(new Yy(t,n,i,r,o,s)),this.mergeVertices()}}class Zy extends Me{constructor(t,n=12){super(),this.type="ShapeBufferGeometry",this.parameters={shapes:t,curveSegments:n};const i=[],r=[],o=[],s=[];let a=0,c=0;if(!1===Array.isArray(t))l(t);else for(let d=0;d<t.length;d++)l(t[d]),this.addGroup(a,c,d),a+=c,c=0;function l(d){const u=r.length/3,f=d.extractPoints(n);let h=f.shape;const p=f.holes;!1===io.isClockWise(h)&&(h=h.reverse());for(let v=0,g=p.length;v<g;v++){const m=p[v];!0===io.isClockWise(m)&&(p[v]=m.reverse())}const y=io.triangulateShape(h,p);for(let v=0,g=p.length;v<g;v++)h=h.concat(p[v]);for(let v=0,g=h.length;v<g;v++){const m=h[v];r.push(m.x,m.y,0),o.push(0,0,1),s.push(m.x,m.y)}for(let v=0,g=y.length;v<g;v++){const m=y[v];i.push(m[0]+u,m[1]+u,m[2]+u),c+=3}}this.setIndex(i),this.setAttribute("position",new te(r,3)),this.setAttribute("normal",new te(o,3)),this.setAttribute("uv",new te(s,2))}toJSON(){const t=Me.prototype.toJSON.call(this);return function _G(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,i=e.length;n<i;n++)t.shapes.push(e[n].uuid);else t.shapes.push(e.uuid);return t}(this.parameters.shapes,t)}}class Jy extends Lt{constructor(t,n){super(),this.type="ShapeGeometry","object"==typeof n&&(console.warn("THREE.ShapeGeometry: Options parameter has been removed."),n=n.curveSegments),this.parameters={shapes:t,curveSegments:n},this.fromBufferGeometry(new Zy(t,n)),this.mergeVertices()}toJSON(){const t=Lt.prototype.toJSON.call(this);return function xG(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,i=e.length;n<i;n++)t.shapes.push(e[n].uuid);else t.shapes.push(e.uuid);return t}(this.parameters.shapes,t)}}class Gf extends Me{constructor(t=1,n=8,i=6,r=0,o=2*Math.PI,s=0,a=Math.PI){super(),this.type="SphereBufferGeometry",this.parameters={radius:t,widthSegments:n,heightSegments:i,phiStart:r,phiLength:o,thetaStart:s,thetaLength:a},n=Math.max(3,Math.floor(n)),i=Math.max(2,Math.floor(i));const c=Math.min(s+a,Math.PI);let l=0;const d=[],u=new M,f=new M,h=[],p=[],y=[],v=[];for(let g=0;g<=i;g++){const m=[],_=g/i;let w=0;0==g&&0==s?w=.5/n:g==i&&c==Math.PI&&(w=-.5/n);for(let b=0;b<=n;b++){const x=b/n;u.x=-t*Math.cos(r+x*o)*Math.sin(s+_*a),u.y=t*Math.cos(s+_*a),u.z=t*Math.sin(r+x*o)*Math.sin(s+_*a),p.push(u.x,u.y,u.z),f.copy(u).normalize(),y.push(f.x,f.y,f.z),v.push(x+w,1-_),m.push(l++)}d.push(m)}for(let g=0;g<i;g++)for(let m=0;m<n;m++){const _=d[g][m+1],w=d[g][m],b=d[g+1][m],x=d[g+1][m+1];(0!==g||s>0)&&h.push(_,w,x),(g!==i-1||c<Math.PI)&&h.push(w,b,x)}this.setIndex(h),this.setAttribute("position",new te(p,3)),this.setAttribute("normal",new te(y,3)),this.setAttribute("uv",new te(v,2))}}class DD extends Lt{constructor(t,n,i,r,o,s,a){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:n,heightSegments:i,phiStart:r,phiLength:o,thetaStart:s,thetaLength:a},this.fromBufferGeometry(new Gf(t,n,i,r,o,s,a)),this.mergeVertices()}}class Qy extends vs{constructor(t=1,n=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,n),this.type="TetrahedronBufferGeometry",this.parameters={radius:t,detail:n}}}class CD extends Lt{constructor(t,n){super(),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:n},this.fromBufferGeometry(new Qy(t,n)),this.mergeVertices()}}class Ky extends ou{constructor(t,n={}){const i=n.font;if(!i||!i.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new Me;const r=i.generateShapes(t,n.size);n.depth=void 0!==n.height?n.height:50,void 0===n.bevelThickness&&(n.bevelThickness=10),void 0===n.bevelSize&&(n.bevelSize=8),void 0===n.bevelEnabled&&(n.bevelEnabled=!1),super(r,n),this.type="TextBufferGeometry"}}class AD extends Lt{constructor(t,n){super(),this.type="TextGeometry",this.parameters={text:t,parameters:n},this.fromBufferGeometry(new Ky(t,n)),this.mergeVertices()}}class ev extends Me{constructor(t=1,n=.4,i=8,r=6,o=2*Math.PI){super(),this.type="TorusBufferGeometry",this.parameters={radius:t,tube:n,radialSegments:i,tubularSegments:r,arc:o},i=Math.floor(i),r=Math.floor(r);const s=[],a=[],c=[],l=[],d=new M,u=new M,f=new M;for(let h=0;h<=i;h++)for(let p=0;p<=r;p++){const y=p/r*o,v=h/i*Math.PI*2;u.x=(t+n*Math.cos(v))*Math.cos(y),u.y=(t+n*Math.cos(v))*Math.sin(y),u.z=n*Math.sin(v),a.push(u.x,u.y,u.z),d.x=t*Math.cos(y),d.y=t*Math.sin(y),f.subVectors(u,d).normalize(),c.push(f.x,f.y,f.z),l.push(p/r),l.push(h/i)}for(let h=1;h<=i;h++)for(let p=1;p<=r;p++){const v=(r+1)*(h-1)+p-1,g=(r+1)*(h-1)+p,m=(r+1)*h+p;s.push((r+1)*h+p-1,v,m),s.push(v,g,m)}this.setIndex(s),this.setAttribute("position",new te(a,3)),this.setAttribute("normal",new te(c,3)),this.setAttribute("uv",new te(l,2))}}class ID extends Lt{constructor(t,n,i,r,o){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:n,radialSegments:i,tubularSegments:r,arc:o},this.fromBufferGeometry(new ev(t,n,i,r,o)),this.mergeVertices()}}class tv extends Me{constructor(t=1,n=.4,i=64,r=8,o=2,s=3){super(),this.type="TorusKnotBufferGeometry",this.parameters={radius:t,tube:n,tubularSegments:i,radialSegments:r,p:o,q:s},i=Math.floor(i),r=Math.floor(r);const a=[],c=[],l=[],d=[],u=new M,f=new M,h=new M,p=new M,y=new M,v=new M,g=new M;for(let _=0;_<=i;++_){const w=_/i*o*Math.PI*2;m(w,o,s,t,h),m(w+.01,o,s,t,p),v.subVectors(p,h),g.addVectors(p,h),y.crossVectors(v,g),g.crossVectors(y,v),y.normalize(),g.normalize();for(let b=0;b<=r;++b){const x=b/r*Math.PI*2,D=-n*Math.cos(x),I=n*Math.sin(x);u.x=h.x+(D*g.x+I*y.x),u.y=h.y+(D*g.y+I*y.y),u.z=h.z+(D*g.z+I*y.z),c.push(u.x,u.y,u.z),f.subVectors(u,h).normalize(),l.push(f.x,f.y,f.z),d.push(_/i),d.push(b/r)}}for(let _=1;_<=i;_++)for(let w=1;w<=r;w++){const x=(r+1)*_+(w-1),D=(r+1)*_+w,I=(r+1)*(_-1)+w;a.push((r+1)*(_-1)+(w-1),x,I),a.push(x,D,I)}function m(_,w,b,x,D){const I=Math.cos(_),R=Math.sin(_),U=b/w*_,P=Math.cos(U);D.x=x*(2+P)*.5*I,D.y=x*(2+P)*R*.5,D.z=x*Math.sin(U)*.5}this.setIndex(a),this.setAttribute("position",new te(c,3)),this.setAttribute("normal",new te(l,3)),this.setAttribute("uv",new te(d,2))}}class LD extends Lt{constructor(t,n,i,r,o,s,a){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:n,tubularSegments:i,radialSegments:r,p:o,q:s},void 0!==a&&console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),this.fromBufferGeometry(new tv(t,n,i,r,o,s)),this.mergeVertices()}}class nv extends Me{constructor(t,n=64,i=1,r=8,o=!1){super(),this.type="TubeBufferGeometry",this.parameters={path:t,tubularSegments:n,radius:i,radialSegments:r,closed:o};const s=t.computeFrenetFrames(n,o);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const a=new M,c=new M,l=new V;let d=new M;const u=[],f=[],h=[],p=[];function v(_){d=t.getPointAt(_/n,d);const w=s.normals[_],b=s.binormals[_];for(let x=0;x<=r;x++){const D=x/r*Math.PI*2,I=Math.sin(D),R=-Math.cos(D);c.x=R*w.x+I*b.x,c.y=R*w.y+I*b.y,c.z=R*w.z+I*b.z,c.normalize(),f.push(c.x,c.y,c.z),a.x=d.x+i*c.x,a.y=d.y+i*c.y,a.z=d.z+i*c.z,u.push(a.x,a.y,a.z)}}(function y(){for(let _=0;_<n;_++)v(_);v(!1===o?n:0),function m(){for(let _=0;_<=n;_++)for(let w=0;w<=r;w++)l.x=_/n,l.y=w/r,h.push(l.x,l.y)}(),function g(){for(let _=1;_<=n;_++)for(let w=1;w<=r;w++){const x=(r+1)*_+(w-1),D=(r+1)*_+w,I=(r+1)*(_-1)+w;p.push((r+1)*(_-1)+(w-1),x,I),p.push(x,D,I)}}()})(),this.setIndex(p),this.setAttribute("position",new te(u,3)),this.setAttribute("normal",new te(f,3)),this.setAttribute("uv",new te(h,2))}toJSON(){const t=Me.prototype.toJSON.call(this);return t.path=this.parameters.path.toJSON(),t}}class RD extends Lt{constructor(t,n,i,r,o,s){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:n,radius:i,radialSegments:r,closed:o},void 0!==s&&console.warn("THREE.TubeGeometry: taper has been removed.");const a=new nv(t,n,i,r,o);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals,this.fromBufferGeometry(a),this.mergeVertices()}}class iv extends Me{constructor(t){super(),this.type="WireframeGeometry";const n=[],i=[0,0],r={},o=["a","b","c"];if(t&&t.isGeometry){const s=t.faces;for(let a=0,c=s.length;a<c;a++){const l=s[a];for(let d=0;d<3;d++){const u=l[o[d]],f=l[o[(d+1)%3]];i[0]=Math.min(u,f),i[1]=Math.max(u,f);const h=i[0]+","+i[1];void 0===r[h]&&(r[h]={index1:i[0],index2:i[1]})}}for(const a in r){const c=r[a];let l=t.vertices[c.index1];n.push(l.x,l.y,l.z),l=t.vertices[c.index2],n.push(l.x,l.y,l.z)}}else if(t&&t.isBufferGeometry){const s=new M;if(null!==t.index){const a=t.attributes.position,c=t.index;let l=t.groups;0===l.length&&(l=[{start:0,count:c.count,materialIndex:0}]);for(let d=0,u=l.length;d<u;++d){const f=l[d],h=f.start;for(let y=h,v=h+f.count;y<v;y+=3)for(let g=0;g<3;g++){const m=c.getX(y+g),_=c.getX(y+(g+1)%3);i[0]=Math.min(m,_),i[1]=Math.max(m,_);const w=i[0]+","+i[1];void 0===r[w]&&(r[w]={index1:i[0],index2:i[1]})}}for(const d in r){const u=r[d];s.fromBufferAttribute(a,u.index1),n.push(s.x,s.y,s.z),s.fromBufferAttribute(a,u.index2),n.push(s.x,s.y,s.z)}}else{const a=t.attributes.position;for(let c=0,l=a.count/3;c<l;c++)for(let d=0;d<3;d++)s.fromBufferAttribute(a,3*c+d),n.push(s.x,s.y,s.z),s.fromBufferAttribute(a,3*c+(d+1)%3),n.push(s.x,s.y,s.z)}}this.setAttribute("position",new te(n,3))}}var Kn=Object.freeze({__proto__:null,BoxGeometry:ky,BoxBufferGeometry:kl,CircleGeometry:dD,CircleBufferGeometry:Hy,ConeGeometry:fD,ConeBufferGeometry:hD,CylinderGeometry:Vy,CylinderBufferGeometry:tu,DodecahedronGeometry:pD,DodecahedronBufferGeometry:Uy,EdgesGeometry:zy,ExtrudeGeometry:qy,ExtrudeBufferGeometry:ou,IcosahedronGeometry:wD,IcosahedronBufferGeometry:$y,LatheGeometry:bD,LatheBufferGeometry:Xy,OctahedronGeometry:MD,OctahedronBufferGeometry:Uf,ParametricGeometry:su,ParametricBufferGeometry:rc,PlaneGeometry:ED,PlaneBufferGeometry:yf,PolyhedronGeometry:SD,PolyhedronBufferGeometry:vs,RingGeometry:TD,RingBufferGeometry:Yy,ShapeGeometry:Jy,ShapeBufferGeometry:Zy,SphereGeometry:DD,SphereBufferGeometry:Gf,TetrahedronGeometry:CD,TetrahedronBufferGeometry:Qy,TextGeometry:AD,TextBufferGeometry:Ky,TorusGeometry:ID,TorusBufferGeometry:ev,TorusKnotGeometry:LD,TorusKnotBufferGeometry:tv,TubeGeometry:RD,TubeBufferGeometry:nv,WireframeGeometry:iv});function _s(e){Pe.call(this),this.type="ShadowMaterial",this.color=new ae(0),this.transparent=!0,this.setValues(e)}function ro(e){Jn.call(this,e),this.type="RawShaderMaterial"}function Tr(e){Pe.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new ae(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ae(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=cs,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(e)}function Oo(e){Tr.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new V(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=ke.clamp(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}function Bo(e){Pe.call(this),this.type="MeshPhongMaterial",this.color=new ae(16777215),this.specular=new ae(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ae(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=cs,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ul,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function xs(e){Pe.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ae(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ae(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=cs,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function ws(e){Pe.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=cs,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function bs(e){Pe.call(this),this.type="MeshLambertMaterial",this.color=new ae(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ae(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ul,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Ms(e){Pe.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ae(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=cs,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Es(e){$t.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}(_s.prototype=Object.create(Pe.prototype)).constructor=_s,_s.prototype.isShadowMaterial=!0,_s.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.color.copy(e.color),this},(ro.prototype=Object.create(Jn.prototype)).constructor=ro,ro.prototype.isRawShaderMaterial=!0,(Tr.prototype=Object.create(Pe.prototype)).constructor=Tr,Tr.prototype.isMeshStandardMaterial=!0,Tr.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.vertexTangents=e.vertexTangents,this},(Oo.prototype=Object.create(Tr.prototype)).constructor=Oo,Oo.prototype.isMeshPhysicalMaterial=!0,Oo.prototype.copy=function(e){return Tr.prototype.copy.call(this,e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,this.sheen=e.sheen?(this.sheen||new ae).copy(e.sheen):null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this},(Bo.prototype=Object.create(Pe.prototype)).constructor=Bo,Bo.prototype.isMeshPhongMaterial=!0,Bo.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},(xs.prototype=Object.create(Pe.prototype)).constructor=xs,xs.prototype.isMeshToonMaterial=!0,xs.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},(ws.prototype=Object.create(Pe.prototype)).constructor=ws,ws.prototype.isMeshNormalMaterial=!0,ws.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},(bs.prototype=Object.create(Pe.prototype)).constructor=bs,bs.prototype.isMeshLambertMaterial=!0,bs.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},(Ms.prototype=Object.create(Pe.prototype)).constructor=Ms,Ms.prototype.isMeshMatcapMaterial=!0,Ms.prototype.copy=function(e){return Pe.prototype.copy.call(this,e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},(Es.prototype=Object.create($t.prototype)).constructor=Es,Es.prototype.isLineDashedMaterial=!0,Es.prototype.copy=function(e){return $t.prototype.copy.call(this,e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this};var wG=Object.freeze({__proto__:null,ShadowMaterial:_s,SpriteMaterial:Fo,RawShaderMaterial:ro,ShaderMaterial:Jn,PointsMaterial:er,MeshPhysicalMaterial:Oo,MeshStandardMaterial:Tr,MeshPhongMaterial:Bo,MeshToonMaterial:xs,MeshNormalMaterial:ws,MeshLambertMaterial:bs,MeshDepthMaterial:Io,MeshDistanceMaterial:Lo,MeshBasicMaterial:Pi,MeshMatcapMaterial:Ms,LineDashedMaterial:Es,LineBasicMaterial:$t,Material:Pe});const zt={arraySlice:function(e,t,n){return zt.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==n?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:"number"==typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){const n=e.length,i=new Array(n);for(let r=0;r!==n;++r)i[r]=r;return i.sort(function t(r,o){return e[r]-e[o]}),i},sortedArray:function(e,t,n){const i=e.length,r=new e.constructor(i);for(let o=0,s=0;s!==i;++o){const a=n[o]*t;for(let c=0;c!==t;++c)r[s++]=e[a+c]}return r},flattenJSON:function(e,t,n,i){let r=1,o=e[0];for(;void 0!==o&&void 0===o[i];)o=e[r++];if(void 0===o)return;let s=o[i];if(void 0!==s)if(Array.isArray(s))do{s=o[i],void 0!==s&&(t.push(o.time),n.push.apply(n,s)),o=e[r++]}while(void 0!==o);else if(void 0!==s.toArray)do{s=o[i],void 0!==s&&(t.push(o.time),s.toArray(n,n.length)),o=e[r++]}while(void 0!==o);else do{s=o[i],void 0!==s&&(t.push(o.time),n.push(s)),o=e[r++]}while(void 0!==o)},subclip:function(e,t,n,i,r=30){const o=e.clone();o.name=t;const s=[];for(let c=0;c<o.tracks.length;++c){const l=o.tracks[c],d=l.getValueSize(),u=[],f=[];for(let h=0;h<l.times.length;++h){const p=l.times[h]*r;if(!(p<n||p>=i)){u.push(l.times[h]);for(let y=0;y<d;++y)f.push(l.values[h*d+y])}}0!==u.length&&(l.times=zt.convertArray(u,l.times.constructor),l.values=zt.convertArray(f,l.values.constructor),s.push(l))}o.tracks=s;let a=1/0;for(let c=0;c<o.tracks.length;++c)a>o.tracks[c].times[0]&&(a=o.tracks[c].times[0]);for(let c=0;c<o.tracks.length;++c)o.tracks[c].shift(-1*a);return o.resetDuration(),o},makeClipAdditive:function(e,t=0,n=e,i=30){i<=0&&(i=30);const r=n.tracks.length,o=t/i;for(let s=0;s<r;++s){const a=n.tracks[s],c=a.ValueTypeName;if("bool"===c||"string"===c)continue;const l=e.tracks.find(function(g){return g.name===a.name&&g.ValueTypeName===c});if(void 0===l)continue;let d=0;const u=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=u/3);let f=0;const h=l.getValueSize();l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=h/3);const p=a.times.length-1;let y;if(o<=a.times[0])y=zt.arraySlice(a.values,d,u-d);else if(o>=a.times[p]){const g=p*u+d;y=zt.arraySlice(a.values,g,g+u-d)}else{const g=a.createInterpolant(),m=d,_=u-d;g.evaluate(o),y=zt.arraySlice(g.resultBuffer,m,_)}"quaternion"===c&&(new On).fromArray(y).normalize().conjugate().toArray(y);const v=l.times.length;for(let g=0;g<v;++g){const m=g*h+f;if("quaternion"===c)On.multiplyQuaternionsFlat(l.values,m,y,0,l.values,m);else{const _=h-2*f;for(let w=0;w<_;++w)l.values[m+w]-=y[w]}}}return e.blendMode=ny,e}};function bi(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==i?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n}function zf(e,t,n,i){bi.call(this,e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function au(e,t,n,i){bi.call(this,e,t,n,i)}function jf(e,t,n,i){bi.call(this,e,t,n,i)}function In(e,t,n,i){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=zt.convertArray(t,this.TimeBufferType),this.values=zt.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}function Wf(e,t,n){In.call(this,e,t,n)}function qf(e,t,n,i){In.call(this,e,t,n,i)}function oc(e,t,n,i){In.call(this,e,t,n,i)}function $f(e,t,n,i){bi.call(this,e,t,n,i)}function cu(e,t,n,i){In.call(this,e,t,n,i)}function Xf(e,t,n,i){In.call(this,e,t,n,i)}function sc(e,t,n,i){In.call(this,e,t,n,i)}function Mi(e,t=-1,n,i=Jd){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=ke.generateUUID(),this.duration<0&&this.resetDuration()}function MG(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=function bG(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return oc;case"vector":case"vector2":case"vector3":case"vector4":return sc;case"color":return qf;case"quaternion":return cu;case"bool":case"boolean":return Wf;case"string":return Xf}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}(e.type);if(void 0===e.times){const n=[],i=[];zt.flattenJSON(e.keys,n,i,"value"),e.times=n,e.values=i}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}Object.assign(bi.prototype,{evaluate:function(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],r=t[n-1];e:{t:{let o;n:{i:if(!(e<i)){for(let s=n+2;;){if(void 0===i){if(e<r)break i;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,r)}if(n===s)break;if(r=i,i=t[++n],e<i)break t}o=t.length;break n}if(e>=r)break e;{const s=t[1];e<s&&(n=2,r=s);for(let a=n-2;;){if(void 0===r)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(n===a)break;if(i=r,r=t[--n-1],e>=r)break t}o=n,n=0}}for(;n<o;){const s=n+o>>>1;e<t[s]?o=s:n=s+1}if(i=t[n],r=t[n-1],void 0===r)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(void 0===i)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,r,e)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,e,i)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=e*i;for(let o=0;o!==i;++o)t[o]=n[r+o];return t},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(bi.prototype,{beforeStart_:bi.prototype.copySampleValue_,afterEnd_:bi.prototype.copySampleValue_}),zf.prototype=Object.assign(Object.create(bi.prototype),{constructor:zf,DefaultSettings_:{endingStart:ss,endingEnd:ss},intervalChanged_:function(e,t,n){const i=this.parameterPositions;let r=e-2,o=e+1,s=i[r],a=i[o];if(void 0===s)switch(this.getSettings_().endingStart){case as:r=e,s=2*t-n;break;case wl:r=i.length-2,s=t+i[r]-i[r+1];break;default:r=e,s=n}if(void 0===a)switch(this.getSettings_().endingEnd){case as:o=e,a=2*n-t;break;case wl:o=1,a=n+i[1]-i[0];break;default:o=e-1,a=t}const c=.5*(n-t),l=this.valueSize;this._weightPrev=c/(t-s),this._weightNext=c/(a-n),this._offsetPrev=r*l,this._offsetNext=o*l},interpolate_:function(e,t,n,i){const r=this.resultBuffer,o=this.sampleValues,s=this.valueSize,a=e*s,c=a-s,l=this._offsetPrev,d=this._offsetNext,u=this._weightPrev,f=this._weightNext,h=(n-t)/(i-t),p=h*h,y=p*h,v=-u*y+2*u*p-u*h,g=(1+u)*y+(-1.5-2*u)*p+(-.5+u)*h+1,m=(-1-f)*y+(1.5+f)*p+.5*h,_=f*y-f*p;for(let w=0;w!==s;++w)r[w]=v*o[l+w]+g*o[c+w]+m*o[a+w]+_*o[d+w];return r}}),au.prototype=Object.assign(Object.create(bi.prototype),{constructor:au,interpolate_:function(e,t,n,i){const r=this.resultBuffer,o=this.sampleValues,s=this.valueSize,a=e*s,c=a-s,l=(n-t)/(i-t),d=1-l;for(let u=0;u!==s;++u)r[u]=o[c+u]*d+o[a+u]*l;return r}}),jf.prototype=Object.assign(Object.create(bi.prototype),{constructor:jf,interpolate_:function(e){return this.copySampleValue_(e-1)}}),Object.assign(In,{toJSON:function(e){const t=e.constructor;let n;if(void 0!==t.toJSON)n=t.toJSON(e);else{n={name:e.name,times:zt.convertArray(e.times,Array),values:zt.convertArray(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}}),Object.assign(In.prototype,{constructor:In,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:xl,InterpolantFactoryMethodDiscrete:function(e){return new jf(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodLinear:function(e){return new au(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:function(e){return new zf(this.times,this.values,this.getValueSize(),e)},setInterpolation:function(e){let t;switch(e){case _l:t=this.InterpolantFactoryMethodDiscrete;break;case xl:t=this.InterpolantFactoryMethodLinear;break;case Zd:t=this.InterpolantFactoryMethodSmooth}if(void 0===t){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(n);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return _l;case this.InterpolantFactoryMethodLinear:return xl;case this.InterpolantFactoryMethodSmooth:return Zd}},getValueSize:function(){return this.values.length/this.times.length},shift:function(e){if(0!==e){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this},scale:function(e){if(1!==e){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this},trim:function(e,t){const n=this.times,i=n.length;let r=0,o=i-1;for(;r!==i&&n[r]<e;)++r;for(;-1!==o&&n[o]>t;)--o;if(++o,0!==r||o!==i){r>=o&&(o=Math.max(o,1),r=o-1);const s=this.getValueSize();this.times=zt.arraySlice(n,r,o),this.values=zt.arraySlice(this.values,r*s,o*s)}return this},validate:function(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,r=n.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let s=0;s!==r;s++){const a=n[s];if("number"==typeof a&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,s,a),e=!1;break}if(null!==o&&o>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,s,a,o),e=!1;break}o=a}if(void 0!==i&&zt.isTypedArray(i))for(let s=0,a=i.length;s!==a;++s){const c=i[s];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,s,c),e=!1;break}}return e},optimize:function(){const e=zt.arraySlice(this.times),t=zt.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===Zd,r=e.length-1;let o=1;for(let s=1;s<r;++s){let a=!1;const c=e[s];if(c!==e[s+1]&&(1!==s||c!==c[0]))if(i)a=!0;else{const d=s*n,u=d-n,f=d+n;for(let h=0;h!==n;++h){const p=t[d+h];if(p!==t[u+h]||p!==t[f+h]){a=!0;break}}}if(a){if(s!==o){e[o]=e[s];const d=s*n,u=o*n;for(let f=0;f!==n;++f)t[u+f]=t[d+f]}++o}}if(r>0){e[o]=e[r];for(let s=r*n,a=o*n,c=0;c!==n;++c)t[a+c]=t[s+c];++o}return o!==e.length?(this.times=zt.arraySlice(e,0,o),this.values=zt.arraySlice(t,0,o*n)):(this.times=e,this.values=t),this},clone:function(){const e=zt.arraySlice(this.times,0),t=zt.arraySlice(this.values,0),i=new(0,this.constructor)(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}),Wf.prototype=Object.assign(Object.create(In.prototype),{constructor:Wf,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:_l,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),qf.prototype=Object.assign(Object.create(In.prototype),{constructor:qf,ValueTypeName:"color"}),oc.prototype=Object.assign(Object.create(In.prototype),{constructor:oc,ValueTypeName:"number"}),$f.prototype=Object.assign(Object.create(bi.prototype),{constructor:$f,interpolate_:function(e,t,n,i){const r=this.resultBuffer,o=this.sampleValues,s=this.valueSize,a=(n-t)/(i-t);let c=e*s;for(let l=c+s;c!==l;c+=4)On.slerpFlat(r,0,o,c-s,o,c,a);return r}}),cu.prototype=Object.assign(Object.create(In.prototype),{constructor:cu,ValueTypeName:"quaternion",DefaultInterpolation:xl,InterpolantFactoryMethodLinear:function(e){return new $f(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:void 0}),Xf.prototype=Object.assign(Object.create(In.prototype),{constructor:Xf,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:_l,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),sc.prototype=Object.assign(Object.create(In.prototype),{constructor:sc,ValueTypeName:"vector"}),Object.assign(Mi,{parse:function(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let o=0,s=n.length;o!==s;++o)t.push(MG(n[o]).scale(i));const r=new Mi(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r},toJSON:function(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,o=n.length;r!==o;++r)t.push(In.toJSON(n[r]));return i},CreateFromMorphTargetSequence:function(e,t,n,i){const r=t.length,o=[];for(let s=0;s<r;s++){let a=[],c=[];a.push((s+r-1)%r,s,(s+1)%r),c.push(0,1,0);const l=zt.getKeyframeOrder(a);a=zt.sortedArray(a,1,l),c=zt.sortedArray(c,1,l),!i&&0===a[0]&&(a.push(r),c.push(c[0])),o.push(new oc(".morphTargetInfluences["+t[s].name+"]",a,c).scale(1/n))}return new Mi(e,-1,o)},findByName:function(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null},CreateClipsFromMorphTargetSequences:function(e,t,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let s=0,a=e.length;s<a;s++){const c=e[s],l=c.name.match(r);if(l&&l.length>1){const d=l[1];let u=i[d];u||(i[d]=u=[]),u.push(c)}}const o=[];for(const s in i)o.push(Mi.CreateFromMorphTargetSequence(s,i[s],t,n));return o},parseAnimation:function(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(d,u,f,h,p){if(0!==f.length){const y=[],v=[];zt.flattenJSON(f,y,v,h),0!==y.length&&p.push(new d(u,y,v))}},i=[],r=e.name||"default",o=e.fps||30,s=e.blendMode;let a=e.length||-1;const c=e.hierarchy||[];for(let d=0;d<c.length;d++){const u=c[d].keys;if(u&&0!==u.length)if(u[0].morphTargets){const f={};let h;for(h=0;h<u.length;h++)if(u[h].morphTargets)for(let p=0;p<u[h].morphTargets.length;p++)f[u[h].morphTargets[p]]=-1;for(const p in f){const y=[],v=[];for(let g=0;g!==u[h].morphTargets.length;++g){const m=u[h];y.push(m.time),v.push(m.morphTarget===p?1:0)}i.push(new oc(".morphTargetInfluence["+p+"]",y,v))}a=f.length*(o||1)}else{const f=".bones["+t[d].name+"]";n(sc,f+".position",u,"pos",i),n(cu,f+".quaternion",u,"rot",i),n(sc,f+".scale",u,"scl",i)}}return 0===i.length?null:new Mi(r,a,i,s)}}),Object.assign(Mi.prototype,{resetDuration:function(){let t=0;for(let n=0,i=this.tracks.length;n!==i;++n){const r=this.tracks[n];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this},trim:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this},validate:function(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e},optimize:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this},clone:function(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new Mi(this.name,this.duration,e,this.blendMode)},toJSON:function(){return Mi.toJSON(this)}});const Ss={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&(this.files[e]=t)},get:function(e){if(!1!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};function rv(e,t,n){const i=this;let a,r=!1,o=0,s=0;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(l){s++,!1===r&&void 0!==i.onStart&&i.onStart(l,o,s),r=!0},this.itemEnd=function(l){o++,void 0!==i.onProgress&&i.onProgress(l,o,s),o===s&&(r=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(l){void 0!==i.onError&&i.onError(l)},this.resolveURL=function(l){return a?a(l):l},this.setURLModifier=function(l){return a=l,this},this.addHandler=function(l,d){return c.push(l,d),this},this.removeHandler=function(l){const d=c.indexOf(l);return-1!==d&&c.splice(d,2),this},this.getHandler=function(l){for(let d=0,u=c.length;d<u;d+=2){const f=c[d],h=c[d+1];if(f.global&&(f.lastIndex=0),f.test(l))return h}return null}}const PD=new rv;function Et(e){this.manager=void 0!==e?e:PD,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(Et.prototype,{load:function(){},loadAsync:function(e,t){const n=this;return new Promise(function(i,r){n.load(e,i,t,r)})},parse:function(){},setCrossOrigin:function(e){return this.crossOrigin=e,this},setWithCredentials:function(e){return this.withCredentials=e,this},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setRequestHeader:function(e){return this.requestHeader=e,this}});const tr={};function Oi(e){Et.call(this,e)}function ov(e){Et.call(this,e)}function sv(e){Et.call(this,e)}function ac(e){Et.call(this,e)}function Yf(e){Et.call(this,e)}function Zf(e){Et.call(this,e)}function Jf(e){Et.call(this,e)}function xe(){this.type="Curve",this.arcLengthDivisions=200}function Ei(e,t,n,i,r,o,s,a){xe.call(this),this.type="EllipseCurve",this.aX=e||0,this.aY=t||0,this.xRadius=n||1,this.yRadius=i||1,this.aStartAngle=r||0,this.aEndAngle=o||2*Math.PI,this.aClockwise=s||!1,this.aRotation=a||0}function cc(e,t,n,i,r,o){Ei.call(this,e,t,n,n,i,r,o),this.type="ArcCurve"}function av(){let e=0,t=0,n=0,i=0;function r(o,s,a,c){e=o,t=a,n=-3*o+3*s-2*a-c,i=2*o-2*s+a+c}return{initCatmullRom:function(o,s,a,c,l){r(s,a,l*(a-o),l*(c-s))},initNonuniformCatmullRom:function(o,s,a,c,l,d,u){let f=(s-o)/l-(a-o)/(l+d)+(a-s)/d,h=(a-s)/d-(c-s)/(d+u)+(c-a)/u;f*=d,h*=d,r(s,a,f,h)},calc:function(o){const s=o*o;return e+t*o+n*s+i*(s*o)}}}Oi.prototype=Object.assign(Object.create(Et.prototype),{constructor:Oi,load:function(e,t,n,i){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=Ss.get(e);if(void 0!==o)return r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o;if(void 0!==tr[e])return void tr[e].push({onLoad:t,onProgress:n,onError:i});const a=e.match(/^data:(.*?)(;base64)?,(.*)$/);let c;if(a){const l=a[1],d=!!a[2];let u=a[3];u=decodeURIComponent(u),d&&(u=atob(u));try{let f;const h=(this.responseType||"").toLowerCase();switch(h){case"arraybuffer":case"blob":const p=new Uint8Array(u.length);for(let v=0;v<u.length;v++)p[v]=u.charCodeAt(v);f="blob"===h?new Blob([p.buffer],{type:l}):p.buffer;break;case"document":f=(new DOMParser).parseFromString(u,l);break;case"json":f=JSON.parse(u);break;default:f=u}setTimeout(function(){t&&t(f),r.manager.itemEnd(e)},0)}catch(f){setTimeout(function(){i&&i(f),r.manager.itemError(e),r.manager.itemEnd(e)},0)}}else{tr[e]=[],tr[e].push({onLoad:t,onProgress:n,onError:i}),c=new XMLHttpRequest,c.open("GET",e,!0),c.addEventListener("load",function(l){const d=this.response,u=tr[e];if(delete tr[e],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Ss.add(e,d);for(let f=0,h=u.length;f<h;f++){const p=u[f];p.onLoad&&p.onLoad(d)}r.manager.itemEnd(e)}else{for(let f=0,h=u.length;f<h;f++){const p=u[f];p.onError&&p.onError(l)}r.manager.itemError(e),r.manager.itemEnd(e)}},!1),c.addEventListener("progress",function(l){const d=tr[e];for(let u=0,f=d.length;u<f;u++){const h=d[u];h.onProgress&&h.onProgress(l)}},!1),c.addEventListener("error",function(l){const d=tr[e];delete tr[e];for(let u=0,f=d.length;u<f;u++){const h=d[u];h.onError&&h.onError(l)}r.manager.itemError(e),r.manager.itemEnd(e)},!1),c.addEventListener("abort",function(l){const d=tr[e];delete tr[e];for(let u=0,f=d.length;u<f;u++){const h=d[u];h.onError&&h.onError(l)}r.manager.itemError(e),r.manager.itemEnd(e)},!1),void 0!==this.responseType&&(c.responseType=this.responseType),void 0!==this.withCredentials&&(c.withCredentials=this.withCredentials),c.overrideMimeType&&c.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const l in this.requestHeader)c.setRequestHeader(l,this.requestHeader[l]);c.send(null)}return r.manager.itemStart(e),c},setResponseType:function(e){return this.responseType=e,this},setMimeType:function(e){return this.mimeType=e,this}}),ov.prototype=Object.assign(Object.create(Et.prototype),{constructor:ov,load:function(e,t,n,i){const r=this,o=new Oi(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(s){try{t(r.parse(JSON.parse(s)))}catch(a){i?i(a):console.error(a),r.manager.itemError(e)}},n,i)},parse:function(e){const t=[];for(let n=0;n<e.length;n++){const i=Mi.parse(e[n]);t.push(i)}return t}}),sv.prototype=Object.assign(Object.create(Et.prototype),{constructor:sv,load:function(e,t,n,i){const r=this,o=[],s=new nc,a=new Oi(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(r.withCredentials);let c=0;function l(d){a.load(e[d],function(u){const f=r.parse(u,!0);o[d]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},c+=1,6===c&&(1===f.mipmapCount&&(s.minFilter=En),s.image=o,s.format=f.format,s.needsUpdate=!0,t&&t(s))},n,i)}if(Array.isArray(e))for(let d=0,u=e.length;d<u;++d)l(d);else a.load(e,function(d){const u=r.parse(d,!0);if(u.isCubemap){const f=u.mipmaps.length/u.mipmapCount;for(let h=0;h<f;h++){o[h]={mipmaps:[]};for(let p=0;p<u.mipmapCount;p++)o[h].mipmaps.push(u.mipmaps[h*u.mipmapCount+p]),o[h].format=u.format,o[h].width=u.width,o[h].height=u.height}s.image=o}else s.image.width=u.width,s.image.height=u.height,s.mipmaps=u.mipmaps;1===u.mipmapCount&&(s.minFilter=En),s.format=u.format,s.needsUpdate=!0,t&&t(s)},n,i);return s}}),ac.prototype=Object.assign(Object.create(Et.prototype),{constructor:ac,load:function(e,t,n,i){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=Ss.get(e);if(void 0!==o)return r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o;const s=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){s.removeEventListener("load",a,!1),s.removeEventListener("error",c,!1),Ss.add(e,this),t&&t(this),r.manager.itemEnd(e)}function c(l){s.removeEventListener("load",a,!1),s.removeEventListener("error",c,!1),i&&i(l),r.manager.itemError(e),r.manager.itemEnd(e)}return s.addEventListener("load",a,!1),s.addEventListener("error",c,!1),"data:"!==e.substr(0,5)&&void 0!==this.crossOrigin&&(s.crossOrigin=this.crossOrigin),r.manager.itemStart(e),s.src=e,s}}),Yf.prototype=Object.assign(Object.create(Et.prototype),{constructor:Yf,load:function(e,t,n,i){const r=new Er,o=new ac(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let s=0;function a(c){o.load(e[c],function(l){r.images[c]=l,s++,6===s&&(r.needsUpdate=!0,t&&t(r))},void 0,i)}for(let c=0;c<e.length;++c)a(c);return r}}),Zf.prototype=Object.assign(Object.create(Et.prototype),{constructor:Zf,load:function(e,t,n,i){const r=this,o=new no,s=new Oi(this.manager);return s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(r.withCredentials),s.load(e,function(a){const c=r.parse(a);!c||(void 0!==c.image?o.image=c.image:void 0!==c.data&&(o.image.width=c.width,o.image.height=c.height,o.image.data=c.data),o.wrapS=void 0!==c.wrapS?c.wrapS:Xn,o.wrapT=void 0!==c.wrapT?c.wrapT:Xn,o.magFilter=void 0!==c.magFilter?c.magFilter:En,o.minFilter=void 0!==c.minFilter?c.minFilter:En,o.anisotropy=void 0!==c.anisotropy?c.anisotropy:1,void 0!==c.format&&(o.format=c.format),void 0!==c.type&&(o.type=c.type),void 0!==c.mipmaps&&(o.mipmaps=c.mipmaps,o.minFilter=Da),1===c.mipmapCount&&(o.minFilter=En),o.needsUpdate=!0,t&&t(o,c))},n,i),o}}),Jf.prototype=Object.assign(Object.create(Et.prototype),{constructor:Jf,load:function(e,t,n,i){const r=new At,o=new ac(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(s){r.image=s;const a=e.search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/);r.format=a?wo:gi,r.needsUpdate=!0,void 0!==t&&t(r)},n,i),r}}),Object.assign(xe.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)},getPoints:function(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t},getSpacedPoints:function(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t},getLength:function(){const e=this.getLengths();return e[e.length-1]},getLengths:function(e){if(void 0===e&&(e=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),r=0;t.push(0);for(let o=1;o<=e;o++)n=this.getPoint(o/e),r+=n.distanceTo(i),t.push(r),i=n;return this.cacheArcLengths=t,t},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(e,t){const n=this.getLengths();let i=0;const r=n.length;let o;o=t||e*n[r-1];let c,s=0,a=r-1;for(;s<=a;)if(i=Math.floor(s+(a-s)/2),c=n[i]-o,c<0)s=i+1;else{if(!(c>0)){a=i;break}a=i-1}if(i=a,n[i]===o)return i/(r-1);const l=n[i];return(i+(o-l)/(n[i+1]-l))/(r-1)},getTangent:function(e,t){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);const o=this.getPoint(i),s=this.getPoint(r),a=t||(o.isVector2?new V:new M);return a.copy(s).sub(o).normalize(),a},getTangentAt:function(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)},computeFrenetFrames:function(e,t){const n=new M,i=[],r=[],o=[],s=new M,a=new Ze;for(let f=0;f<=e;f++)i[f]=this.getTangentAt(f/e,new M),i[f].normalize();r[0]=new M,o[0]=new M;let c=Number.MAX_VALUE;const l=Math.abs(i[0].x),d=Math.abs(i[0].y),u=Math.abs(i[0].z);l<=c&&(c=l,n.set(1,0,0)),d<=c&&(c=d,n.set(0,1,0)),u<=c&&n.set(0,0,1),s.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],s),o[0].crossVectors(i[0],r[0]);for(let f=1;f<=e;f++){if(r[f]=r[f-1].clone(),o[f]=o[f-1].clone(),s.crossVectors(i[f-1],i[f]),s.length()>Number.EPSILON){s.normalize();const h=Math.acos(ke.clamp(i[f-1].dot(i[f]),-1,1));r[f].applyMatrix4(a.makeRotationAxis(s,h))}o[f].crossVectors(i[f],r[f])}if(!0===t){let f=Math.acos(ke.clamp(r[0].dot(r[e]),-1,1));f/=e,i[0].dot(s.crossVectors(r[0],r[e]))>0&&(f=-f);for(let h=1;h<=e;h++)r[h].applyMatrix4(a.makeRotationAxis(i[h],f*h)),o[h].crossVectors(i[h],r[h])}return{tangents:i,normals:r,binormals:o}},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this},toJSON:function(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e},fromJSON:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}),(Ei.prototype=Object.create(xe.prototype)).constructor=Ei,Ei.prototype.isEllipseCurve=!0,Ei.prototype.getPoint=function(e,t){const n=t||new V,i=2*Math.PI;let r=this.aEndAngle-this.aStartAngle;const o=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(r=o?0:i),!0===this.aClockwise&&!o&&(r===i?r=-i:r-=i);const s=this.aStartAngle+e*r;let a=this.aX+this.xRadius*Math.cos(s),c=this.aY+this.yRadius*Math.sin(s);if(0!==this.aRotation){const l=Math.cos(this.aRotation),d=Math.sin(this.aRotation),u=a-this.aX,f=c-this.aY;a=u*l-f*d+this.aX,c=u*d+f*l+this.aY}return n.set(a,c)},Ei.prototype.copy=function(e){return xe.prototype.copy.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},Ei.prototype.toJSON=function(){const e=xe.prototype.toJSON.call(this);return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e},Ei.prototype.fromJSON=function(e){return xe.prototype.fromJSON.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},(cc.prototype=Object.create(Ei.prototype)).constructor=cc,cc.prototype.isArcCurve=!0;const Qf=new M,cv=new av,lv=new av,uv=new av;function kn(e=[],t=!1,n="centripetal",i=.5){xe.call(this),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}function FD(e,t,n,i,r){const o=.5*(i-t),s=.5*(r-n),a=e*e;return(2*n-2*i+o+s)*(e*a)+(-3*n+3*i-2*o-s)*a+o*e+n}function lu(e,t,n,i){return function EG(e,t){const n=1-e;return n*n*t}(e,t)+function SG(e,t){return 2*(1-e)*e*t}(e,n)+function TG(e,t){return e*e*t}(e,i)}function uu(e,t,n,i,r){return function DG(e,t){const n=1-e;return n*n*n*t}(e,t)+function CG(e,t){const n=1-e;return 3*n*n*e*t}(e,n)+function AG(e,t){return 3*(1-e)*e*e*t}(e,i)+function IG(e,t){return e*e*e*t}(e,r)}function nr(e=new V,t=new V,n=new V,i=new V){xe.call(this),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}function Dr(e=new M,t=new M,n=new M,i=new M){xe.call(this),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}function ri(e=new V,t=new V){xe.call(this),this.type="LineCurve",this.v1=e,this.v2=t}function ir(e=new M,t=new M){xe.call(this),this.type="LineCurve3",this.v1=e,this.v2=t}function rr(e=new V,t=new V,n=new V){xe.call(this),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}function Cr(e=new M,t=new M,n=new M){xe.call(this),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}function or(e=[]){xe.call(this),this.type="SplineCurve",this.points=e}(kn.prototype=Object.create(xe.prototype)).constructor=kn,kn.prototype.isCatmullRomCurve3=!0,kn.prototype.getPoint=function(e,t=new M){const n=t,i=this.points,r=i.length,o=(r-(this.closed?0:1))*e;let c,l,s=Math.floor(o),a=o-s;this.closed?s+=s>0?0:(Math.floor(Math.abs(s)/r)+1)*r:0===a&&s===r-1&&(s=r-2,a=1),this.closed||s>0?c=i[(s-1)%r]:(Qf.subVectors(i[0],i[1]).add(i[0]),c=Qf);const d=i[s%r],u=i[(s+1)%r];if(this.closed||s+2<r?l=i[(s+2)%r]:(Qf.subVectors(i[r-1],i[r-2]).add(i[r-1]),l=Qf),"centripetal"===this.curveType||"chordal"===this.curveType){const f="chordal"===this.curveType?.5:.25;let h=Math.pow(c.distanceToSquared(d),f),p=Math.pow(d.distanceToSquared(u),f),y=Math.pow(u.distanceToSquared(l),f);p<1e-4&&(p=1),h<1e-4&&(h=p),y<1e-4&&(y=p),cv.initNonuniformCatmullRom(c.x,d.x,u.x,l.x,h,p,y),lv.initNonuniformCatmullRom(c.y,d.y,u.y,l.y,h,p,y),uv.initNonuniformCatmullRom(c.z,d.z,u.z,l.z,h,p,y)}else"catmullrom"===this.curveType&&(cv.initCatmullRom(c.x,d.x,u.x,l.x,this.tension),lv.initCatmullRom(c.y,d.y,u.y,l.y,this.tension),uv.initCatmullRom(c.z,d.z,u.z,l.z,this.tension));return n.set(cv.calc(a),lv.calc(a),uv.calc(a)),n},kn.prototype.copy=function(e){xe.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++)this.points.push(e.points[t].clone());return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},kn.prototype.toJSON=function(){const e=xe.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++)e.points.push(this.points[t].toArray());return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e},kn.prototype.fromJSON=function(e){xe.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push((new M).fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},(nr.prototype=Object.create(xe.prototype)).constructor=nr,nr.prototype.isCubicBezierCurve=!0,nr.prototype.getPoint=function(e,t=new V){const n=t,i=this.v0,r=this.v1,o=this.v2,s=this.v3;return n.set(uu(e,i.x,r.x,o.x,s.x),uu(e,i.y,r.y,o.y,s.y)),n},nr.prototype.copy=function(e){return xe.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},nr.prototype.toJSON=function(){const e=xe.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},nr.prototype.fromJSON=function(e){return xe.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},(Dr.prototype=Object.create(xe.prototype)).constructor=Dr,Dr.prototype.isCubicBezierCurve3=!0,Dr.prototype.getPoint=function(e,t=new M){const n=t,i=this.v0,r=this.v1,o=this.v2,s=this.v3;return n.set(uu(e,i.x,r.x,o.x,s.x),uu(e,i.y,r.y,o.y,s.y),uu(e,i.z,r.z,o.z,s.z)),n},Dr.prototype.copy=function(e){return xe.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},Dr.prototype.toJSON=function(){const e=xe.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},Dr.prototype.fromJSON=function(e){return xe.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},(ri.prototype=Object.create(xe.prototype)).constructor=ri,ri.prototype.isLineCurve=!0,ri.prototype.getPoint=function(e,t=new V){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n},ri.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},ri.prototype.getTangent=function(e,t){const n=t||new V;return n.copy(this.v2).sub(this.v1).normalize(),n},ri.prototype.copy=function(e){return xe.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},ri.prototype.toJSON=function(){const e=xe.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},ri.prototype.fromJSON=function(e){return xe.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},(ir.prototype=Object.create(xe.prototype)).constructor=ir,ir.prototype.isLineCurve3=!0,ir.prototype.getPoint=function(e,t=new M){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n},ir.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},ir.prototype.copy=function(e){return xe.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},ir.prototype.toJSON=function(){const e=xe.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},ir.prototype.fromJSON=function(e){return xe.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},(rr.prototype=Object.create(xe.prototype)).constructor=rr,rr.prototype.isQuadraticBezierCurve=!0,rr.prototype.getPoint=function(e,t=new V){const n=t,i=this.v0,r=this.v1,o=this.v2;return n.set(lu(e,i.x,r.x,o.x),lu(e,i.y,r.y,o.y)),n},rr.prototype.copy=function(e){return xe.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},rr.prototype.toJSON=function(){const e=xe.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},rr.prototype.fromJSON=function(e){return xe.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},(Cr.prototype=Object.create(xe.prototype)).constructor=Cr,Cr.prototype.isQuadraticBezierCurve3=!0,Cr.prototype.getPoint=function(e,t=new M){const n=t,i=this.v0,r=this.v1,o=this.v2;return n.set(lu(e,i.x,r.x,o.x),lu(e,i.y,r.y,o.y),lu(e,i.z,r.z,o.z)),n},Cr.prototype.copy=function(e){return xe.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},Cr.prototype.toJSON=function(){const e=xe.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},Cr.prototype.fromJSON=function(e){return xe.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},(or.prototype=Object.create(xe.prototype)).constructor=or,or.prototype.isSplineCurve=!0,or.prototype.getPoint=function(e,t=new V){const n=t,i=this.points,r=(i.length-1)*e,o=Math.floor(r),s=r-o,a=i[0===o?o:o-1],c=i[o],l=i[o>i.length-2?i.length-1:o+1],d=i[o>i.length-3?i.length-1:o+2];return n.set(FD(s,a.x,c.x,l.x,d.x),FD(s,a.y,c.y,l.y,d.y)),n},or.prototype.copy=function(e){xe.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++)this.points.push(e.points[t].clone());return this},or.prototype.toJSON=function(){const e=xe.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++)e.points.push(this.points[t].toArray());return e},or.prototype.fromJSON=function(e){xe.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push((new V).fromArray(i))}return this};var dv=Object.freeze({__proto__:null,ArcCurve:cc,CatmullRomCurve3:kn,CubicBezierCurve:nr,CubicBezierCurve3:Dr,EllipseCurve:Ei,LineCurve:ri,LineCurve3:ir,QuadraticBezierCurve:rr,QuadraticBezierCurve3:Cr,SplineCurve:or});function oo(){xe.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function sr(e){oo.call(this),this.type="Path",this.currentPoint=new V,e&&this.setFromPoints(e)}function ko(e){sr.call(this,e),this.uuid=ke.generateUUID(),this.type="Shape",this.holes=[]}function kt(e,t=1){ge.call(this),this.type="Light",this.color=new ae(e),this.intensity=t}function Kf(e,t,n){kt.call(this,e,n),this.type="HemisphereLight",this.position.copy(ge.DefaultUp),this.updateMatrix(),this.groundColor=new ae(t)}function so(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new V(512,512),this.map=null,this.mapPass=null,this.matrix=new Ze,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Hl,this._frameExtents=new V(1,1),this._viewportCount=1,this._viewports=[new It(0,0,1,1)]}function fv(){so.call(this,new pn(50,1,.5,500)),this.focus=1}function eh(e,t,n,i,r,o){kt.call(this,e,t),this.type="SpotLight",this.position.copy(ge.DefaultUp),this.updateMatrix(),this.target=new ge,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(s){this.intensity=s/Math.PI}}),this.distance=void 0!==n?n:0,this.angle=void 0!==i?i:Math.PI/3,this.penumbra=void 0!==r?r:0,this.decay=void 0!==o?o:1,this.shadow=new fv}function hv(){so.call(this,new pn(90,1,.5,500)),this._frameExtents=new V(4,2),this._viewportCount=6,this._viewports=[new It(2,1,1,1),new It(0,1,1,1),new It(3,1,1,1),new It(1,1,1,1),new It(3,0,1,1),new It(1,0,1,1)],this._cubeDirections=[new M(1,0,0),new M(-1,0,0),new M(0,0,1),new M(0,0,-1),new M(0,1,0),new M(0,-1,0)],this._cubeUps=[new M(0,1,0),new M(0,1,0),new M(0,1,0),new M(0,1,0),new M(0,0,1),new M(0,0,-1)]}function th(e,t,n,i){kt.call(this,e,t),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(r){this.intensity=r/(4*Math.PI)}}),this.distance=void 0!==n?n:0,this.decay=void 0!==i?i:1,this.shadow=new hv}function lc(e=-1,t=1,n=1,i=-1,r=.1,o=2e3){Mr.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=r,this.far=o,this.updateProjectionMatrix()}function pv(){so.call(this,new lc(-5,5,5,-5,.5,500))}function nh(e,t){kt.call(this,e,t),this.type="DirectionalLight",this.position.copy(ge.DefaultUp),this.updateMatrix(),this.target=new ge,this.shadow=new pv}function ih(e,t){kt.call(this,e,t),this.type="AmbientLight"}function rh(e,t,n,i){kt.call(this,e,t),this.type="RectAreaLight",this.width=void 0!==n?n:10,this.height=void 0!==i?i:10}oo.prototype=Object.assign(Object.create(xe.prototype),{constructor:oo,add:function(e){this.curves.push(e)},closePath:function(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new ri(t,e))},getPoint:function(e){const t=e*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=t){const r=n[i]-t,o=this.curves[i],s=o.getLength();return o.getPointAt(0===s?0:1-r/s)}i++}return null},getLength:function(){const e=this.getCurveLengths();return e[e.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e},getSpacedPoints:function(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t},getPoints:function(e=12){const t=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const o=r[i],a=o.getPoints(o&&o.isEllipseCurve?2*e:o&&(o.isLineCurve||o.isLineCurve3)?1:o&&o.isSplineCurve?e*o.points.length:e);for(let c=0;c<a.length;c++){const l=a[c];n&&n.equals(l)||(t.push(l),n=l)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t},copy:function(e){xe.prototype.copy.call(this,e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++)this.curves.push(e.curves[t].clone());return this.autoClose=e.autoClose,this},toJSON:function(){const e=xe.prototype.toJSON.call(this);e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++)e.curves.push(this.curves[t].toJSON());return e},fromJSON:function(e){xe.prototype.fromJSON.call(this,e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push((new dv[i.type]).fromJSON(i))}return this}}),sr.prototype=Object.assign(Object.create(oo.prototype),{constructor:sr,setFromPoints:function(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this},moveTo:function(e,t){return this.currentPoint.set(e,t),this},lineTo:function(e,t){const n=new ri(this.currentPoint.clone(),new V(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this},quadraticCurveTo:function(e,t,n,i){const r=new rr(this.currentPoint.clone(),new V(e,t),new V(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this},bezierCurveTo:function(e,t,n,i,r,o){const s=new nr(this.currentPoint.clone(),new V(e,t),new V(n,i),new V(r,o));return this.curves.push(s),this.currentPoint.set(r,o),this},splineThru:function(e){const n=new or([this.currentPoint.clone()].concat(e));return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this},arc:function(e,t,n,i,r,o){return this.absarc(e+this.currentPoint.x,t+this.currentPoint.y,n,i,r,o),this},absarc:function(e,t,n,i,r,o){return this.absellipse(e,t,n,n,i,r,o),this},ellipse:function(e,t,n,i,r,o,s,a){return this.absellipse(e+this.currentPoint.x,t+this.currentPoint.y,n,i,r,o,s,a),this},absellipse:function(e,t,n,i,r,o,s,a){const c=new Ei(e,t,n,i,r,o,s,a);if(this.curves.length>0){const d=c.getPoint(0);d.equals(this.currentPoint)||this.lineTo(d.x,d.y)}this.curves.push(c);const l=c.getPoint(1);return this.currentPoint.copy(l),this},copy:function(e){return oo.prototype.copy.call(this,e),this.currentPoint.copy(e.currentPoint),this},toJSON:function(){const e=oo.prototype.toJSON.call(this);return e.currentPoint=this.currentPoint.toArray(),e},fromJSON:function(e){return oo.prototype.fromJSON.call(this,e),this.currentPoint.fromArray(e.currentPoint),this}}),ko.prototype=Object.assign(Object.create(sr.prototype),{constructor:ko,getPointsHoles:function(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t},extractPoints:function(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}},copy:function(e){sr.prototype.copy.call(this,e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++)this.holes.push(e.holes[t].clone());return this},toJSON:function(){const e=sr.prototype.toJSON.call(this);e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++)e.holes.push(this.holes[t].toJSON());return e},fromJSON:function(e){sr.prototype.fromJSON.call(this,e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push((new sr).fromJSON(i))}return this}}),kt.prototype=Object.assign(Object.create(ge.prototype),{constructor:kt,isLight:!0,copy:function(e){return ge.prototype.copy.call(this,e),this.color.copy(e.color),this.intensity=e.intensity,this},toJSON:function(e){const t=ge.prototype.toJSON.call(this,e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}),Kf.prototype=Object.assign(Object.create(kt.prototype),{constructor:Kf,isHemisphereLight:!0,copy:function(e){return kt.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}),Object.assign(so.prototype,{_projScreenMatrix:new Ze,_lightPositionWorld:new M,_lookTarget:new M,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(e){const t=this.camera,n=this.matrix,i=this._projScreenMatrix,r=this._lookTarget,o=this._lightPositionWorld;o.setFromMatrixPosition(e.matrixWorld),t.position.copy(o),r.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(r),t.updateMatrixWorld(),i.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(i),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)},getViewport:function(e){return this._viewports[e]},getFrameExtents:function(){return this._frameExtents},copy:function(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),(512!==this.mapSize.x||512!==this.mapSize.y)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}),fv.prototype=Object.assign(Object.create(so.prototype),{constructor:fv,isSpotLightShadow:!0,updateMatrices:function(e){const t=this.camera,n=2*ke.RAD2DEG*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(n!==t.fov||i!==t.aspect||r!==t.far)&&(t.fov=n,t.aspect=i,t.far=r,t.updateProjectionMatrix()),so.prototype.updateMatrices.call(this,e)}}),eh.prototype=Object.assign(Object.create(kt.prototype),{constructor:eh,isSpotLight:!0,copy:function(e){return kt.prototype.copy.call(this,e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),hv.prototype=Object.assign(Object.create(so.prototype),{constructor:hv,isPointLightShadow:!0,updateMatrices:function(e,t=0){const n=this.camera,i=this.matrix,r=this._lightPositionWorld,o=this._lookTarget,s=this._projScreenMatrix;r.setFromMatrixPosition(e.matrixWorld),n.position.copy(r),o.copy(n.position),o.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(o),n.updateMatrixWorld(),i.makeTranslation(-r.x,-r.y,-r.z),s.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(s)}}),th.prototype=Object.assign(Object.create(kt.prototype),{constructor:th,isPointLight:!0,copy:function(e){return kt.prototype.copy.call(this,e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}),lc.prototype=Object.assign(Object.create(Mr.prototype),{constructor:lc,isOrthographicCamera:!0,copy:function(e,t){return Mr.prototype.copy.call(this,e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this},setViewOffset:function(e,t,n,i,r,o){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-e,o=n+e,s=i+t,a=i-t;if(null!==this.view&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,l=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,o=r+c*this.view.width,s-=l*this.view.offsetY,a=s-l*this.view.height}this.projectionMatrix.makeOrthographic(r,o,s,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(e){const t=ge.prototype.toJSON.call(this,e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}),pv.prototype=Object.assign(Object.create(so.prototype),{constructor:pv,isDirectionalLightShadow:!0,updateMatrices:function(e){so.prototype.updateMatrices.call(this,e)}}),nh.prototype=Object.assign(Object.create(kt.prototype),{constructor:nh,isDirectionalLight:!0,copy:function(e){return kt.prototype.copy.call(this,e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),ih.prototype=Object.assign(Object.create(kt.prototype),{constructor:ih,isAmbientLight:!0}),rh.prototype=Object.assign(Object.create(kt.prototype),{constructor:rh,isRectAreaLight:!0,copy:function(e){return kt.prototype.copy.call(this,e),this.width=e.width,this.height=e.height,this},toJSON:function(e){const t=kt.prototype.toJSON.call(this,e);return t.object.width=this.width,t.object.height=this.height,t}});class ND{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new M)}set(t){for(let n=0;n<9;n++)this.coefficients[n].copy(t[n]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,n){const i=t.x,r=t.y,o=t.z,s=this.coefficients;return n.copy(s[0]).multiplyScalar(.282095),n.addScaledVector(s[1],.488603*r),n.addScaledVector(s[2],.488603*o),n.addScaledVector(s[3],.488603*i),n.addScaledVector(s[4],i*r*1.092548),n.addScaledVector(s[5],r*o*1.092548),n.addScaledVector(s[6],.315392*(3*o*o-1)),n.addScaledVector(s[7],i*o*1.092548),n.addScaledVector(s[8],.546274*(i*i-r*r)),n}getIrradianceAt(t,n){const i=t.x,r=t.y,o=t.z,s=this.coefficients;return n.copy(s[0]).multiplyScalar(.886227),n.addScaledVector(s[1],1.023328*r),n.addScaledVector(s[2],1.023328*o),n.addScaledVector(s[3],1.023328*i),n.addScaledVector(s[4],.858086*i*r),n.addScaledVector(s[5],.858086*r*o),n.addScaledVector(s[6],.743125*o*o-.247708),n.addScaledVector(s[7],.858086*i*o),n.addScaledVector(s[8],.429043*(i*i-r*r)),n}add(t){for(let n=0;n<9;n++)this.coefficients[n].add(t.coefficients[n]);return this}addScaledSH(t,n){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(t.coefficients[i],n);return this}scale(t){for(let n=0;n<9;n++)this.coefficients[n].multiplyScalar(t);return this}lerp(t,n){for(let i=0;i<9;i++)this.coefficients[i].lerp(t.coefficients[i],n);return this}equals(t){for(let n=0;n<9;n++)if(!this.coefficients[n].equals(t.coefficients[n]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,n=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].fromArray(t,n+3*r);return this}toArray(t=[],n=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].toArray(t,n+3*r);return t}static getBasisAt(t,n){const i=t.x,r=t.y,o=t.z;n[0]=.282095,n[1]=.488603*r,n[2]=.488603*o,n[3]=.488603*i,n[4]=1.092548*i*r,n[5]=1.092548*r*o,n[6]=.315392*(3*o*o-1),n[7]=1.092548*i*o,n[8]=.546274*(i*i-r*r)}}function Bi(e,t){kt.call(this,void 0,t),this.type="LightProbe",this.sh=void 0!==e?e:new ND}function oh(e){Et.call(this,e),this.textures={}}Bi.prototype=Object.assign(Object.create(kt.prototype),{constructor:Bi,isLightProbe:!0,copy:function(e){return kt.prototype.copy.call(this,e),this.sh.copy(e.sh),this},fromJSON:function(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this},toJSON:function(e){const t=kt.prototype.toJSON.call(this,e);return t.object.sh=this.sh.toArray(),t}}),oh.prototype=Object.assign(Object.create(Et.prototype),{constructor:oh,load:function(e,t,n,i){const r=this,o=new Oi(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(s){try{t(r.parse(JSON.parse(s)))}catch(a){i?i(a):console.error(a),r.manager.itemError(e)}},n,i)},parse:function(e){const t=this.textures;function n(r){return void 0===t[r]&&console.warn("THREE.MaterialLoader: Undefined texture",r),t[r]}const i=new wG[e.type];if(void 0!==e.uuid&&(i.uuid=e.uuid),void 0!==e.name&&(i.name=e.name),void 0!==e.color&&void 0!==i.color&&i.color.setHex(e.color),void 0!==e.roughness&&(i.roughness=e.roughness),void 0!==e.metalness&&(i.metalness=e.metalness),void 0!==e.sheen&&(i.sheen=(new ae).setHex(e.sheen)),void 0!==e.emissive&&void 0!==i.emissive&&i.emissive.setHex(e.emissive),void 0!==e.specular&&void 0!==i.specular&&i.specular.setHex(e.specular),void 0!==e.shininess&&(i.shininess=e.shininess),void 0!==e.clearcoat&&(i.clearcoat=e.clearcoat),void 0!==e.clearcoatRoughness&&(i.clearcoatRoughness=e.clearcoatRoughness),void 0!==e.fog&&(i.fog=e.fog),void 0!==e.flatShading&&(i.flatShading=e.flatShading),void 0!==e.blending&&(i.blending=e.blending),void 0!==e.combine&&(i.combine=e.combine),void 0!==e.side&&(i.side=e.side),void 0!==e.opacity&&(i.opacity=e.opacity),void 0!==e.transparent&&(i.transparent=e.transparent),void 0!==e.alphaTest&&(i.alphaTest=e.alphaTest),void 0!==e.depthTest&&(i.depthTest=e.depthTest),void 0!==e.depthWrite&&(i.depthWrite=e.depthWrite),void 0!==e.colorWrite&&(i.colorWrite=e.colorWrite),void 0!==e.stencilWrite&&(i.stencilWrite=e.stencilWrite),void 0!==e.stencilWriteMask&&(i.stencilWriteMask=e.stencilWriteMask),void 0!==e.stencilFunc&&(i.stencilFunc=e.stencilFunc),void 0!==e.stencilRef&&(i.stencilRef=e.stencilRef),void 0!==e.stencilFuncMask&&(i.stencilFuncMask=e.stencilFuncMask),void 0!==e.stencilFail&&(i.stencilFail=e.stencilFail),void 0!==e.stencilZFail&&(i.stencilZFail=e.stencilZFail),void 0!==e.stencilZPass&&(i.stencilZPass=e.stencilZPass),void 0!==e.wireframe&&(i.wireframe=e.wireframe),void 0!==e.wireframeLinewidth&&(i.wireframeLinewidth=e.wireframeLinewidth),void 0!==e.wireframeLinecap&&(i.wireframeLinecap=e.wireframeLinecap),void 0!==e.wireframeLinejoin&&(i.wireframeLinejoin=e.wireframeLinejoin),void 0!==e.rotation&&(i.rotation=e.rotation),1!==e.linewidth&&(i.linewidth=e.linewidth),void 0!==e.dashSize&&(i.dashSize=e.dashSize),void 0!==e.gapSize&&(i.gapSize=e.gapSize),void 0!==e.scale&&(i.scale=e.scale),void 0!==e.polygonOffset&&(i.polygonOffset=e.polygonOffset),void 0!==e.polygonOffsetFactor&&(i.polygonOffsetFactor=e.polygonOffsetFactor),void 0!==e.polygonOffsetUnits&&(i.polygonOffsetUnits=e.polygonOffsetUnits),void 0!==e.skinning&&(i.skinning=e.skinning),void 0!==e.morphTargets&&(i.morphTargets=e.morphTargets),void 0!==e.morphNormals&&(i.morphNormals=e.morphNormals),void 0!==e.dithering&&(i.dithering=e.dithering),void 0!==e.vertexTangents&&(i.vertexTangents=e.vertexTangents),void 0!==e.visible&&(i.visible=e.visible),void 0!==e.toneMapped&&(i.toneMapped=e.toneMapped),void 0!==e.userData&&(i.userData=e.userData),void 0!==e.vertexColors&&(i.vertexColors="number"==typeof e.vertexColors?e.vertexColors>0:e.vertexColors),void 0!==e.uniforms)for(const r in e.uniforms){const o=e.uniforms[r];switch(i.uniforms[r]={},o.type){case"t":i.uniforms[r].value=n(o.value);break;case"c":i.uniforms[r].value=(new ae).setHex(o.value);break;case"v2":i.uniforms[r].value=(new V).fromArray(o.value);break;case"v3":i.uniforms[r].value=(new M).fromArray(o.value);break;case"v4":i.uniforms[r].value=(new It).fromArray(o.value);break;case"m3":i.uniforms[r].value=(new Zn).fromArray(o.value);break;case"m4":i.uniforms[r].value=(new Ze).fromArray(o.value);break;default:i.uniforms[r].value=o.value}}if(void 0!==e.defines&&(i.defines=e.defines),void 0!==e.vertexShader&&(i.vertexShader=e.vertexShader),void 0!==e.fragmentShader&&(i.fragmentShader=e.fragmentShader),void 0!==e.extensions)for(const r in e.extensions)i.extensions[r]=e.extensions[r];if(void 0!==e.shading&&(i.flatShading=1===e.shading),void 0!==e.size&&(i.size=e.size),void 0!==e.sizeAttenuation&&(i.sizeAttenuation=e.sizeAttenuation),void 0!==e.map&&(i.map=n(e.map)),void 0!==e.matcap&&(i.matcap=n(e.matcap)),void 0!==e.alphaMap&&(i.alphaMap=n(e.alphaMap)),void 0!==e.bumpMap&&(i.bumpMap=n(e.bumpMap)),void 0!==e.bumpScale&&(i.bumpScale=e.bumpScale),void 0!==e.normalMap&&(i.normalMap=n(e.normalMap)),void 0!==e.normalMapType&&(i.normalMapType=e.normalMapType),void 0!==e.normalScale){let r=e.normalScale;!1===Array.isArray(r)&&(r=[r,r]),i.normalScale=(new V).fromArray(r)}return void 0!==e.displacementMap&&(i.displacementMap=n(e.displacementMap)),void 0!==e.displacementScale&&(i.displacementScale=e.displacementScale),void 0!==e.displacementBias&&(i.displacementBias=e.displacementBias),void 0!==e.roughnessMap&&(i.roughnessMap=n(e.roughnessMap)),void 0!==e.metalnessMap&&(i.metalnessMap=n(e.metalnessMap)),void 0!==e.emissiveMap&&(i.emissiveMap=n(e.emissiveMap)),void 0!==e.emissiveIntensity&&(i.emissiveIntensity=e.emissiveIntensity),void 0!==e.specularMap&&(i.specularMap=n(e.specularMap)),void 0!==e.envMap&&(i.envMap=n(e.envMap)),void 0!==e.envMapIntensity&&(i.envMapIntensity=e.envMapIntensity),void 0!==e.reflectivity&&(i.reflectivity=e.reflectivity),void 0!==e.refractionRatio&&(i.refractionRatio=e.refractionRatio),void 0!==e.lightMap&&(i.lightMap=n(e.lightMap)),void 0!==e.lightMapIntensity&&(i.lightMapIntensity=e.lightMapIntensity),void 0!==e.aoMap&&(i.aoMap=n(e.aoMap)),void 0!==e.aoMapIntensity&&(i.aoMapIntensity=e.aoMapIntensity),void 0!==e.gradientMap&&(i.gradientMap=n(e.gradientMap)),void 0!==e.clearcoatMap&&(i.clearcoatMap=n(e.clearcoatMap)),void 0!==e.clearcoatRoughnessMap&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),void 0!==e.clearcoatNormalMap&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),void 0!==e.clearcoatNormalScale&&(i.clearcoatNormalScale=(new V).fromArray(e.clearcoatNormalScale)),void 0!==e.transmission&&(i.transmission=e.transmission),void 0!==e.transmissionMap&&(i.transmissionMap=n(e.transmissionMap)),i},setTextures:function(e){return this.textures=e,this}});const mv={decodeText:function(e){if(typeof TextDecoder<"u")return(new TextDecoder).decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}},extractUrlBase:function(e){const t=e.lastIndexOf("/");return-1===t?"./":e.substr(0,t+1)}};function du(){Me.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function sh(e,t,n,i){"number"==typeof n&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Ee.call(this,e,t,n),this.meshPerAttribute=i||1}function ah(e){Et.call(this,e)}du.prototype=Object.assign(Object.create(Me.prototype),{constructor:du,isInstancedBufferGeometry:!0,copy:function(e){return Me.prototype.copy.call(this,e),this.instanceCount=e.instanceCount,this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const e=Me.prototype.toJSON.call(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}),sh.prototype=Object.assign(Object.create(Ee.prototype),{constructor:sh,isInstancedBufferAttribute:!0,copy:function(e){return Ee.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},toJSON:function(){const e=Ee.prototype.toJSON.call(this);return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}),ah.prototype=Object.assign(Object.create(Et.prototype),{constructor:ah,load:function(e,t,n,i){const r=this,o=new Oi(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(s){try{t(r.parse(JSON.parse(s)))}catch(a){i?i(a):console.error(a),r.manager.itemError(e)}},n,i)},parse:function(e){const t={},n={};function i(f,h){if(void 0!==t[h])return t[h];const y=f.interleavedBuffers[h],v=function r(f,h){if(void 0!==n[h])return n[h];const v=new Uint32Array(f.arrayBuffers[h]).buffer;return n[h]=v,v}(f,y.buffer),m=new wi(Nl(y.type,v),y.stride);return m.uuid=y.uuid,t[h]=m,m}const o=e.isInstancedBufferGeometry?new du:new Me,s=e.data.index;if(void 0!==s){const f=Nl(s.type,s.array);o.setIndex(new Ee(f,1))}const a=e.data.attributes;for(const f in a){const h=a[f];let p;if(h.isInterleavedBufferAttribute)p=new Po(i(e.data,h.data),h.itemSize,h.offset,h.normalized);else{const y=Nl(h.type,h.array);p=new(h.isInstancedBufferAttribute?sh:Ee)(y,h.itemSize,h.normalized)}void 0!==h.name&&(p.name=h.name),o.setAttribute(f,p)}const c=e.data.morphAttributes;if(c)for(const f in c){const h=c[f],p=[];for(let y=0,v=h.length;y<v;y++){const g=h[y];let m;m=g.isInterleavedBufferAttribute?new Po(i(e.data,g.data),g.itemSize,g.offset,g.normalized):new Ee(Nl(g.type,g.array),g.itemSize,g.normalized),void 0!==g.name&&(m.name=g.name),p.push(m)}o.morphAttributes[f]=p}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const d=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==d)for(let f=0,h=d.length;f!==h;++f){const p=d[f];o.addGroup(p.start,p.count,p.materialIndex)}const u=e.data.boundingSphere;if(void 0!==u){const f=new M;void 0!==u.center&&f.fromArray(u.center),o.boundingSphere=new Zr(f,u.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}});class LG extends Et{constructor(t){super(t)}load(t,n,i,r){const o=this,s=""===this.path?mv.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||s;const a=new Oi(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(c){let l=null;try{l=JSON.parse(c)}catch(u){return void 0!==r&&r(u),void console.error("THREE:ObjectLoader: Can't parse "+t+".",u.message)}const d=l.metadata;void 0!==d&&void 0!==d.type&&"geometry"!==d.type.toLowerCase()?o.parse(l,n):console.error("THREE.ObjectLoader: Can't load "+t)},i,r)}parse(t,n){const i=this.parseAnimations(t.animations),r=this.parseShapes(t.shapes),o=this.parseGeometries(t.geometries,r),s=this.parseImages(t.images,function(){void 0!==n&&n(l)}),a=this.parseTextures(t.textures,s),c=this.parseMaterials(t.materials,a),l=this.parseObject(t.object,o,c,i),d=this.parseSkeletons(t.skeletons,l);if(this.bindSkeletons(l,d),void 0!==n){let u=!1;for(const f in s)if(s[f]instanceof HTMLImageElement){u=!0;break}!1===u&&n(l)}return l}parseShapes(t){const n={};if(void 0!==t)for(let i=0,r=t.length;i<r;i++){const o=(new ko).fromJSON(t[i]);n[o.uuid]=o}return n}parseSkeletons(t,n){const i={},r={};if(n.traverse(function(o){o.isBone&&(r[o.uuid]=o)}),void 0!==t)for(let o=0,s=t.length;o<s;o++){const a=(new Jl).fromJSON(t[o],r);i[a.uuid]=a}return i}parseGeometries(t,n){const i={};let r;if(void 0!==t){const o=new ah;for(let s=0,a=t.length;s<a;s++){let c;const l=t[s];switch(l.type){case"PlaneGeometry":case"PlaneBufferGeometry":c=new Kn[l.type](l.width,l.height,l.widthSegments,l.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":case"CubeGeometry":c=new Kn[l.type](l.width,l.height,l.depth,l.widthSegments,l.heightSegments,l.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":c=new Kn[l.type](l.radius,l.segments,l.thetaStart,l.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":c=new Kn[l.type](l.radiusTop,l.radiusBottom,l.height,l.radialSegments,l.heightSegments,l.openEnded,l.thetaStart,l.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":c=new Kn[l.type](l.radius,l.height,l.radialSegments,l.heightSegments,l.openEnded,l.thetaStart,l.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":c=new Kn[l.type](l.radius,l.widthSegments,l.heightSegments,l.phiStart,l.phiLength,l.thetaStart,l.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":c=new Kn[l.type](l.radius,l.detail);break;case"RingGeometry":case"RingBufferGeometry":c=new Kn[l.type](l.innerRadius,l.outerRadius,l.thetaSegments,l.phiSegments,l.thetaStart,l.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":c=new Kn[l.type](l.radius,l.tube,l.radialSegments,l.tubularSegments,l.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":c=new Kn[l.type](l.radius,l.tube,l.tubularSegments,l.radialSegments,l.p,l.q);break;case"TubeGeometry":case"TubeBufferGeometry":c=new Kn[l.type]((new dv[l.path.type]).fromJSON(l.path),l.tubularSegments,l.radius,l.radialSegments,l.closed);break;case"LatheGeometry":case"LatheBufferGeometry":c=new Kn[l.type](l.points,l.segments,l.phiStart,l.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":c=new Kn[l.type](l.vertices,l.indices,l.radius,l.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":r=[];for(let u=0,f=l.shapes.length;u<f;u++)r.push(n[l.shapes[u]]);c=new Kn[l.type](r,l.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":r=[];for(let u=0,f=l.shapes.length;u<f;u++)r.push(n[l.shapes[u]]);const d=l.options.extrudePath;void 0!==d&&(l.options.extrudePath=(new dv[d.type]).fromJSON(d)),c=new Kn[l.type](r,l.options);break;case"BufferGeometry":case"InstancedBufferGeometry":c=o.parse(l);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+l.type+'"');continue}c.uuid=l.uuid,void 0!==l.name&&(c.name=l.name),!0===c.isBufferGeometry&&void 0!==l.userData&&(c.userData=l.userData),i[l.uuid]=c}}return i}parseMaterials(t,n){const i={},r={};if(void 0!==t){const o=new oh;o.setTextures(n);for(let s=0,a=t.length;s<a;s++){const c=t[s];if("MultiMaterial"===c.type){const l=[];for(let d=0;d<c.materials.length;d++){const u=c.materials[d];void 0===i[u.uuid]&&(i[u.uuid]=o.parse(u)),l.push(i[u.uuid])}r[c.uuid]=l}else void 0===i[c.uuid]&&(i[c.uuid]=o.parse(c)),r[c.uuid]=i[c.uuid]}}return r}parseAnimations(t){const n={};if(void 0!==t)for(let i=0;i<t.length;i++){const o=Mi.parse(t[i]);n[o.uuid]=o}return n}parseImages(t,n){const i=this,r={};let o;function a(c){if("string"==typeof c){const l=c;return function s(c){return i.manager.itemStart(c),o.load(c,function(){i.manager.itemEnd(c)},void 0,function(){i.manager.itemError(c),i.manager.itemEnd(c)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(l)?l:i.resourcePath+l)}return c.data?{data:Nl(c.type,c.data),width:c.width,height:c.height}:null}if(void 0!==t&&t.length>0){const c=new rv(n);o=new ac(c),o.setCrossOrigin(this.crossOrigin);for(let l=0,d=t.length;l<d;l++){const u=t[l],f=u.url;if(Array.isArray(f)){r[u.uuid]=[];for(let h=0,p=f.length;h<p;h++){const v=a(f[h]);null!==v&&(v instanceof HTMLImageElement?r[u.uuid].push(v):r[u.uuid].push(new no(v.data,v.width,v.height)))}}else{const h=a(u.url);null!==h&&(r[u.uuid]=h)}}}return r}parseTextures(t,n){function i(o,s){return"number"==typeof o?o:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",o),s[o])}const r={};if(void 0!==t)for(let o=0,s=t.length;o<s;o++){const a=t[o];let c;void 0===a.image&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),void 0===n[a.image]&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const l=n[a.image];Array.isArray(l)?(c=new Er(l),6===l.length&&(c.needsUpdate=!0)):(c=l&&l.data?new no(l.data,l.width,l.height):new At(l),l&&(c.needsUpdate=!0)),c.uuid=a.uuid,void 0!==a.name&&(c.name=a.name),void 0!==a.mapping&&(c.mapping=i(a.mapping,RG)),void 0!==a.offset&&c.offset.fromArray(a.offset),void 0!==a.repeat&&c.repeat.fromArray(a.repeat),void 0!==a.center&&c.center.fromArray(a.center),void 0!==a.rotation&&(c.rotation=a.rotation),void 0!==a.wrap&&(c.wrapS=i(a.wrap[0],OD),c.wrapT=i(a.wrap[1],OD)),void 0!==a.format&&(c.format=a.format),void 0!==a.type&&(c.type=a.type),void 0!==a.encoding&&(c.encoding=a.encoding),void 0!==a.minFilter&&(c.minFilter=i(a.minFilter,BD)),void 0!==a.magFilter&&(c.magFilter=i(a.magFilter,BD)),void 0!==a.anisotropy&&(c.anisotropy=a.anisotropy),void 0!==a.flipY&&(c.flipY=a.flipY),void 0!==a.premultiplyAlpha&&(c.premultiplyAlpha=a.premultiplyAlpha),void 0!==a.unpackAlignment&&(c.unpackAlignment=a.unpackAlignment),r[a.uuid]=c}return r}parseObject(t,n,i,r){let o,c,l;function s(d){return void 0===n[d]&&console.warn("THREE.ObjectLoader: Undefined geometry",d),n[d]}function a(d){if(void 0!==d){if(Array.isArray(d)){const u=[];for(let f=0,h=d.length;f<h;f++){const p=d[f];void 0===i[p]&&console.warn("THREE.ObjectLoader: Undefined material",p),u.push(i[p])}return u}return void 0===i[d]&&console.warn("THREE.ObjectLoader: Undefined material",d),i[d]}}switch(t.type){case"Scene":o=new Ry,void 0!==t.background&&Number.isInteger(t.background)&&(o.background=new ae(t.background)),void 0!==t.fog&&("Fog"===t.fog.type?o.fog=new xf(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(o.fog=new _f(t.fog.color,t.fog.density)));break;case"PerspectiveCamera":o=new pn(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(o.focus=t.focus),void 0!==t.zoom&&(o.zoom=t.zoom),void 0!==t.filmGauge&&(o.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(o.filmOffset=t.filmOffset),void 0!==t.view&&(o.view=Object.assign({},t.view));break;case"OrthographicCamera":o=new lc(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(o.zoom=t.zoom),void 0!==t.view&&(o.view=Object.assign({},t.view));break;case"AmbientLight":o=new ih(t.color,t.intensity);break;case"DirectionalLight":o=new nh(t.color,t.intensity);break;case"PointLight":o=new th(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":o=new rh(t.color,t.intensity,t.width,t.height);break;case"SpotLight":o=new eh(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":o=new Kf(t.color,t.groundColor,t.intensity);break;case"LightProbe":o=(new Bi).fromJSON(t);break;case"SkinnedMesh":c=s(t.geometry),l=a(t.material),o=new Yl(c,l),void 0!==t.bindMode&&(o.bindMode=t.bindMode),void 0!==t.bindMatrix&&o.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(o.skeleton=t.skeleton);break;case"Mesh":c=s(t.geometry),l=a(t.material),o=new Gt(c,l);break;case"InstancedMesh":c=s(t.geometry),l=a(t.material);const u=t.instanceMatrix;o=new Tf(c,l,t.count),o.instanceMatrix=new Ee(new Float32Array(u.array),16);break;case"LOD":o=new Xl;break;case"Line":o=new Ni(s(t.geometry),a(t.material));break;case"LineLoop":o=new Lf(s(t.geometry),a(t.material));break;case"LineSegments":o=new Qn(s(t.geometry),a(t.material));break;case"PointCloud":case"Points":o=new tc(s(t.geometry),a(t.material));break;case"Sprite":o=new $l(a(t.material));break;case"Group":o=new Ro;break;case"Bone":o=new Zl;break;default:o=new ge}if(o.uuid=t.uuid,void 0!==t.name&&(o.name=t.name),void 0!==t.matrix?(o.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(o.matrixAutoUpdate=t.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(void 0!==t.position&&o.position.fromArray(t.position),void 0!==t.rotation&&o.rotation.fromArray(t.rotation),void 0!==t.quaternion&&o.quaternion.fromArray(t.quaternion),void 0!==t.scale&&o.scale.fromArray(t.scale)),void 0!==t.castShadow&&(o.castShadow=t.castShadow),void 0!==t.receiveShadow&&(o.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(o.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(o.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(o.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&o.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(o.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(o.visible=t.visible),void 0!==t.frustumCulled&&(o.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(o.renderOrder=t.renderOrder),void 0!==t.userData&&(o.userData=t.userData),void 0!==t.layers&&(o.layers.mask=t.layers),void 0!==t.children){const d=t.children;for(let u=0;u<d.length;u++)o.add(this.parseObject(d[u],n,i,r))}if(void 0!==t.animations){const d=t.animations;for(let u=0;u<d.length;u++)o.animations.push(r[d[u]])}if("LOD"===t.type){void 0!==t.autoUpdate&&(o.autoUpdate=t.autoUpdate);const d=t.levels;for(let u=0;u<d.length;u++){const f=d[u],h=o.getObjectByProperty("uuid",f.object);void 0!==h&&o.addLevel(h,f.distance)}}return o}bindSkeletons(t,n){0!==Object.keys(n).length&&t.traverse(function(i){if(!0===i.isSkinnedMesh&&void 0!==i.skeleton){const r=n[i.skeleton];void 0===r?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",i.skeleton):i.bind(r,i.bindMatrix)}})}setTexturePath(t){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(t)}}const RG={UVMapping:Wd,CubeReflectionMapping:dl,CubeRefractionMapping:fl,EquirectangularReflectionMapping:qd,EquirectangularRefractionMapping:$d,CubeUVReflectionMapping:Ta,CubeUVRefractionMapping:hl},OD={RepeatWrapping:pl,ClampToEdgeWrapping:Xn,MirroredRepeatWrapping:ml},BD={NearestFilter:bn,NearestMipmapNearestFilter:Xd,NearestMipmapLinearFilter:Yd,LinearFilter:En,LinearMipmapNearestFilter:Wg,LinearMipmapLinearFilter:Da};function gv(e){typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),Et.call(this,e),this.options={premultiplyAlpha:"none"}}function yv(){this.type="ShapePath",this.color=new ae,this.subPaths=[],this.currentPath=null}function vv(e){this.type="Font",this.data=e}function FG(e,t,n,i,r){const o=r.glyphs[e]||r.glyphs["?"];if(!o)return void console.error('THREE.Font: character "'+e+'" does not exists in font family '+r.familyName+".");const s=new yv;let a,c,l,d,u,f,h,p;if(o.o){const y=o._cachedOutline||(o._cachedOutline=o.o.split(" "));for(let v=0,g=y.length;v<g;)switch(y[v++]){case"m":a=y[v++]*t+n,c=y[v++]*t+i,s.moveTo(a,c);break;case"l":a=y[v++]*t+n,c=y[v++]*t+i,s.lineTo(a,c);break;case"q":l=y[v++]*t+n,d=y[v++]*t+i,u=y[v++]*t+n,f=y[v++]*t+i,s.quadraticCurveTo(u,f,l,d);break;case"b":l=y[v++]*t+n,d=y[v++]*t+i,u=y[v++]*t+n,f=y[v++]*t+i,h=y[v++]*t+n,p=y[v++]*t+i,s.bezierCurveTo(u,f,h,p,l,d)}}return{offsetX:o.ha*t,path:s}}function _v(e){Et.call(this,e)}let ch;gv.prototype=Object.assign(Object.create(Et.prototype),{constructor:gv,isImageBitmapLoader:!0,setOptions:function(t){return this.options=t,this},load:function(e,t,n,i){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=Ss.get(e);if(void 0!==o)return r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o;const s={};s.credentials="anonymous"===this.crossOrigin?"same-origin":"include",fetch(e,s).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,r.options)}).then(function(a){Ss.add(e,a),t&&t(a),r.manager.itemEnd(e)}).catch(function(a){i&&i(a),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}}),Object.assign(yv.prototype,{moveTo:function(e,t){return this.currentPath=new sr,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this},lineTo:function(e,t){return this.currentPath.lineTo(e,t),this},quadraticCurveTo:function(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this},bezierCurveTo:function(e,t,n,i,r,o){return this.currentPath.bezierCurveTo(e,t,n,i,r,o),this},splineThru:function(e){return this.currentPath.splineThru(e),this},toShapes:function(e,t){function n(g){const m=[];for(let _=0,w=g.length;_<w;_++){const b=g[_],x=new ko;x.curves=b.curves,m.push(x)}return m}function i(g,m){const _=m.length;let w=!1;for(let b=_-1,x=0;x<_;b=x++){let D=m[b],I=m[x],R=I.x-D.x,U=I.y-D.y;if(Math.abs(U)>Number.EPSILON){if(U<0&&(D=m[x],R=-R,I=m[b],U=-U),g.y<D.y||g.y>I.y)continue;if(g.y===D.y){if(g.x===D.x)return!0}else{const P=U*(g.x-D.x)-R*(g.y-D.y);if(0===P)return!0;if(P<0)continue;w=!w}}else{if(g.y!==D.y)continue;if(I.x<=g.x&&g.x<=D.x||D.x<=g.x&&g.x<=I.x)return!0}}return w}const r=io.isClockWise,o=this.subPaths;if(0===o.length)return[];if(!0===t)return n(o);let s,a,c;const l=[];if(1===o.length)return a=o[0],c=new ko,c.curves=a.curves,l.push(c),l;let d=!r(o[0].getPoints());d=e?!d:d;const u=[],f=[];let y,v,h=[],p=0;f[p]=void 0,h[p]=[];for(let g=0,m=o.length;g<m;g++)a=o[g],y=a.getPoints(),s=r(y),s=e?!s:s,s?(!d&&f[p]&&p++,f[p]={s:new ko,p:y},f[p].s.curves=a.curves,d&&p++,h[p]=[]):h[p].push({h:a,p:y[0]});if(!f[0])return n(o);if(f.length>1){let g=!1;const m=[];for(let _=0,w=f.length;_<w;_++)u[_]=[];for(let _=0,w=f.length;_<w;_++){const b=h[_];for(let x=0;x<b.length;x++){const D=b[x];let I=!0;for(let R=0;R<f.length;R++)i(D.p,f[R].p)&&(_!==R&&m.push({froms:_,tos:R,hole:x}),I?(I=!1,u[R].push(D)):g=!0);I&&u[_].push(D)}}m.length>0&&(g||(h=u))}for(let g=0,m=f.length;g<m;g++){c=f[g].s,l.push(c),v=h[g];for(let _=0,w=v.length;_<w;_++)c.holes.push(v[_].h)}return l}}),Object.assign(vv.prototype,{isFont:!0,generateShapes:function(e,t=100){const n=[],i=function PG(e,t,n){const i=Array.from?Array.from(e):String(e).split(""),r=t/n.resolution,o=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*r,s=[];let a=0,c=0;for(let l=0;l<i.length;l++){const d=i[l];if("\n"===d)a=0,c-=o;else{const u=FG(d,r,a,c,n);a+=u.offsetX,s.push(u.path)}}return s}(e,t,this.data);for(let r=0,o=i.length;r<o;r++)Array.prototype.push.apply(n,i[r].toShapes());return n}}),_v.prototype=Object.assign(Object.create(Et.prototype),{constructor:_v,load:function(e,t,n,i){const r=this,o=new Oi(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(s){let a;try{a=JSON.parse(s)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),a=JSON.parse(s.substring(65,s.length-2))}const c=r.parse(a);t&&t(c)},n,i)},parse:function(e){return new vv(e)}});const xv={getContext:function(){return void 0===ch&&(ch=new(window.AudioContext||window.webkitAudioContext)),ch},setContext:function(e){ch=e}};function lh(e){Et.call(this,e)}function wv(e,t,n){Bi.call(this,void 0,n);const i=(new ae).set(e),r=(new ae).set(t),o=new M(i.r,i.g,i.b),s=new M(r.r,r.g,r.b),a=Math.sqrt(Math.PI),c=a*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a),this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c)}function bv(e,t){Bi.call(this,void 0,t);const n=(new ae).set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}lh.prototype=Object.assign(Object.create(Et.prototype),{constructor:lh,load:function(e,t,n,i){const r=this,o=new Oi(r.manager);o.setResponseType("arraybuffer"),o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(s){try{const a=s.slice(0);xv.getContext().decodeAudioData(a,function(l){t(l)})}catch(a){i?i(a):console.error(a),r.manager.itemError(e)}},n,i)}}),wv.prototype=Object.assign(Object.create(Bi.prototype),{constructor:wv,isHemisphereLightProbe:!0,copy:function(e){return Bi.prototype.copy.call(this,e),this},toJSON:function(e){return Bi.prototype.toJSON.call(this,e)}}),bv.prototype=Object.assign(Object.create(Bi.prototype),{constructor:bv,isAmbientLightProbe:!0,copy:function(e){return Bi.prototype.copy.call(this,e),this},toJSON:function(e){return Bi.prototype.toJSON.call(this,e)}});const kD=new Ze,HD=new Ze;function VD(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new pn,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new pn,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(VD.prototype,{update:function(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep;const i=e.projectionMatrix.clone(),r=t.eyeSep/2,o=r*t.near/t.focus,s=t.near*Math.tan(ke.DEG2RAD*t.fov*.5)/t.zoom;let a,c;HD.elements[12]=-r,kD.elements[12]=r,a=-s*t.aspect+o,c=s*t.aspect+o,i.elements[0]=2*t.near/(c-a),i.elements[8]=(c+a)/(c-a),this.cameraL.projectionMatrix.copy(i),a=-s*t.aspect-o,c=s*t.aspect-o,i.elements[0]=2*t.near/(c-a),i.elements[8]=(c+a)/(c-a),this.cameraR.projectionMatrix.copy(i)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(HD),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(kD)}});class UD{constructor(t){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=GD(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const n=GD();t=(n-this.oldTime)/1e3,this.oldTime=n,this.elapsedTime+=t}return t}}function GD(){return(typeof performance>"u"?Date:performance).now()}const Ts=new M,zD=new On,NG=new M,Ds=new M;class OG extends ge{constructor(){super(),this.type="AudioListener",this.context=xv.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new UD}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const n=this.context.listener,i=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Ts,zD,NG),Ds.set(0,0,-1).applyQuaternion(zD),n.positionX){const r=this.context.currentTime+this.timeDelta;n.positionX.linearRampToValueAtTime(Ts.x,r),n.positionY.linearRampToValueAtTime(Ts.y,r),n.positionZ.linearRampToValueAtTime(Ts.z,r),n.forwardX.linearRampToValueAtTime(Ds.x,r),n.forwardY.linearRampToValueAtTime(Ds.y,r),n.forwardZ.linearRampToValueAtTime(Ds.z,r),n.upX.linearRampToValueAtTime(i.x,r),n.upY.linearRampToValueAtTime(i.y,r),n.upZ.linearRampToValueAtTime(i.z,r)}else n.setPosition(Ts.x,Ts.y,Ts.z),n.setOrientation(Ds.x,Ds.y,Ds.z,i.x,i.y,i.z)}}class Mv extends ge{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const n=this.context.createBufferSource();return n.buffer=this.buffer,n.loop=this.loop,n.loopStart=this.loopStart,n.loopEnd=this.loopEnd,n.onended=this.onEnded.bind(this),n.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=n,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,n=this.filters.length;t<n;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,n=this.filters.length;t<n;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const Cs=new M,jD=new On,BG=new M,As=new M;class kG extends Mv{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,n,i){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=n,this.panner.coneOuterGain=i,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(Cs,jD,BG),As.set(0,0,1).applyQuaternion(jD);const n=this.panner;if(n.positionX){const i=this.context.currentTime+this.listener.timeDelta;n.positionX.linearRampToValueAtTime(Cs.x,i),n.positionY.linearRampToValueAtTime(Cs.y,i),n.positionZ.linearRampToValueAtTime(Cs.z,i),n.orientationX.linearRampToValueAtTime(As.x,i),n.orientationY.linearRampToValueAtTime(As.y,i),n.orientationZ.linearRampToValueAtTime(As.z,i)}else n.setPosition(Cs.x,Cs.y,Cs.z),n.setOrientation(As.x,As.y,As.z)}}class WD{constructor(t,n=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=n,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const n=this.getFrequencyData();for(let i=0;i<n.length;i++)t+=n[i];return t/n.length}}function Ev(e,t,n){let i,r,o;switch(this.binding=e,this.valueSize=n,t){case"quaternion":i=this._slerp,r=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(Ev.prototype,{accumulate:function(e,t){const n=this.buffer,i=this.valueSize,r=e*i+i;let o=this.cumulativeWeight;if(0===o){for(let s=0;s!==i;++s)n[r+s]=n[s];o=t}else o+=t,this._mixBufferRegion(n,r,0,t/o,i);this.cumulativeWeight=o},accumulateAdditive:function(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e},apply:function(e){const t=this.valueSize,n=this.buffer,i=e*t+t,r=this.cumulativeWeight,o=this.cumulativeWeightAdditive,s=this.binding;this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1&&this._mixBufferRegion(n,i,t*this._origIndex,1-r,t),o>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let a=t,c=t+t;a!==c;++a)if(n[a]!==n[a+t]){s.setValue(n,i);break}},saveOriginalState:function(){const t=this.buffer,n=this.valueSize,i=n*this._origIndex;this.binding.getValue(t,i);for(let r=n,o=i;r!==o;++r)t[r]=t[i+r%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){this.binding.setValue(this.buffer,3*this.valueSize)},_setAdditiveIdentityNumeric:function(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]},_select:function(e,t,n,i,r){if(i>=.5)for(let o=0;o!==r;++o)e[t+o]=e[n+o]},_slerp:function(e,t,n,i){On.slerpFlat(e,t,e,t,e,n,i)},_slerpAdditive:function(e,t,n,i,r){const o=this._workIndex*r;On.multiplyQuaternionsFlat(e,o,e,t,e,n),On.slerpFlat(e,t,e,t,e,o,i)},_lerp:function(e,t,n,i,r){const o=1-i;for(let s=0;s!==r;++s){const a=t+s;e[a]=e[a]*o+e[n+s]*i}},_lerpAdditive:function(e,t,n,i,r){for(let o=0;o!==r;++o){const s=t+o;e[s]=e[s]+e[n+o]*i}}});const Sv="\\[\\]\\.:\\/",HG=new RegExp("["+Sv+"]","g"),Tv="[^"+Sv+"]",VG="[^"+Sv.replace("\\.","")+"]",UG=/((?:WC+[\/:])*)/.source.replace("WC",Tv),GG=/(WCOD+)?/.source.replace("WCOD",VG),zG=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Tv),jG=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Tv),WG=new RegExp("^"+UG+GG+zG+jG+"$"),qG=["material","materials","bones"];function qD(e,t,n){const i=n||Hn.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}function Hn(e,t,n){this.path=t,this.parsedPath=n||Hn.parseTrackName(t),this.node=Hn.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e}function $D(){this.uuid=ke.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,i=arguments.length;n!==i;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}Object.assign(qD.prototype,{getValue:function(e,t){this.bind();const i=this._bindings[this._targetGroup.nCachedObjects_];void 0!==i&&i.getValue(e,t)},setValue:function(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(e,t)},bind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()},unbind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}),Object.assign(Hn,{Composite:qD,create:function(e,t,n){return e&&e.isAnimationObjectGroup?new Hn.Composite(e,t,n):new Hn(e,t,n)},sanitizeNodeName:function(e){return e.replace(/\s/g,"_").replace(HG,"")},parseTrackName:function(e){const t=WG.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==i&&-1!==i){const r=n.nodeName.substring(i+1);-1!==qG.indexOf(r)&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n},findNode:function(e,t){if(!t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(void 0!==n)return n}if(e.children){const n=function(r){for(let o=0;o<r.length;o++){const s=r[o];if(s.name===t||s.uuid===t)return s;const a=n(s.children);if(a)return a}return null},i=n(e.children);if(i)return i}return null}}),Object.assign(Hn.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(t,n){t[n]=this.node[this.propertyName]},function(t,n){const i=this.resolvedProperty;for(let r=0,o=i.length;r!==o;++r)t[n++]=i[r]},function(t,n){t[n]=this.resolvedProperty[this.propertyIndex]},function(t,n){this.resolvedProperty.toArray(t,n)}],SetterByBindingTypeAndVersioning:[[function(t,n){this.targetObject[this.propertyName]=t[n]},function(t,n){this.targetObject[this.propertyName]=t[n],this.targetObject.needsUpdate=!0},function(t,n){this.targetObject[this.propertyName]=t[n],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,n){const i=this.resolvedProperty;for(let r=0,o=i.length;r!==o;++r)i[r]=t[n++]},function(t,n){const i=this.resolvedProperty;for(let r=0,o=i.length;r!==o;++r)i[r]=t[n++];this.targetObject.needsUpdate=!0},function(t,n){const i=this.resolvedProperty;for(let r=0,o=i.length;r!==o;++r)i[r]=t[n++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,n){this.resolvedProperty[this.propertyIndex]=t[n]},function(t,n){this.resolvedProperty[this.propertyIndex]=t[n],this.targetObject.needsUpdate=!0},function(t,n){this.resolvedProperty[this.propertyIndex]=t[n],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,n){this.resolvedProperty.fromArray(t,n)},function(t,n){this.resolvedProperty.fromArray(t,n),this.targetObject.needsUpdate=!0},function(t,n){this.resolvedProperty.fromArray(t,n),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(t,n){this.bind(),this.getValue(t,n)},setValue:function(t,n){this.bind(),this.setValue(t,n)},bind:function(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=Hn.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let c=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let l=0;l<e.length;l++)if(e[l].name===c){c=l;break}break;default:if(void 0===e[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(void 0!==c){if(void 0===e[c])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[c]}}const o=e[i];if(void 0===o)return void console.error("THREE.PropertyBinding: Trying to update property for track: "+t.nodeName+"."+i+" but it wasn't found.",e);let s=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?s=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(s=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(void 0!==r){if("morphTargetInfluences"===i){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[r]&&(r=e.morphTargetDictionary[r])}a=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=r}else void 0!==o.fromArray&&void 0!==o.toArray?(a=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(a=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=i;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][s]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(Hn.prototype,{_getValue_unbound:Hn.prototype.getValue,_setValue_unbound:Hn.prototype.setValue}),Object.assign($D.prototype,{isAnimationObjectGroup:!0,add:function(){const e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,o=r.length;let s,a=e.length,c=this.nCachedObjects_;for(let l=0,d=arguments.length;l!==d;++l){const u=arguments[l],f=u.uuid;let h=t[f];if(void 0===h){h=a++,t[f]=h,e.push(u);for(let p=0,y=o;p!==y;++p)r[p].push(new Hn(u,n[p],i[p]))}else if(h<c){s=e[h];const p=--c,y=e[p];t[y.uuid]=h,e[h]=y,t[f]=p,e[p]=u;for(let v=0,g=o;v!==g;++v){const m=r[v];let w=m[h];m[h]=m[p],void 0===w&&(w=new Hn(u,n[v],i[v])),m[p]=w}}else e[h]!==s&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c},remove:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let o=0,s=arguments.length;o!==s;++o){const a=arguments[o],c=a.uuid,l=t[c];if(void 0!==l&&l>=r){const d=r++,u=e[d];t[u.uuid]=l,e[l]=u,t[c]=d,e[d]=a;for(let f=0,h=i;f!==h;++f){const p=n[f],v=p[l];p[l]=p[d],p[d]=v}}}this.nCachedObjects_=r},uncache:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,o=e.length;for(let s=0,a=arguments.length;s!==a;++s){const l=arguments[s].uuid,d=t[l];if(void 0!==d)if(delete t[l],d<r){const u=--r,f=e[u],h=--o,p=e[h];t[f.uuid]=d,e[d]=f,t[p.uuid]=u,e[u]=p,e.pop();for(let y=0,v=i;y!==v;++y){const g=n[y],_=g[h];g[d]=g[u],g[u]=_,g.pop()}}else{const u=--o,f=e[u];u>0&&(t[f.uuid]=d),e[d]=f,e.pop();for(let h=0,p=i;h!==p;++h){const y=n[h];y[d]=y[u],y.pop()}}}this.nCachedObjects_=r},subscribe_:function(e,t){const n=this._bindingsIndicesByPath;let i=n[e];const r=this._bindings;if(void 0!==i)return r[i];const o=this._paths,s=this._parsedPaths,a=this._objects,l=this.nCachedObjects_,d=new Array(a.length);i=r.length,n[e]=i,o.push(e),s.push(t),r.push(d);for(let u=l,f=a.length;u!==f;++u)d[u]=new Hn(a[u],e,t);return d},unsubscribe_:function(e){const t=this._bindingsIndicesByPath,n=t[e];if(void 0!==n){const i=this._paths,r=this._parsedPaths,o=this._bindings,s=o.length-1,a=o[s];t[e[s]]=n,o[n]=a,o.pop(),r[n]=r[s],r.pop(),i[n]=i[s],i.pop()}}});class $G{constructor(t,n,i=null,r=n.blendMode){this._mixer=t,this._clip=n,this._localRoot=i,this.blendMode=r;const o=n.tracks,s=o.length,a=new Array(s),c={endingStart:ss,endingEnd:ss};for(let l=0;l!==s;++l){const d=o[l].createInterpolant(null);a[l]=d,d.settings=c}this._interpolantSettings=c,this._interpolants=a,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=nT,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,n){return this.loop=t,this.repetitions=n,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,n,i){if(t.fadeOut(n),this.fadeIn(n),i){const r=this._clip.duration,o=t._clip.duration,a=r/o;t.warp(1,o/r,n),this.warp(a,1,n)}return this}crossFadeTo(t,n,i){return t.crossFadeFrom(this,n,i)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,n,i){const r=this._mixer,o=r.time,s=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const c=a.parameterPositions,l=a.sampleValues;return c[0]=o,c[1]=o+i,l[0]=t/s,l[1]=n/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,n,i,r){if(!this.enabled)return void this._updateWeight(t);const o=this._startTime;if(null!==o){const c=(t-o)*i;if(c<0||0===i)return;this._startTime=null,n=i*c}n*=this._updateTimeScale(t);const s=this._updateTime(n),a=this._updateWeight(t);if(a>0){const c=this._interpolants,l=this._propertyBindings;if(this.blendMode===ny)for(let d=0,u=c.length;d!==u;++d)c[d].evaluate(s),l[d].accumulateAdditive(a);else for(let d=0,u=c.length;d!==u;++d)c[d].evaluate(s),l[d].accumulate(r,a)}}_updateWeight(t){let n=0;if(this.enabled){n=this.weight;const i=this._weightInterpolant;if(null!==i){const r=i.evaluate(t)[0];n*=r,t>i.parameterPositions[1]&&(this.stopFading(),0===r&&(this.enabled=!1))}}return this._effectiveWeight=n,n}_updateTimeScale(t){let n=0;if(!this.paused){n=this.timeScale;const i=this._timeScaleInterpolant;null!==i&&(n*=i.evaluate(t)[0],t>i.parameterPositions[1]&&(this.stopWarping(),0===n?this.paused=!0:this.timeScale=n))}return this._effectiveTimeScale=n,n}_updateTime(t){const n=this._clip.duration,i=this.loop;let r=this.time+t,o=this._loopCount;const s=i===iT;if(0===t)return-1===o?r:s&&1==(1&o)?n-r:r;if(i===tT){-1===o&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=n)r=n;else{if(!(r<0)){this.time=r;break e}r=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===o&&(t>=0?(o=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),r>=n||r<0){const a=Math.floor(r/n);r-=n*a,o+=Math.abs(a);const c=this.repetitions-o;if(c<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?n:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===c){const l=t<0;this._setEndings(l,!l,s)}else this._setEndings(!1,!1,s);this._loopCount=o,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(s&&1==(1&o))return n-r}return r}_setEndings(t,n,i){const r=this._interpolantSettings;i?(r.endingStart=as,r.endingEnd=as):(r.endingStart=t?this.zeroSlopeAtStart?as:ss:wl,r.endingEnd=n?this.zeroSlopeAtEnd?as:ss:wl)}_scheduleFading(t,n,i){const r=this._mixer,o=r.time;let s=this._weightInterpolant;null===s&&(s=r._lendControlInterpolant(),this._weightInterpolant=s);const a=s.parameterPositions,c=s.sampleValues;return a[0]=o,c[0]=n,a[1]=o+t,c[1]=i,this}}function Dv(e){this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}Dv.prototype=Object.assign(Object.create(_r.prototype),{constructor:Dv,_bindAction:function(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,r=i.length,o=e._propertyBindings,s=e._interpolants,a=n.uuid,c=this._bindingsByRootAndName;let l=c[a];void 0===l&&(l={},c[a]=l);for(let d=0;d!==r;++d){const u=i[d],f=u.name;let h=l[f];if(void 0!==h)o[d]=h;else{if(h=o[d],void 0!==h){null===h._cacheIndex&&(++h.referenceCount,this._addInactiveBinding(h,a,f));continue}h=new Ev(Hn.create(n,f,t&&t._propertyBindings[d].binding.parsedPath),u.ValueTypeName,u.getValueSize()),++h.referenceCount,this._addInactiveBinding(h,a,f),o[d]=h}s[d].resultBuffer=h.buffer}},_activateAction:function(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];0==r.useCount++&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}},_deactivateAction:function(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];0==--r.useCount&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}},_isActiveAction:function(e){const t=e._cacheIndex;return null!==t&&t<this._nActiveActions},_addInactiveAction:function(e,t,n){const i=this._actions,r=this._actionsByClip;let o=r[t];if(void 0===o)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=o;else{const s=o.knownActions;e._byClipCacheIndex=s.length,s.push(e)}e._cacheIndex=i.length,i.push(e),o.actionByRoot[n]=e},_removeInactiveAction:function(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const r=e._clip.uuid,o=this._actionsByClip,s=o[r],a=s.knownActions,c=a[a.length-1],l=e._byClipCacheIndex;c._byClipCacheIndex=l,a[l]=c,a.pop(),e._byClipCacheIndex=null,delete s.actionByRoot[(e._localRoot||this._root).uuid],0===a.length&&delete o[r],this._removeInactiveBindingsForAction(e)},_removeInactiveBindingsForAction:function(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];0==--r.referenceCount&&this._removeInactiveBinding(r)}},_lendAction:function(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r},_takeBackAction:function(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r},_addInactiveBinding:function(e,t,n){const i=this._bindingsByRootAndName,r=this._bindings;let o=i[t];void 0===o&&(o={},i[t]=o),o[n]=e,e._cacheIndex=r.length,r.push(e)},_removeInactiveBinding:function(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,r=n.path,o=this._bindingsByRootAndName,s=o[i],a=t[t.length-1],c=e._cacheIndex;a._cacheIndex=c,t[c]=a,t.pop(),delete s[r],0===Object.keys(s).length&&delete o[i]},_lendBinding:function(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r},_takeBackBinding:function(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r},_lendControlInterpolant:function(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return void 0===n&&(n=new au(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n},_takeBackControlInterpolant:function(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=t[i];e.__cacheIndex=i,t[i]=e,r.__cacheIndex=n,t[n]=r},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(e,t,n){const i=t||this._root,r=i.uuid;let o="string"==typeof e?Mi.findByName(i,e):e;const s=null!==o?o.uuid:e,a=this._actionsByClip[s];let c=null;if(void 0===n&&(n=null!==o?o.blendMode:Jd),void 0!==a){const d=a.actionByRoot[r];if(void 0!==d&&d.blendMode===n)return d;c=a.knownActions[0],null===o&&(o=c._clip)}if(null===o)return null;const l=new $G(this,o,t,n);return this._bindAction(l,c),this._addInactiveAction(l,s,r),l},existingAction:function(e,t){const n=t||this._root,i=n.uuid,r="string"==typeof e?Mi.findByName(n,e):e,s=this._actionsByClip[r?r.uuid:e];return void 0!==s&&s.actionByRoot[i]||null},stopAllAction:function(){const e=this._actions;for(let n=this._nActiveActions-1;n>=0;--n)e[n].stop();return this},update:function(e){const t=this._actions,n=this._nActiveActions,i=this.time+=e*=this.timeScale,r=Math.sign(e),o=this._accuIndex^=1;for(let c=0;c!==n;++c)t[c]._update(i,e,r,o);const s=this._bindings,a=this._nActiveBindings;for(let c=0;c!==a;++c)s[c].apply(o);return this},setTime:function(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)},getRoot:function(){return this._root},uncacheClip:function(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,r=i[n];if(void 0!==r){const o=r.knownActions;for(let s=0,a=o.length;s!==a;++s){const c=o[s];this._deactivateAction(c);const l=c._cacheIndex,d=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,d._cacheIndex=l,t[l]=d,t.pop(),this._removeInactiveBindingsForAction(c)}delete i[n]}},uncacheRoot:function(e){const t=e.uuid,n=this._actionsByClip;for(const o in n){const a=n[o].actionByRoot[t];void 0!==a&&(this._deactivateAction(a),this._removeInactiveAction(a))}const r=this._bindingsByRootAndName[t];if(void 0!==r)for(const o in r){const s=r[o];s.restoreOriginalState(),this._removeInactiveBinding(s)}},uncacheAction:function(e,t){const n=this.existingAction(e,t);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}});class uh{constructor(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new uh(void 0===this.value.clone?this.value:this.value.clone())}}function Cv(e,t,n){wi.call(this,e,t),this.meshPerAttribute=n||1}function Av(e,t,n,i,r){this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}function Iv(e,t,n,i){this.ray=new Na(e,t),this.near=n||0,this.far=i||1/0,this.camera=null,this.layers=new my,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function XD(e,t){return e.distance-t.distance}function Lv(e,t,n,i){if(e.layers.test(t.layers)&&e.raycast(t,n),!0===i){const r=e.children;for(let o=0,s=r.length;o<s;o++)Lv(r[o],t,n,!0)}}Cv.prototype=Object.assign(Object.create(wi.prototype),{constructor:Cv,isInstancedInterleavedBuffer:!0,copy:function(e){return wi.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},clone:function(e){const t=wi.prototype.clone.call(this,e);return t.meshPerAttribute=this.meshPerAttribute,t},toJSON:function(e){const t=wi.prototype.toJSON.call(this,e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}),Object.defineProperty(Av.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(Av.prototype,{isGLBufferAttribute:!0,setBuffer:function(e){return this.buffer=e,this},setType:function(e,t){return this.type=e,this.elementSize=t,this},setItemSize:function(e){return this.itemSize=e,this},setCount:function(e){return this.count=e,this}}),Object.assign(Iv.prototype,{set:function(e,t){this.ray.set(e,t)},setFromCamera:function(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)},intersectObject:function(e,t,n){const i=n||[];return Lv(e,this,i,t),i.sort(XD),i},intersectObjects:function(e,t,n){const i=n||[];if(!1===Array.isArray(e))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),i;for(let r=0,o=e.length;r<o;r++)Lv(e[r],this,i,t);return i.sort(XD),i}});class XG{constructor(t=1,n=0,i=0){return this.radius=t,this.phi=n,this.theta=i,this}set(t,n,i){return this.radius=t,this.phi=n,this.theta=i,this}clone(){return(new this.constructor).copy(this)}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,n,i){return this.radius=Math.sqrt(t*t+n*n+i*i),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,i),this.phi=Math.acos(ke.clamp(n/this.radius,-1,1))),this}}class YG{constructor(t,n,i){return this.radius=void 0!==t?t:1,this.theta=void 0!==n?n:0,this.y=void 0!==i?i:0,this}set(t,n,i){return this.radius=t,this.theta=n,this.y=i,this}clone(){return(new this.constructor).copy(this)}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,n,i){return this.radius=Math.sqrt(t*t+i*i),this.theta=Math.atan2(t,i),this.y=n,this}}const YD=new V;class ZD{constructor(t,n){Object.defineProperty(this,"isBox2",{value:!0}),this.min=void 0!==t?t:new V(1/0,1/0),this.max=void 0!==n?n:new V(-1/0,-1/0)}set(t,n){return this.min.copy(t),this.max.copy(n),this}setFromPoints(t){this.makeEmpty();for(let n=0,i=t.length;n<i;n++)this.expandByPoint(t[n]);return this}setFromCenterAndSize(t,n){const i=YD.copy(n).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return void 0===t&&(console.warn("THREE.Box2: .getCenter() target is now required"),t=new V),this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return void 0===t&&(console.warn("THREE.Box2: .getSize() target is now required"),t=new V),this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,n){return void 0===n&&(console.warn("THREE.Box2: .getParameter() target is now required"),n=new V),n.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,n){return void 0===n&&(console.warn("THREE.Box2: .clampPoint() target is now required"),n=new V),n.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return YD.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const JD=new M,dh=new M;class QD{constructor(t,n){this.start=void 0!==t?t:new M,this.end=void 0!==n?n:new M}set(t,n){return this.start.copy(t),this.end.copy(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return void 0===t&&(console.warn("THREE.Line3: .getCenter() target is now required"),t=new M),t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return void 0===t&&(console.warn("THREE.Line3: .delta() target is now required"),t=new M),t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,n){return void 0===n&&(console.warn("THREE.Line3: .at() target is now required"),n=new M),this.delta(n).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,n){JD.subVectors(t,this.start),dh.subVectors(this.end,this.start);const i=dh.dot(dh);let o=dh.dot(JD)/i;return n&&(o=ke.clamp(o,0,1)),o}closestPointToPoint(t,n,i){const r=this.closestPointToPointParameter(t,n);return void 0===i&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),i=new M),this.delta(i).multiplyScalar(r).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}}function fu(e){ge.call(this),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}(fu.prototype=Object.create(ge.prototype)).constructor=fu,fu.prototype.isImmediateRenderObject=!0;const KD=new M;class ZG extends ge{constructor(t,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const i=new Me,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let s=0,a=1,c=32;s<c;s++,a++){const l=s/c*Math.PI*2,d=a/c*Math.PI*2;r.push(Math.cos(l),Math.sin(l),1,Math.cos(d),Math.sin(d),1)}i.setAttribute("position",new te(r,3));const o=new $t({fog:!1,toneMapped:!1});this.cone=new Qn(i,o),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const t=this.light.distance?this.light.distance:1e3,n=t*Math.tan(this.light.angle);this.cone.scale.set(n,n,t),KD.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(KD),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Ho=new M,fh=new Ze,Rv=new Ze;class e1 extends Qn{constructor(t){const n=t1(t),i=new Me,r=[],o=[],s=new ae(0,0,1),a=new ae(0,1,0);for(let l=0;l<n.length;l++){const d=n[l];d.parent&&d.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),o.push(s.r,s.g,s.b),o.push(a.r,a.g,a.b))}i.setAttribute("position",new te(r,3)),i.setAttribute("color",new te(o,3)),super(i,new $t({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=n,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const n=this.bones,i=this.geometry,r=i.getAttribute("position");Rv.copy(this.root.matrixWorld).invert();for(let o=0,s=0;o<n.length;o++){const a=n[o];a.parent&&a.parent.isBone&&(fh.multiplyMatrices(Rv,a.matrixWorld),Ho.setFromMatrixPosition(fh),r.setXYZ(s,Ho.x,Ho.y,Ho.z),fh.multiplyMatrices(Rv,a.parent.matrixWorld),Ho.setFromMatrixPosition(fh),r.setXYZ(s+1,Ho.x,Ho.y,Ho.z),s+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function t1(e){const t=[];e&&e.isBone&&t.push(e);for(let n=0;n<e.children.length;n++)t.push.apply(t,t1(e.children[n]));return t}class JG extends Gt{constructor(t,n,i){super(new Gf(n,4,2),new Pi({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.light.updateMatrixWorld(),this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const QG=new M,n1=new ae,i1=new ae;class KG extends ge{constructor(t,n,i){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=i;const r=new Uf(n);r.rotateY(.5*Math.PI),this.material=new Pi({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const o=r.getAttribute("position"),s=new Float32Array(3*o.count);r.setAttribute("color",new Ee(s,3)),this.add(new Gt(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const n=t.geometry.getAttribute("color");n1.copy(this.light.color),i1.copy(this.light.groundColor);for(let i=0,r=n.count;i<r;i++){const o=i<r/2?n1:i1;n.setXYZ(i,o.r,o.g,o.b)}n.needsUpdate=!0}t.lookAt(QG.setFromMatrixPosition(this.light.matrixWorld).negate())}}class r1 extends Qn{constructor(t=10,n=10,i=4473924,r=8947848){i=new ae(i),r=new ae(r);const o=n/2,s=t/n,a=t/2,c=[],l=[];for(let f=0,h=0,p=-a;f<=n;f++,p+=s){c.push(-a,0,p,a,0,p),c.push(p,0,-a,p,0,a);const y=f===o?i:r;y.toArray(l,h),h+=3,y.toArray(l,h),h+=3,y.toArray(l,h),h+=3,y.toArray(l,h),h+=3}const d=new Me;d.setAttribute("position",new te(c,3)),d.setAttribute("color",new te(l,3)),super(d,new $t({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}class ez extends Qn{constructor(t=10,n=16,i=8,r=64,o=4473924,s=8947848){o=new ae(o),s=new ae(s);const a=[],c=[];for(let u=0;u<=n;u++){const f=u/n*(2*Math.PI),h=Math.sin(f)*t,p=Math.cos(f)*t;a.push(0,0,0),a.push(h,0,p);const y=1&u?o:s;c.push(y.r,y.g,y.b),c.push(y.r,y.g,y.b)}for(let u=0;u<=i;u++){const f=1&u?o:s,h=t-t/i*u;for(let p=0;p<r;p++){let y=p/r*(2*Math.PI),v=Math.sin(y)*h,g=Math.cos(y)*h;a.push(v,0,g),c.push(f.r,f.g,f.b),y=(p+1)/r*(2*Math.PI),v=Math.sin(y)*h,g=Math.cos(y)*h,a.push(v,0,g),c.push(f.r,f.g,f.b)}}const l=new Me;l.setAttribute("position",new te(a,3)),l.setAttribute("color",new te(c,3)),super(l,new $t({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}}const o1=new M,hh=new M,s1=new M;class tz extends ge{constructor(t,n,i){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,void 0===n&&(n=1);let r=new Me;r.setAttribute("position",new te([-n,n,0,n,n,0,n,-n,0,-n,-n,0,-n,n,0],3));const o=new $t({fog:!1,toneMapped:!1});this.lightPlane=new Ni(r,o),this.add(this.lightPlane),r=new Me,r.setAttribute("position",new te([0,0,0,0,0,1],3)),this.targetLine=new Ni(r,o),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){o1.setFromMatrixPosition(this.light.matrixWorld),hh.setFromMatrixPosition(this.light.target.matrixWorld),s1.subVectors(hh,o1),this.lightPlane.lookAt(hh),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(hh),this.targetLine.scale.z=s1.length()}}const ph=new M,rn=new Mr;class nz extends Qn{constructor(t){const n=new Me,i=new $t({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],o=[],s={},a=new ae(16755200),c=new ae(16711680),l=new ae(43775),d=new ae(16777215),u=new ae(3355443);function f(p,y,v){h(p,v),h(y,v)}function h(p,y){r.push(0,0,0),o.push(y.r,y.g,y.b),void 0===s[p]&&(s[p]=[]),s[p].push(r.length/3-1)}f("n1","n2",a),f("n2","n4",a),f("n4","n3",a),f("n3","n1",a),f("f1","f2",a),f("f2","f4",a),f("f4","f3",a),f("f3","f1",a),f("n1","f1",a),f("n2","f2",a),f("n3","f3",a),f("n4","f4",a),f("p","n1",c),f("p","n2",c),f("p","n3",c),f("p","n4",c),f("u1","u2",l),f("u2","u3",l),f("u3","u1",l),f("c","t",d),f("p","c",u),f("cn1","cn2",u),f("cn3","cn4",u),f("cf1","cf2",u),f("cf3","cf4",u),n.setAttribute("position",new te(r,3)),n.setAttribute("color",new te(o,3)),super(n,i),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update()}update(){const t=this.geometry,n=this.pointMap;rn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),cn("c",n,t,rn,0,0,-1),cn("t",n,t,rn,0,0,1),cn("n1",n,t,rn,-1,-1,-1),cn("n2",n,t,rn,1,-1,-1),cn("n3",n,t,rn,-1,1,-1),cn("n4",n,t,rn,1,1,-1),cn("f1",n,t,rn,-1,-1,1),cn("f2",n,t,rn,1,-1,1),cn("f3",n,t,rn,-1,1,1),cn("f4",n,t,rn,1,1,1),cn("u1",n,t,rn,.7,1.1,-1),cn("u2",n,t,rn,-.7,1.1,-1),cn("u3",n,t,rn,0,2,-1),cn("cf1",n,t,rn,-1,0,1),cn("cf2",n,t,rn,1,0,1),cn("cf3",n,t,rn,0,-1,1),cn("cf4",n,t,rn,0,1,1),cn("cn1",n,t,rn,-1,0,-1),cn("cn2",n,t,rn,1,0,-1),cn("cn3",n,t,rn,0,-1,-1),cn("cn4",n,t,rn,0,1,-1),t.getAttribute("position").needsUpdate=!0}}function cn(e,t,n,i,r,o,s){ph.set(r,o,s).unproject(i);const a=t[e];if(void 0!==a){const c=n.getAttribute("position");for(let l=0,d=a.length;l<d;l++)c.setXYZ(a[l],ph.x,ph.y,ph.z)}}const mh=new xr;class a1 extends Qn{constructor(t,n=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(24),o=new Me;o.setIndex(new Ee(i,1)),o.setAttribute("position",new Ee(r,3)),super(o,new $t({color:n,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(void 0!==t&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&mh.setFromObject(this.object),mh.isEmpty())return;const n=mh.min,i=mh.max,r=this.geometry.attributes.position,o=r.array;o[0]=i.x,o[1]=i.y,o[2]=i.z,o[3]=n.x,o[4]=i.y,o[5]=i.z,o[6]=n.x,o[7]=n.y,o[8]=i.z,o[9]=i.x,o[10]=n.y,o[11]=i.z,o[12]=i.x,o[13]=i.y,o[14]=n.z,o[15]=n.x,o[16]=i.y,o[17]=n.z,o[18]=n.x,o[19]=n.y,o[20]=n.z,o[21]=i.x,o[22]=n.y,o[23]=n.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t){return Qn.prototype.copy.call(this,t),this.object=t.object,this}}class iz extends Qn{constructor(t,n=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),o=new Me;o.setIndex(new Ee(i,1)),o.setAttribute("position",new te([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(o,new $t({color:n,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const n=this.box;n.isEmpty()||(n.getCenter(this.position),n.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}}class rz extends Ni{constructor(t,n=1,i=16776960){const r=i,s=new Me;s.setAttribute("position",new te([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),s.computeBoundingSphere(),super(s,new $t({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=n;const c=new Me;c.setAttribute("position",new te([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),c.computeBoundingSphere(),this.add(new Gt(c,new Pi({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){let n=-this.plane.constant;Math.abs(n)<1e-8&&(n=1e-8),this.scale.set(.5*this.size,.5*this.size,n),this.children[0].material.side=n<0?wn:Ea,this.lookAt(this.plane.normal),super.updateMatrixWorld(t)}}const c1=new M;let gh,Pv;class oz extends ge{constructor(t,n,i,r,o,s){super(),this.type="ArrowHelper",void 0===t&&(t=new M(0,0,1)),void 0===n&&(n=new M(0,0,0)),void 0===i&&(i=1),void 0===r&&(r=16776960),void 0===o&&(o=.2*i),void 0===s&&(s=.2*o),void 0===gh&&(gh=new Me,gh.setAttribute("position",new te([0,0,0,0,1,0],3)),Pv=new tu(0,.5,1,5,1),Pv.translate(0,-.5,0)),this.position.copy(n),this.line=new Ni(gh,new $t({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Gt(Pv,new Pi({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(i,o,s)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{c1.set(t.z,0,-t.x).normalize();const n=Math.acos(t.y);this.quaternion.setFromAxisAngle(c1,n)}}setLength(t,n,i){void 0===n&&(n=.2*t),void 0===i&&(i=.2*n),this.line.scale.set(1,Math.max(1e-4,t-n),1),this.line.updateMatrix(),this.cone.scale.set(i,n,i),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}}class l1 extends Qn{constructor(t=1){const n=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],r=new Me;r.setAttribute("position",new te(n,3)),r.setAttribute("color",new te([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(r,new $t({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}}const u1=new Float32Array(1),sz=new Int32Array(u1.buffer),az={toHalfFloat:function(e){u1[0]=e;const t=sz[0];let n=t>>16&32768,i=t>>12&2047;const r=t>>23&255;return r<103?n:r>142?(n|=31744,n|=(255==r?0:1)&&8388607&t,n):r<113?(i|=2048,n|=(i>>114-r)+(i>>113-r&1),n):(n|=r-112<<10|i>>1,n+=1&i,n)}},Ar=Math.pow(2,8),d1=[.125,.215,.35,.446,.526,.582],f1=5+d1.length,Ir={[Yn]:0,[bl]:1,[Kd]:2,[iy]:3,[ry]:4,[oy]:5,[Qd]:6},Fv=new lc,{_lodPlanes:hu,_sizeLods:h1,_sigmas:yh}=uz(),p1=new ae;let Nv=null;const Is=(1+Math.sqrt(5))/2,fc=1/Is,m1=[new M(1,1,1),new M(-1,1,1),new M(1,1,-1),new M(-1,1,-1),new M(0,Is,fc),new M(0,Is,-fc),new M(fc,0,Is),new M(-fc,0,Is),new M(Is,fc,0),new M(-Is,fc,0)];class cz{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=function dz(e){return new ro({name:"SphericalGaussianBlur",defines:{n:e},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:new Float32Array(e)},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:new M(0,1,0)},inputEncoding:{value:Ir[Yn]},outputEncoding:{value:Ir[Yn]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:$r,depthTest:!1,depthWrite:!1})}(20),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,n=0,i=.1,r=100){Nv=this._renderer.getRenderTarget();const o=this._allocateTargets();return this._sceneToCubeUV(t,i,r,o),n>0&&this._blur(o,0,0,n),this._applyPMREM(o),this._cleanup(o),o}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=v1(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=y1(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let t=0;t<hu.length;t++)hu[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Nv),t.scissorTest=!1,vh(t,0,0,t.width,t.height)}_fromTexture(t){Nv=this._renderer.getRenderTarget();const n=this._allocateTargets(t);return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(t){const n={magFilter:bn,minFilter:bn,generateMipmaps:!1,type:Ca,format:vS,encoding:(e=t,void 0===e||e.type!==Ca||e.encoding!==Yn&&e.encoding!==bl&&e.encoding!==Qd?Kd:t.encoding),depthBuffer:!1},i=g1(n);var e;return i.depthBuffer=!t,this._pingPongRenderTarget=g1(n),i}_compileMaterial(t){const n=new Gt(hu[0],t);this._renderer.compile(n,Fv)}_sceneToCubeUV(t,n,i,r){const a=new pn(90,1,n,i),c=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],d=this._renderer,u=d.outputEncoding,f=d.toneMapping;d.getClearColor(p1);const h=d.getClearAlpha();d.toneMapping=rs,d.outputEncoding=Yn;let p=t.background;if(p&&p.isColor){p.convertSRGBToLinear();const y=Math.max(p.r,p.g,p.b),v=Math.min(Math.max(Math.ceil(Math.log2(y)),-128),127);p=p.multiplyScalar(Math.pow(2,-v)),d.setClearColor(p,(v+128)/255),t.background=null}for(let y=0;y<6;y++){const v=y%3;0==v?(a.up.set(0,c[y],0),a.lookAt(l[y],0,0)):1==v?(a.up.set(0,0,c[y]),a.lookAt(0,l[y],0)):(a.up.set(0,c[y],0),a.lookAt(0,0,l[y])),vh(r,v*Ar,y>2?Ar:0,Ar,Ar),d.setRenderTarget(r),d.render(t,a)}d.toneMapping=f,d.outputEncoding=u,d.setClearColor(p1,h)}_textureToCubeUV(t,n){const i=this._renderer;t.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=v1()):null==this._equirectShader&&(this._equirectShader=y1());const r=t.isCubeTexture?this._cubemapShader:this._equirectShader,o=new Gt(hu[0],r),s=r.uniforms;s.envMap.value=t,t.isCubeTexture||s.texelSize.value.set(1/t.image.width,1/t.image.height),s.inputEncoding.value=Ir[t.encoding],s.outputEncoding.value=Ir[n.texture.encoding],vh(n,0,0,3*Ar,2*Ar),i.setRenderTarget(n),i.render(o,Fv)}_applyPMREM(t){const n=this._renderer,i=n.autoClear;n.autoClear=!1;for(let r=1;r<f1;r++){const o=Math.sqrt(yh[r]*yh[r]-yh[r-1]*yh[r-1]);this._blur(t,r-1,r,o,m1[(r-1)%m1.length])}n.autoClear=i}_blur(t,n,i,r,o){const s=this._pingPongRenderTarget;this._halfBlur(t,s,n,i,r,"latitudinal",o),this._halfBlur(s,t,i,i,r,"longitudinal",o)}_halfBlur(t,n,i,r,o,s,a){const c=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const u=new Gt(hu[r],l),f=l.uniforms,h=h1[i]-1,p=isFinite(o)?Math.PI/(2*h):2*Math.PI/39,y=o/p,v=isFinite(o)?1+Math.floor(3*y):20;v>20&&console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${v} samples when the maximum is set to 20`);const g=[];let m=0;for(let x=0;x<20;++x){const D=x/y,I=Math.exp(-D*D/2);g.push(I),0==x?m+=I:x<v&&(m+=2*I)}for(let x=0;x<g.length;x++)g[x]=g[x]/m;f.envMap.value=t.texture,f.samples.value=v,f.weights.value=g,f.latitudinal.value="latitudinal"===s,a&&(f.poleAxis.value=a),f.dTheta.value=p,f.mipInt.value=8-i,f.inputEncoding.value=Ir[t.texture.encoding],f.outputEncoding.value=Ir[t.texture.encoding];const _=h1[r];vh(n,3*Math.max(0,Ar-2*_),(0===r?0:2*Ar)+2*_*(r>4?r-8+4:0),3*_,2*_),c.setRenderTarget(n),c.render(u,Fv)}}function uz(){const e=[],t=[],n=[];let i=8;for(let r=0;r<f1;r++){const o=Math.pow(2,i);t.push(o);let s=1/o;r>4?s=d1[r-8+4-1]:0==r&&(s=0),n.push(s);const a=1/(o-1),c=-a/2,l=1+a/2,d=[c,c,l,c,l,l,c,c,l,l,c,l],u=6,f=6,h=3,p=2,y=1,v=new Float32Array(h*f*u),g=new Float32Array(p*f*u),m=new Float32Array(y*f*u);for(let w=0;w<u;w++){const b=w%3*2/3-1,x=w>2?0:-1;v.set([b,x,0,b+2/3,x,0,b+2/3,x+1,0,b,x,0,b+2/3,x+1,0,b,x+1,0],h*f*w),g.set(d,p*f*w),m.set([w,w,w,w,w,w],y*f*w)}const _=new Me;_.setAttribute("position",new Ee(v,h)),_.setAttribute("uv",new Ee(g,p)),_.setAttribute("faceIndex",new Ee(m,y)),e.push(_),i>4&&i--}return{_lodPlanes:e,_sizeLods:t,_sigmas:n}}function g1(e){const t=new yi(3*Ar,3*Ar,e);return t.texture.mapping=Ta,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function vh(e,t,n,i,r){e.viewport.set(t,n,i,r),e.scissor.set(t,n,i,r)}function y1(){return new ro({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:new V(1,1)},inputEncoding:{value:Ir[Yn]},outputEncoding:{value:Ir[Yn]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:$r,depthTest:!1,depthWrite:!1})}function v1(){return new ro({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Ir[Yn]},outputEncoding:{value:Ir[Yn]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:$r,depthTest:!1,depthWrite:!1})}function fz(e,t,n,i,r,o,s){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new Dl(e,t,n,r,o,s)}const hz=0,pz=1,mz=0,gz=1,yz=2;function vz(e){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),e}function _z(e=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),e.isMultiMaterial=!0,e.materials=e,e.clone=function(){return e.slice()},e}function xz(e,t){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new tc(e,t)}function wz(e){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new $l(e)}function bz(e,t){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new tc(e,t)}function Mz(e){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new er(e)}function Ez(e){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new er(e)}function Sz(e){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new er(e)}function Tz(e,t,n){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new M(e,t,n)}function Dz(e,t){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new Ee(e,t).setUsage(ls)}function Cz(e,t){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new Cl(e,t)}function Az(e,t){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new Al(e,t)}function Iz(e,t){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new Il(e,t)}function Lz(e,t){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new Ll(e,t)}function Rz(e,t){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new hs(e,t)}function Pz(e,t){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new Rl(e,t)}function Fz(e,t){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new ps(e,t)}function Nz(e,t){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new te(e,t)}function Oz(e,t){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new Fl(e,t)}function _1(e){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),kn.call(this,e),this.type="catmullrom",this.closed=!0}function x1(e){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),kn.call(this,e),this.type="catmullrom"}function kv(e){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),kn.call(this,e),this.type="catmullrom"}function Bz(e){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new l1(e)}function kz(e,t){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new a1(e,t)}function Hz(e,t){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new Qn(new zy(e.geometry),new $t({color:void 0!==t?t:16777215}))}function Vz(e,t){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new Qn(new iv(e.geometry),new $t({color:void 0!==t?t:16777215}))}function Uz(e){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new Oi(e)}function Gz(e){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new Zf(e)}function zz(e,t,n){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new to(e,n)}xe.create=function(e,t){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(xe.prototype),e.prototype.constructor=e,e.prototype.getPoint=t,e},Object.assign(oo.prototype,{createPointsGeometry:function(e){console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=this.getPoints(e);return this.createGeometry(t)},createSpacedPointsGeometry:function(e){console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=this.getSpacedPoints(e);return this.createGeometry(t)},createGeometry:function(e){console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=new Lt;for(let n=0,i=e.length;n<i;n++){const r=e[n];t.vertices.push(new M(r.x,r.y,r.z||0))}return t}}),Object.assign(sr.prototype,{fromPoints:function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)}}),_1.prototype=Object.create(kn.prototype),x1.prototype=Object.create(kn.prototype),kv.prototype=Object.create(kn.prototype),Object.assign(kv.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),r1.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},e1.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(Et.prototype,{extractUrlBase:function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),mv.extractUrlBase(e)}}),Et.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(ZD.prototype,{center:function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},size:function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(xr.prototype,{center:function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionSphere:function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},size:function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(Zr.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),Hl.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)},QD.prototype.center=function(e){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(e)},Object.assign(ke,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(e){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),ke.floorPowerOfTwo(e)},nextPowerOfTwo:function(e){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),ke.ceilPowerOfTwo(e)}}),Object.assign(Zn.prototype,{flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},multiplyVector3:function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(e){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()}}),Object.assign(Ze.prototype,{extractPosition:function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new M).setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector4:function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},crossVector:function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(e,t,n,i,r,o){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,t,i,n,r,o)},getInverse:function(e){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()}}),wr.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)},Object.assign(On.prototype,{multiplyVector3:function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}}),Object.assign(Na.prototype,{isIntersectionBox:function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionPlane:function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},isIntersectionSphere:function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)}}),Object.assign(An.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(e,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,t)},midpoint:function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},normal:function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},plane:function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)}}),Object.assign(An,{barycoordFromPoint:function(e,t,n,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),An.getBarycoord(e,t,n,i,r)},normal:function(e,t,n,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),An.getNormal(e,t,n,i)}}),Object.assign(ko.prototype,{extractAllPoints:function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},extrude:function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new qy(this,e)},makeGeometry:function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Jy(this,e)}}),Object.assign(V.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(M.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},getScaleFromMatrix:function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},getColumnFromMatrix:function(e,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,e)},applyProjection:function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},fromAttribute:function(e,t,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(It.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Lt.prototype,{computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.assign(ge.prototype,{getChildByName:function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(e,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,e)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(ge.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(Gt.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(Gt.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),rT},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(Xl.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(Jl.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),Yl.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(xe.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(e){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=e}}),pn.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==t&&(this.filmGauge=t),this.setFocalLength(e)},Object.defineProperties(kt.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}}),Object.defineProperties(Ee.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===ls},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(ls)}}}),Object.assign(Ee.prototype,{setDynamic:function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?ls:Ml),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(Me.prototype,{addIndex:function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},addAttribute:function(e,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),t&&t.isBufferAttribute||t&&t.isInterleavedBufferAttribute?"index"===e?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(e,t):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new Ee(arguments[1],arguments[2])))},addDrawCall:function(e,t,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,t)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},applyMatrix:function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(Me.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(du.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(e){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=e}}}),Object.defineProperties(Iv.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(e){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=e}}}),Object.defineProperties(wi.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===ls},set:function(e){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(e)}}}),Object.assign(wi.prototype,{setDynamic:function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?ls:Ml),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(ou.prototype,{getArrays:function(){console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")}}),Object.assign(Ry.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}}),Object.defineProperties(uh.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(Pe.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new ae}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===Bg}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}}}),Object.defineProperties(Bo.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(Oo.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(e){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=e}}}),Object.defineProperties(Jn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}}),Object.assign(zl.prototype,{clearTarget:function(e,t,n,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(t,n,i)},animate:function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(zl.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===e?bl:Yn}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties($T.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(yi.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}}),Object.defineProperties(Mv.prototype,{load:{value:function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return(new lh).load(e,function(i){t.setBuffer(i)}),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),WD.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},gs.prototype.updateCubeMap=function(e,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,t)},gs.prototype.clear=function(e,t,n,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(e,t,n,i)};const jz={merge:function(e,t,n){let i;console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),t.isMesh&&(t.matrixAutoUpdate&&t.updateMatrix(),i=t.matrix,t=t.geometry),e.merge(t,i,n)},center:function(e){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),e.center()}};function Wz(){console.error("THREE.CanvasRenderer has been removed")}function qz(){console.error("THREE.JSONLoader has been removed.")}us.crossOrigin=void 0,us.loadTexture=function(e,t,n,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new Jf;r.setCrossOrigin(this.crossOrigin);const o=r.load(e,n,void 0,i);return t&&(o.mapping=t),o},us.loadTextureCube=function(e,t,n,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new Yf;r.setCrossOrigin(this.crossOrigin);const o=r.load(e,n,void 0,i);return t&&(o.mapping=t),o},us.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},us.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const $z={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function Xz(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:PE}}));var Yz=Tt(833),w1=Tt.n(Yz);let Zz=(()=>{class e{constructor(n){this.el=n,this.title="angular-vanta-app"}ngOnInit(){this.vantaEffect=w1()({el:this.el.nativeElement,THREE:it})}ngOnDestroy(){this.vantaEffect&&this.vantaEffect.destroy()}}return e.\u0275fac=function(n){return new(n||e)(ot(ts))},e.\u0275cmp=Nh({type:e,selectors:[["app-root"]],decls:1,vars:1,template:function(n,i){1&n&&Hw(0),2&n&&pd("",i.title,"\n")},styles:["[_nghost-%COMP%]{z-index:0;position:absolute;left:0;top:0;width:100%;height:100%}"]}),e})();window.BIRDS=w1();let Jz=(()=>{class e{}return e.\u0275fac=function(n){return new(n||e)},e.\u0275mod=_c({type:e,bootstrap:[Zz]}),e.\u0275inj=Os({imports:[$3]}),e})();(function I2(){GM=!1})(),q3().bootstrapModule(Jz).catch(e=>console.error(e))}},pc=>{pc(pc.s=78)}]);